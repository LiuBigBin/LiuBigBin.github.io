<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="new-C-11常规特性之auto和decltype" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之auto和decltype/" class="article-date">
  <time datetime="2016-07-06T10:48:56.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之auto和decltype/">C++11常规特性之auto和decltype</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++11之前，auto用来声明对象的存储期，修饰普通局部栈变量，是自动存储，这种对象会自动创建和销毁。在C++11新特性中，用来实现类型的推判。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。特别是在循环遍历容器的时候，auto会显得很有用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> Ptr();</span><br><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>,&amp;r=i;</span><br><span class="line"><span class="keyword">auto</span> a=r;<span class="comment">//a为int，因为r是i的别名，i为int。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> b = v.begin();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = begin(<span class="built_in">map</span>); it != end(<span class="built_in">map</span>); ++it) &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，auto不能用来声明函数的返回值。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T1, typename T2&gt;</span><br><span class="line"><span class="keyword">auto</span> compose(T1 t1, T2 t2) -&gt; decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> v = compose(<span class="number">2</span>, <span class="number">3.14</span>); <span class="comment">// v's type is double</span></span><br></pre></td></tr></table></figure></p>
<p>使用auto时,你只是需要一个变量的类型初始化。如果你需要一个类型不是一个变量，那么你需要用到decltype,例如返回类型。decltype是根据变量推导获取出变量的类型。目的是选择并返回操作数的数据类型，重要的是，在此过程中编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum=x;  <span class="comment">//sum的类型就是f返回值的类型， 但是这里不执行函数f()</span></span><br><span class="line"><span class="keyword">auto</span> x= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(x*y)</span> Type</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x*y) xy;  <span class="comment">//xy的类型为int</span></span><br><span class="line"><span class="comment">//decltype声明函数指针的时，关键是要记住decltype返回的是一个函数的类型的，因此要加上*声明符才能构成完整的函数指针的类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(f)* k = f; <span class="comment">//直接decltype(f) k = f 是不可以的</span></span><br><span class="line">k(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果decltype使用表达式的结果类型可以作为一条赋值语句的左值，那么decltype返回一个引用类型，例如解引用操作和变量加括号的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c=k; <span class="comment">//c为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = k;  <span class="comment">//d为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) e = k <span class="comment">//e为int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i++) f; <span class="comment">//f 为int类型</span></span><br><span class="line">tecltype(f=k) g <span class="comment">//g为int&amp;类型，必须初始化</span></span><br></pre></td></tr></table></figure></p>
<h4 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h4><h5 id="const和应用"><a href="#const和应用" class="headerlink" title="const和应用"></a>const和应用</h5><p>auto和const的推断与decltype不一样，对于auto，变量顶层的const会被忽略，只保留底层的const<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="keyword">int</span> ci=i,&amp;cr=i;</span><br><span class="line"><span class="keyword">auto</span> a=ci;      <span class="comment">//a为int（忽略顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> b=cr;      <span class="comment">//b为int（忽略顶层const，cr是引用）</span></span><br><span class="line"><span class="keyword">auto</span> c=&amp;i;      <span class="comment">//c为int *</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;ci;     <span class="comment">//d是pointer to const int(&amp;ci为底层const）</span></span><br><span class="line"><span class="comment">//要声明顶层const，前面要加上const关键字；要声明引用要加上&amp;标识符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f=ci; <span class="comment">//ci的推演类型是int,f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g=ci;<span class="comment">// g是一个绑定到ci的引用</span></span><br></pre></td></tr></table></figure></p>
<p>对于decltype，其对const和应用的处理如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x=<span class="number">0</span>;   <span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p=&amp;i,&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b; <span class="comment">//b为int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) y=x;   <span class="comment">//y的类型是const int&amp;，y绑定到x上</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之auto和decltype/" data-id="ciqarm48d005bh8qyojoexjd2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之统一初始化和初始化器列表" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/" class="article-date">
  <time datetime="2016-07-06T10:43:47.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/">C++11常规特性之统一初始化和初始化器列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在c++11以前，程序员，或者初学者经常会感到疑惑关于怎样去初始化一个变量或者是一个对象。<br>初始化经常使用括号，或者是使用大括号，或者是复赋值操作。<br>因为这个原因，c++11提出了统一初始化，以为着使用这初始化列表，下面的做法都是正确的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value[] &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi &#123;<span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">56</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; cities &#123;<span class="string">"Berlin"</span> , <span class="string">"New York "</span> , <span class="string">"london "</span> , <span class="string">"cairo"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span> , <span class="number">3.0</span>&#125;;  <span class="comment">//相当于c（4.0 ， 3.0）；</span></span><br></pre></td></tr></table></figure></p>
<p>一个初始化列表强制使用赋值操作， 也就是为每个变量设置一个默认的初始化值，被初始化为0（NULL 或者是 nullptr）<br>如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">//这是一个未定义的行为</span></span><br><span class="line"><span class="keyword">int</span> i&#123;&#125;； <span class="comment">//i调用默认的构造函数为i赋值为0</span></span><br><span class="line"><span class="keyword">int</span> *p； <span class="comment">//这是一个未定义的行为</span></span><br><span class="line"><span class="keyword">int</span> *p&#123;&#125; ;<span class="comment">// p被初始化为一个nullptr</span></span><br></pre></td></tr></table></figure></p>
<p>初始化类表不会进行隐式转换<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  x1（<span class="number">5.3</span>）； <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span> <span class="comment">//5</span></span><br><span class="line"><span class="keyword">int</span> xi&#123;<span class="number">5.0</span>&#125; <span class="comment">//精确地   所以会出现error</span></span><br><span class="line"><span class="keyword">int</span> x4 = &#123;<span class="number">5.3</span>&#125; <span class="comment">// 精确地   所以会出现error</span></span><br><span class="line"><span class="keyword">char</span> ci&#123;<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c9&#123;<span class="number">9999</span>&#125;; <span class="comment">//error  9999不合适是一个char类型</span></span><br></pre></td></tr></table></figure></p>
<p>如果是自己想实现初始化列表构造函数，拷贝函数，赋值函数，需要包含initializer_list 这个头文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> a):a_(a)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"normal initializer list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass(<span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; a):b_(a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"initializer list constructor\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass(MyClass&amp; my) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor\n"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a_ = my.a_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b_ = my.b_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; my) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"operator = constructor\n"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a_ = my.a_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b_ = my.b_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是初始化以及输出结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyClass ma&#123;<span class="number">1</span>&#125;;               <span class="comment">// (a)</span></span><br><span class="line">MyClass mb = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;      <span class="comment">// (b)</span></span><br><span class="line"><span class="function">MyClass <span class="title">mc</span><span class="params">(<span class="number">2</span>)</span></span>;               <span class="comment">// (c)</span></span><br><span class="line">MyClass md = b;              <span class="comment">// (d)</span></span><br><span class="line"><span class="function">MyClass <span class="title">me</span><span class="params">(c)</span></span>;               <span class="comment">// (e)</span></span><br><span class="line">MyClass mf&#123;e&#125;;               <span class="comment">// (f)</span></span><br><span class="line"><span class="keyword">auto</span> l&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">MyClass mh&#123;l&#125;;               <span class="comment">// (e)</span></span><br><span class="line">ma = mb;                     <span class="comment">// (h)</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initializer list <span class="function"><span class="keyword">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">initializer</span> <span class="title">list</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">normal</span> <span class="title">constructor</span> <span class="title">list</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">initializer</span> <span class="title">list</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">operator</span> = <span class="title">constructor</span></span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之统一初始化和初始化器列表/" data-id="ciqarm483004vh8qyl2cfrj7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之右值引用和move语义" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之右值引用和move语义/" class="article-date">
  <time datetime="2016-07-06T10:43:33.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之右值引用和move语义/">C++11常规特性之右值引用和move语义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++11加入了右值引用(rvalue reference)的概念（用&amp;&amp;标识），用来区分对左值和右值的引用。左值就是一个有名字的对象，而右值则是一个无名对象（临时对象）。move语义允许修改右值（以前右值被看作是不可修改的，等同于const T&amp;类型）。<br>C++的class或者struct以前都有一些隐含的成员函数：默认构造函数（仅当没有显示定义任何其他构造函数时才存在），拷贝构造函数，析构函数还有拷贝赋值操作符。拷贝构造函数和拷贝赋值操作符提供bit-wise的拷贝（浅拷贝），也就是逐个bit拷贝对象。也就是说，如果你有一个类包含指向其他对象的指针，拷贝时只会拷贝指针的值而不会管指向的对象。在某些情况下这种做法是没问题的，但在很多情况下，实际上你需要的是深拷贝，也就是说你希望拷贝指针所指向的对象。而不是拷贝指针的值。这种情况下，你需要显示地提供拷贝构造函数与拷贝赋值操作符来进行深拷贝。</p>
<p>如果你用来初始化或拷贝的源对象是个右值（临时对象）会怎么样呢？你仍然需要拷贝它的值，但随后很快右值就会被释放。这意味着产生了额外的操作开销，包括原本并不需要的空间分配以及内存拷贝。</p>
<p>现在说说move constructor和move assignment operator。这两个函数接收T&amp;&amp;类型的参数，也就是一个右值。在这种情况下，它们可以修改右值对象，例如“偷走”它们内部指针所指向的对象。举个例子，一个容器的实现（例如vector或者queue）可能包含一个指向元素数组的指针。当用一个临时对象初始化一个对象时，我们不需要分配另一个数组，从临时对象中把值复制过来，然后在临时对象析构时释放它的内存。我们只需要将指向数组内存的指针值复制过来，由此节约了一次内存分配，一次元数组的复制以及后来的内存释放。</p>
<p>以下代码实现了一个简易的buffer。这个buffer有一个成员记录buffer名称（为了便于以下的说明），一个指针（封装在unique_ptr中）指向元素为T类型的数组，还有一个记录数组长度的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// default constructor</span></span><br><span class="line">   Buffer():</span><br><span class="line">      _size(<span class="number">16</span>),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[<span class="number">16</span>])</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">size_t</span> size):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[size])</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[copy._size])</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Buffer&amp; copy)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> != ©)</span><br><span class="line">      &#123;</span><br><span class="line">         _name = copy._name;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(_size != copy._size)</span><br><span class="line">         &#123;</span><br><span class="line">            _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">            _size = copy._size;</span><br><span class="line">            _buffer = _size &gt; <span class="number">0</span> &gt; <span class="keyword">new</span> T[_size] : <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         T* source = copy._buffer.get();</span><br><span class="line">         T* dest = _buffer.get();</span><br><span class="line">         <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):</span><br><span class="line">      _name(<span class="built_in">std</span>::move(temp._name)),</span><br><span class="line">      _size(temp._size),</span><br><span class="line">      _buffer(<span class="built_in">std</span>::move(temp._buffer))</span><br><span class="line">   &#123;</span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; temp)</span><br><span class="line">   &#123;</span><br><span class="line">      assert(<span class="keyword">this</span> != &amp;temp); <span class="comment">// assert if this is not a temporary</span></span><br><span class="line"></span><br><span class="line">      _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      _size = temp._size;</span><br><span class="line">      _buffer = <span class="built_in">std</span>::move(temp._buffer);</span><br><span class="line"></span><br><span class="line">      _name = <span class="built_in">std</span>::move(temp._name);</span><br><span class="line"></span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Buffer&lt;T&gt; getBuffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">   Buffer&lt;T&gt; b(name, <span class="number">128</span>);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b1;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b2(<span class="string">"buf2"</span>, <span class="number">64</span>);</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b3 = b2;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b4 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf4"</span>);</span><br><span class="line">   b1 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf5"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的copy constructor以及copy assignment operator大家应该很熟悉了。C++11中新增的是move constructor以及move assignment operator，这两个函数根据上文所描述的move语义实现。如果你运行这段代码，你就会发现b4构造时，move constructor会被调用。同样，对b1赋值时，move assignment operator会被调用。原因就在于getBuffer()的返回值是一个临时对象——也就是右值。</p>
<p>你也许注意到了，move constuctor中当我们初始化变量name和指向buffer的指针时，我们使用了std::move。name实际上是一个string，std::string实现了move语义。std::unique_ptr也一样。但是如果我们写_name(temp._name)，那么copy constructor将会被调用。不过对于_buffer来说不能这么写，因为std::unique_ptr没有copy constructor。但为什么std::string的move constructor此时没有被调到呢？这是因为虽然我们使用一个右值调用了Buffer的move constructor，但在这个构造函数内，它实际上是个左值。为什么？因为它是有名字的——“temp”。一个有名字的对象就是左值。为了再把它变为右值（以便调用move constructor)必须使用std::move。这个函数仅仅是把一个左值引用变为一个右值引用。</p>
<p>更新：虽然这个例子是为了说明如何实现move constructor以及move assignment operator，但具体的实现方式并不是唯一的。在本文的回复中Member 7805758同学提供了另一种可能的实现。为了方便查看，我把它也列在下面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = <span class="string">""</span>, <span class="keyword">size_t</span> size = <span class="number">16</span>):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(size? <span class="keyword">new</span> T[size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(copy._size? <span class="keyword">new</span> T[copy._size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer copy)</span><br><span class="line">   &#123;</span><br><span class="line">       swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):Buffer()</span><br><span class="line">   &#123;</span><br><span class="line">      swap(*<span class="keyword">this</span>, temp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; first, Buffer&amp; second)</span> <span class="keyword">noexcept</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">       swap(first._name  , second._name);</span><br><span class="line">       swap(first._size  , second._size);</span><br><span class="line">       swap(first._buffer, second._buffer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>move语义不仅仅用于右值，也用于左值。标准库提供了std::move方法，将左值转换成右值。因此，对于swap函数，我们可以这样实现<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T temp(st<span class="number">d::</span>move(a))<span class="comment">;</span></span><br><span class="line">    a = st<span class="number">d::</span>move(b)<span class="comment">;</span></span><br><span class="line">    b = st<span class="number">d::</span>move(temp)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.jobbole.com/44015/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之右值引用和move语义/" data-id="ciqarm485004zh8qy4789dtx9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之lambda" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之lambda/" class="article-date">
  <time datetime="2016-07-06T10:42:44.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之lambda/">C++11常规特性之lambda</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多语言都提供了 lambda 表达式，如 Python，Java 8。lambda 表达式可以方便地构造匿名函数，如果你的代码里面存在大量的小函数，而这些函数一般只被调用一次，那么不妨将他们重构成 lambda 表达式。举一个例子。标准 C++ 库中有一个常用算法的库，其中提供了很多算法函数，比如 sort() 和 find()。这些函数通常需要提供一个“谓词函数 predicate function”。所谓谓词函数，就是进行一个操作用的临时函数。比如 find() 需要一个谓词，用于查找元素满足的条件；能够满足谓词函数的元素才会被查找出来。这样的谓词函数，使用临时的匿名函数，既可以减少函数数量，又会让代码变得清晰易读。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="keyword">mutable</span>:当capture为传值的时候，函数不能修改外部的局部变量，如果需要修改，可以使用该关键字，</span><br><span class="line">        但是由于是传值，即使修改，也不会影响到capture的变量；传引用的时候，是可以修改变量的</span><br><span class="line">        而且会影响到所capture的变量</span><br><span class="line"><span class="keyword">exception</span>：说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f<span class="literal">()</span> throw(<span class="type">X</span>, <span class="type">Y</span>)。</span><br><span class="line">attribute: 用来声明属性</span><br><span class="line">returnType: lambda函数的返回类型，可以不需要，lambda可以根据返回表达式自己推导</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">exception</span> attribute三个属性可以省略</span><br><span class="line"></span><br><span class="line">capture 指定了在可见域范围内 lambda 表达式的代码内可见得外部变量的列表，具体解释如下：</span><br><span class="line">[a,&amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获。</span><br><span class="line">[this] 以值的方式捕获 this 指针。</span><br><span class="line">[&amp;] 以引用的方式捕获所有的外部自动变量。</span><br><span class="line">[=] 以值的方式捕获所有的外部自动变量。</span><br><span class="line"><span class="literal">[]</span> 不捕获外部的任何变量。</span><br><span class="line">*/</span><br><span class="line">[ capture ] ( params ) <span class="keyword">mutable</span> <span class="keyword">exception</span> attribute -&gt; returnType &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [](<span class="keyword">float</span> f) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [](<span class="keyword">float</span> f) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们想引用一个 lambda 表达式时，我们可以使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [] () -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> val * <span class="number">100</span>; &#125;;</span><br><span class="line"><span class="comment">//auto关键字实际会将 lambda表达式转换成一种类似于std::function的内部类型</span></span><br><span class="line"><span class="comment">//（但并不是std::function类型，虽然与std::function“兼容”）。所以，我们也可以这么写：</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>()&gt; lambda = [] () -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> val * <span class="number">100</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传值方式，改变capture变量</span></span><br><span class="line"><span class="keyword">float</span> f0 = <span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [=](<span class="keyword">float</span> f) <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> f0 += <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>); <span class="comment">//f0仍然是1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。</span></span><br><span class="line"><span class="comment">//但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</span></span><br><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;someFunc(); &#125;();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之lambda/" data-id="ciqarm48c0058h8qy7757boug" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之noexcept" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之noexcept/" class="article-date">
  <time datetime="2016-07-06T10:42:33.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之noexcept/">C++11常规特性之noexcept</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在异常处理的代码中，程序员有可能看到过如下的异常声明表达形式：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> excpt_func() <span class="keyword">throw</span>(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>在excpt_func函数声明之后，我们定义了一个动态异常声明throw(int, double)，该声明指出了excpt_func可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了（参见附录B），而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。</p>
<p>noexcept形如其名地，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行，这比基于异常机制的throw()在效率上会高一些。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。</p>
<p>从语法上讲，noexcept修饰符有两种形式，一种就是简单地在函数声明后加上noexcept关键字。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>另外一种则可以接受一个常量表达式作为参数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的结果会被转换成一个bool类型的值。该值为true，表示函数不会抛出异常，反之，则有可能抛出异常。这里，不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。</p>
<p>在通常情况下，在C++11中使用noexcept可以有效地阻止异常的传播与扩散。我们可以看看下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Throw</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NoBlockThrow</span><span class="params">()</span> </span>&#123; Throw(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; Throw(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Throw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw."</span> &lt;&lt; endl;     <span class="comment">// Found throw.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NoBlockThrow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Throw is not blocked."</span> &lt;&lt; endl;    <span class="comment">// Throw is not blocked.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BlockThrow();   <span class="comment">// terminate called after throwing an instance of 'int'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw 1."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项:g++ -std=c++11 2-6-1.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码清单2-12中，我们定义了Throw函数，该函数的唯一作用是抛出一个异常。而NoBlockThrow是一个调用Throw的普通函数，BlockThrow则是一个noexcept修饰的函数。从main的运行中我们可以看到，NoBlockThrow会让Throw函数抛出的异常继续抛出，直到main中的catch语句将其捕捉。而BlockThrow则会直接调用std::terminate中断程序的执行，从而阻止了异常的继续传播。从使用效果上看，这与C++98中的throw()是一样的。<br>而noexcept作为一个操作符时，通常可以用于模板。比如：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  void <span class="function"><span class="keyword">fun</span>() <span class="title">noexcept</span></span>(noexcept(<span class="constant">T</span>())) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为false，反之为true（实际noexcept参数返回false还包括一些情况，这里就不展开讲了）。这样一来，我们就可以使模板函数根据条件实现noexcept修饰的版本或无noexcept修饰的版本。从泛型编程的角度看来，这样的设计保证了关于“函数是否抛出异常”这样的问题可以通过表达式进行推导。因此这也可以视作C++11为了更好地支持泛型编程而引入的特性。</p>
<p>虽然noexcept修饰的函数通过std::terminate的调用来结束程序的执行的方式可能会带来很多问题，比如无法保证对象的析构函数的正常调用，无法保证栈的自动释放等，但很多时候，“暴力”地终止整个程序确实是很简单有效的做法。事实上，noexcept被广泛地、系统地应用在C++11的标准库中，用于提高标准库的性能，以及满足一些阻止异常扩散的需求。</p>
<p>比如在C++98中，存在着使用throw()来声明不抛出异常的函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用noexcept来替换throw()。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="keyword">noexcept</span>  </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>又比如，在C++98中，new可能会包含一些抛出的std::bad_alloc异常。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc);</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用noexcept(false)来进行替代。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">noexcept</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然，noexcept更大的作用是保证应用程序的安全。比如一个类析构函数不应该抛出异常，那么对于常被析构函数调用的delete函数来说，C++11默认将delete函数设置成noexcept，就可以提高应用程序的安全性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>而同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的。当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持默认值。我们可以看看下面的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A &#123;</span><br><span class="line">    ~A() &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B &#123;</span><br><span class="line">    ~B() <span class="keyword">noexcept</span>(<span class="literal">false</span>) &#123; <span class="keyword">throw</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> C &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funA</span><span class="params">()</span> </span>&#123; A a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funB</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funC</span><span class="params">()</span> </span>&#123; C c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funB."</span> &lt;&lt; endl; <span class="comment">// caught funB.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funC."</span> &lt;&lt; endl; <span class="comment">// caught funC.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funA(); <span class="comment">// terminate called after throwing an instance of 'int'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funA."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项:g++ -std=c++11 2-6-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。这在实际的使用中，应该引起程序员的注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之noexcept/" data-id="ciqarm48a0055h8qysdfng0n7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-11常规特性之其他一些新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之其他一些新特性/" class="article-date">
  <time datetime="2016-07-06T04:01:15.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之其他一些新特性/">C++11常规特性之其他一些新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++11有很多的新特性，这里只记录一下一些比较会常用到的新特性，有：auto和decltype、nullptr、noexcept、lambda、基于范围的for语句、初始化器列表、右值引用和move语义、constexpr、override和final、强类型枚举（Strong-type enums）、智能指针（Smart Pointers）、非成员begin()和end()以及static_assert和type traits</p>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>以前都是用0来表示空指针的，但由于0可以被隐式类型转换为整形，这就会存在一些问题。关键字nullptr是std::nullptr_t类型的值，用来指代空指针。nullptr和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。但是为了向前兼容，0仍然是个合法的空指针值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="literal">nullptr</span>;   </span><br><span class="line"><span class="keyword">if</span>(p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">nullptr</span>);</span><br><span class="line">bar(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="literal">nullptr</span>; <span class="comment">// error: A native nullptr can only be converted to bool or, using reinterpret_cast, to an integral type</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Range-based-for-loops-（基于范围的for循环）"><a href="#Range-based-for-loops-（基于范围的for循环）" class="headerlink" title="Range-based for loops （基于范围的for循环）"></a>Range-based for loops （基于范围的for循环）</h3><p>为了在遍历容器时支持”foreach”用法，C++11扩展了for语句的语法。用这个新的写法，可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> x : &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span> &#125;) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v) ++x;  <span class="comment">// using a reference to allow us to change the value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr) &#123;e=e*e;&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="constexpr和const"><a href="#constexpr和const" class="headerlink" title="constexpr和const"></a>constexpr和const</h3><p>const并未区分出编译期常量和运行期常量<br>constexpr限定在了编译期常量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">// 如果size()是常量表达式则编译通过，否则报错</span></span><br></pre></td></tr></table></figure></p>
<p>constexpr修饰的函数，返回值不一定是编译期常量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(5)&gt; arr; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    foo(i); <span class="comment">// Call is Ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// But...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(i)&gt; arr1; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了。不过，我们不必因此而写两个版本，所以如果函数体适用于constexpr函数的条件，可以尽量加上constexpr。</p>
<p>而检测constexpr函数是否产生编译时期值的方法很简单，就是利用std::array需要编译期常值才能编译通过的小技巧。这样的话，即可检测你所写的函数是否真的产生编译期常值了。</p>
<p>以上内容来自<a href="https://www.zhihu.com/question/35614219/answer/63798713" target="_blank" rel="external">知乎</a></p>
<p>通常，我们希望编译时期计算可以保护全局或者名字空间内的对象，对名字空间内的对象，我们希望它保存在只读空间内。<br>对于那些构造函数比较简单，可以成为常量表达式（也就是可以使用constexpr进行修饰）的对象可以做到这一点<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">      <span class="keyword">int</span> x,y;</span><br><span class="line">      constexpr Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy) : x(xx), y(yy) &#123; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  constexpr <span class="function">Point <span class="title">origo</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  constexpr <span class="keyword">int</span> z = origo.x;</span><br><span class="line">  constexpr Point a[] = &#123;Point(<span class="number">0</span>,<span class="number">0</span>), Point(<span class="number">1</span>,<span class="number">1</span>), Point(<span class="number">2</span>,<span class="number">2</span>) &#125;;</span><br><span class="line">  constexpr <span class="keyword">int</span> x = a[<span class="number">1</span>].x;   <span class="comment">// x becomes 1</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>const的主要功能是修饰一个对象而不是通过一个接口（即使对象很容易通过其他接口修改）。只不过声明一个对象常量为编译器提供了优化的机会。特别是，如果一个声明了一个对象常量而他的地址没有取到，编译器通常可以在编译时对他进行初始化（尽管这不是肯定的）保证这个对象在他的列表里而不是把它添加到生成代码里。</li>
<li>constexpr的主要功能可以在编译时计算表达式的值进行了范围扩展，这是一种计算安全而且可以用在编译时期（如初始化枚举或者整体模板参数）。constexpr声明对象可以在初始化编译的时候计算出结果来。他们基本上只保存在编译器的列表，如果需要的话会释放到生成的代码里。</li>
</ol>
<p>以上内容来自<a href="http://blog.jobbole.com/55063/" target="_blank" rel="external">知乎</a></p>
<h3 id="override和final"><a href="#override和final" class="headerlink" title="override和final"></a>override和final</h3><p>我总觉得C++中虚函数的设计很差劲，因为时至今日仍然没有一个强制的机制来标识虚函数会在派生类里被改写。vitual关键字是可选的，这使得阅读代码变得很费劲。因为可能需要追溯到继承体系的源头才能确定某个方法是否是虚函数。为了增加可读性，我总是在派生类里也写上virtual关键字，并且也鼓励大家都这么做。即使这样，仍然会产生一些微妙的错误。看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>D::f 按理应当重写 B::f。然而二者的声明是不同的，一个参数是short，另一个是int。因此D::f（原文为B::f，可能是作者笔误——译者注）只是拥有同样名字的另一个函数（重载）而不是重写。当你通过B类型的指针调用f()可能会期望打印出D::f，但实际上则会打出 B::f 。</p>
<p>另一个很微妙的错误情况：参数相同，但是基类的函数是const的，派生类的函数却不是。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f "</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样，这两个函数是重载而不是重写，所以你通过B类型指针调用f()将打印B::f，而不是D::f。</p>
<p>幸运的是，现在有一种方式能描述你的意图。新标准加入了两个新的标识符（不是关键字）:：</p>
<ol>
<li>override，表示函数应当重写基类中的虚函数。</li>
<li>final，表示派生类不应当重写这个虚函数。<br>第一个的例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在这将触发一个编译错误（后面那个例子，如果也写上override标识，会得到相同的错误提示）：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'D::f' : <span class="keyword">method</span> <span class="keyword">with</span> override specifier 'override' did <span class="keyword">not</span> override <span class="type">any</span> base class methods</span><br></pre></td></tr></table></figure></p>
<p>另一方面，如果你希望函数不要再被派生类进一步重写，你可以把它标识为final。可以在基类或任何派生类中使用final。在派生类中，可以同时使用override和final标识。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override final </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> F : <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"F::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>被标记成final的函数将不能再被F::f重写。</p>
<h3 id="Strongly-typed-enums-强类型枚举"><a href="#Strongly-typed-enums-强类型枚举" class="headerlink" title="Strongly-typed enums 强类型枚举"></a>Strongly-typed enums 强类型枚举</h3><p>传统的C++枚举类型存在一些缺陷：它们会将枚举常量暴露在外层作用域中（这可能导致名字冲突，如果同一个作用域中存在两个不同的枚举类型，但是具有相同的枚举常量就会冲突），而且它们会被隐式转换为整形，无法拥有特定的用户定义类型。</p>
<p>在C++11中通过引入了一个称为强类型枚举的新类型，修正了这种情况。强类型枚举由关键字enum class标识。它不会将枚举常量暴露到外层作用域中，也不会隐式转换为整形，并且拥有用户指定的特定类型（传统枚举也增加了这个性质）。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Options</span> &#123;<span class="title">None</span>, <span class="title">One</span>, <span class="title">All</span>&#125;;</span></span><br><span class="line"><span class="constant">Options</span> o = <span class="constant">Options::All</span>;</span><br></pre></td></tr></table></figure></p>
<p>在标准C++中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。C++03 唯一提供的安全机制是一个整数或一个枚举型值不能隐式转换到另一个枚举别型。 此外，枚举所使用整数类型及其大小都由实现方法定义，皆无法明确指定。 最后，枚举的名称全数暴露于一般范围中，因此C++03两个不同的枚举，不可以有相同的枚举名。 (好比 enum Side{ Right, Left }; 和 enum Thing{ Wrong, Right }; 不能一起使用。)<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Enumeration</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="constant">Val1</span>,</span><br><span class="line">  <span class="constant">Val2</span>,</span><br><span class="line">  <span class="constant">Val3</span> = <span class="number">100</span>,</span><br><span class="line">  <span class="constant">Val4</span> /* = <span class="number">101</span> *<span class="regexp">/,</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>此种枚举为类型安全的。枚举类型不能隐式地转换为整数；也无法与整数数值做比较。 (表示式 Enumeration::Val4 == 101 会触发编译期错误)。</p>
<p>枚举类型所使用类型必须显式指定。在上面的示例中，使用的是默认类型 int，但也可以指定其他类型：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Enum2</span> : <span class="title">unsigned</span> <span class="title">int</span> &#123;<span class="title">Val1</span>, <span class="title">Val2</span>&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>枚举类型的语汇范围(scoping)定义于枚举类型的名称范围中。 使用枚举类型的枚举名时，必须明确指定其所属范围。 由前述枚举类型 Enum2 为例，Enum2::Val1是有意义的表示法， 而单独的 Val1 则否。</p>
<p>此外，C++11 允许为传统的枚举指定使用类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum3 : <span class="keyword">unsigned</span> <span class="keyword">long</span> &#123;Val1 = <span class="number">1</span>, Val2&#125;;</span><br></pre></td></tr></table></figure></p>
<p>枚举名 Val1 定义于 Enum3 的枚举范围中(Enum3::Val1)，但为了兼容性， Val1 仍然可以于一般的范围中单独使用。</p>
<p>在 C++11 中，枚举类型的前置声明 (forward declaration) 也是可行的，只要使用可指定类型的新式枚举即可。 之前的 C++ 无法写出枚举的前置声明，是由于无法确定枚举参数所占的空间大小， C++11 解决了这个问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum1;                     <span class="comment">// 不合法的 C++ 與 C++11; 無法判別大小</span></span><br><span class="line"><span class="keyword">enum</span> Enum2 : <span class="keyword">unsigned</span> <span class="keyword">int</span>;      <span class="comment">// 合法的 C++11</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Enum3;               <span class="comment">// 合法的 C++11，列舉類別使用預設型別 int</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Enum4: <span class="keyword">unsigned</span> <span class="keyword">int</span>; <span class="comment">// 合法的 C++11</span></span><br><span class="line"><span class="keyword">enum</span> Enum2 : <span class="keyword">unsigned</span> <span class="keyword">short</span>;    <span class="comment">// 不合法的 C++11，Enum2 已被聲明為 unsigned int</span></span><br></pre></td></tr></table></figure></p>
<h3 id="static-assert和-type-traits"><a href="#static-assert和-type-traits" class="headerlink" title="static_assert和 type traits"></a>static_assert和 type traits</h3><p>static_assert提供一个编译时的断言检查。如果断言为真，什么也不会发生。如果断言为假，编译器会打印一个特殊的错误信息。是在编译的时候进行断言，所以在实时编译的环境下编辑代码的时候，如果断言为假的话，就会直接提示错误<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sj = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static_assert</span>(sj&lt;<span class="number">9</span>, <span class="string">"Size is too small"</span>); <span class="comment">//OK and assert is true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// error 因为是在编译期的断言，所以在编译期必须能够对断言的内容进行确定，由于a是运行时动态确定的，所以这里编译错误</span></span><br><span class="line"><span class="keyword">static_assert</span>(a&lt;<span class="number">9</span>, <span class="string">"Size is too small"</span>);</span><br></pre></td></tr></table></figure></p>
<p>static_assert和type traits一起使用能发挥更大的威力。type traits是一些class，在编译时提供关于类型的信息。在头文件<type_traits>中可以找到它们。这个头文件中有好几种class: helper class，用来产生编译时常量。type traits class，用来在编译时获取类型信息，还有就是type transformation class，他们可以将已存在的类型变换为新的类型。</type_traits></p>
<p>下面这段代码原本期望只做用于整数类型。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">auto add<span class="function"><span class="params">(T1 t1, T2 t2)</span> -&gt;</span> decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果有人写出如下代码，编译器并不会报错<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"one"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>程序会打印出4.14和”e”。但是如果我们加上编译时断言，那么以上两行将产生编译错误。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="constant">T1,</span> typename <span class="constant">T2&gt;</span></span><br><span class="line">auto add(<span class="constant">T1 </span>t1, <span class="constant">T2 </span>t2) -&gt; decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line">   static_assert(<span class="symbol">std:</span><span class="symbol">:is_integral&lt;T1&gt;</span><span class="symbol">:</span><span class="symbol">:value</span>, <span class="string">"Type T1 must be integral"</span>);</span><br><span class="line">   static_assert(<span class="symbol">std:</span><span class="symbol">:is_integral&lt;T2&gt;</span><span class="symbol">:</span><span class="symbol">:value</span>, <span class="string">"Type T2 must be integral"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error</span> C2338: Type T2 must be integral</span><br><span class="line">see reference <span class="keyword">to</span> <span class="keyword">function</span> template instantiation <span class="comment">'T2 add<span class="xmlDocTag">&lt;int,double&gt;</span>(T1,T2)' being compiled</span></span><br><span class="line">   <span class="keyword">with</span></span><br><span class="line">   [</span><br><span class="line">      T2=<span class="built_in">double</span>,</span><br><span class="line">      T1=int</span><br><span class="line">   ]</span><br><span class="line"><span class="keyword">error</span> C2338: Type T1 must be integral</span><br><span class="line">see reference <span class="keyword">to</span> <span class="keyword">function</span> template instantiation <span class="comment">'T1 add<span class="xmlDocTag">&lt;const char*,int&gt;</span>(T1,T2)' being compiled</span></span><br><span class="line">   <span class="keyword">with</span></span><br><span class="line">   [</span><br><span class="line">      T1=<span class="keyword">const</span> <span class="built_in">char</span> *,</span><br><span class="line">      T2=int</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之其他一些新特性/" data-id="ciqarm4880052h8qymuqirwb8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-套接字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/套接字/" class="article-date">
  <time datetime="2016-07-02T06:37:39.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/套接字/">套接字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息队列、信号灯、共享内存等，都是基于Sys V的IPC机制进行讨论的，它们的应用局限在单一计算机内的进程间通信；基于BSD套接口不仅可以实现单机内的进程间通信，还可以实现不同计算机进程之间的通信。</p>
<p>一个套接口可以看作是进程间通信的端点（endpoint），每个套接口的名字都是唯一的（唯一的含义是不言而喻的），其他进程可以发现、连接并且与之通信。通信域用来说明套接口通信的协议，不同的通信域有不同的通信协议以及套接口的地址结构等等，因此，创建一个套接口时，要指明它的通信域。比较常见的是unix域套接口（采用套接口机制实现单机内的进程间通信）及网际通信域。</p>
<h3 id="1、背景知识"><a href="#1、背景知识" class="headerlink" title="1、背景知识"></a>1、背景知识</h3><p>linux目前的网络内核代码主要基于伯克利的BSD的unix实现，整个结构采用的是一种面向对象的分层机制。层与层之间有严格的接口定义。这里我们引用[1]中的一个图表来描述linux支持的一些通信协议：<br><img src="/pictures/Linux/进程间通信/共享内存-套接字通信协议.png" alt=""></p>
<p>我们这里只关心IPS，即因特网协议族，也就是通常所说的TCP/IP网络。我们这里假设读者具有网络方面的一些背景知识，如了解网络的分层结构，通常所说的7层结构；了解IP地址以及路由的一些基本知识。</p>
<p>目前linux网络API是基于BSD套接口的（系统V提供基于流I/O子系统的用户接口，但是linux内核目前不支持流I/O子系统）。套接口可以说是网络编程中一个非常重要的概念，linux以文件的形式实现套接口，与套接口相应的文件属于sockfs特殊文件系统，创建一个套接口就是在sockfs中创建一个特殊文件，并建立起为实现套接口功能的相关数据结构。换句话说，对每一个新创建的BSD套接口，linux内核都将在sockfs特殊文件系统中创建一个新的inode。描述套接口的数据结构是socket，将在后面给出。</p>
<h3 id="2、重要数据结构"><a href="#2、重要数据结构" class="headerlink" title="2、重要数据结构"></a>2、重要数据结构</h3><p>下面是在网络编程中比较重要的几个数据结构，读者可以在后面介绍编程API部分再回过头来了解它们。</p>
<h4 id="（1）表示套接口的数据结构struct-socket"><a href="#（1）表示套接口的数据结构struct-socket" class="headerlink" title="（1）表示套接口的数据结构struct socket"></a>（1）表示套接口的数据结构struct socket</h4><p>套接口是由socket数据结构代表的，形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket</span><br><span class="line">&#123;</span><br><span class="line">socket_state  state;     <span class="comment">/* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种</span><br><span class="line">套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>    flags;</span><br><span class="line">  <span class="keyword">struct</span> proto_ops  ops;  <span class="comment">/* 指明可对套接口进行的各种操作 */</span></span><br><span class="line">  <span class="keyword">struct</span> inode    inode;    <span class="comment">/* 指向sockfs文件系统中的相应inode */</span></span><br><span class="line">  <span class="keyword">struct</span> fasync_struct  *fasync_list;  <span class="comment">/* Asynchronous wake up list  */</span></span><br><span class="line">  <span class="keyword">struct</span> file    *file;          <span class="comment">/* 指向sockfs文件系统中的相应文件  */</span></span><br><span class="line"><span class="keyword">struct</span> sock    sk;  <span class="comment">/* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对</span><br><span class="line">象。 */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>  wait;</span><br><span class="line">  <span class="keyword">short</span>      type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>    passcred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（2）描述套接口通用地址的数据结构struct-sockaddr"><a href="#（2）描述套接口通用地址的数据结构struct-sockaddr" class="headerlink" title="（2）描述套接口通用地址的数据结构struct sockaddr"></a>（2）描述套接口通用地址的数据结构struct sockaddr</h4><p>由于历史的缘故，在bind、connect等系统调用中，特定于协议的套接口地址结构指针都要强制转换成该通用的套接口地址结构指针。结构形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr &#123;</span><br><span class="line">	<span class="keyword">sa_family_t</span>	sa_family;	<span class="comment">/* address family, AF_xxx	*/</span></span><br><span class="line">	<span class="keyword">char</span>		sa_data[<span class="number">14</span>];	<span class="comment">/* 14 bytes of protocol address	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）："><a href="#（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）：" class="headerlink" title="（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）："></a>（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in</span><br><span class="line">  &#123;</span><br><span class="line">    __SOCKADDR_COMMON (sin_);	<span class="comment">/* 描述协议族 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;			<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="keyword">struct</span> in_addr sin_addr;		<span class="comment">/* 因特网地址 */</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">			   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，读者最关心的是前三个域，即通信协议、端口号及地址。</p>
<h3 id="3、套接口编程的几个重要步骤："><a href="#3、套接口编程的几个重要步骤：" class="headerlink" title="3、套接口编程的几个重要步骤："></a>3、套接口编程的几个重要步骤：</h3><h4 id="（1）创建套接口，由系统调用socket实现："><a href="#（1）创建套接口，由系统调用socket实现：" class="headerlink" title="（1）创建套接口，由系统调用socket实现："></a>（1）创建套接口，由系统调用socket实现：</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> ptotocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数domain指明通信域，如PF_UNIX（unix域），PF_INET（IPv4），PF_INET6(IPv6)等；type指明通信类型，如SOCK_STREAM(面向连接方式)、SOCK_DGRAM(非面向连接方式)等。一般来说，参数protocol可设置为0，除非用在原始套接口上（原始套接口有一些特殊功能，后面还将介绍）。</p>
<p>注：socket（）系统调用为套接口在sockfs文件系统中分配一个新的文件和dentry对象，并通过文件描述符把它们与调用进程联系起来。进程可以像访问一个已经打开的文件一样访问套接口在sockfs中的对应文件。但进程绝不能调用open()来访问该文件（sockfs文件系统没有可视安装点，其中的文件永远不会出现在系统目录树上），当套接口被关闭时，内核会自动删除sockfs中的inodes。</p>
<h4 id="（2）绑定地址"><a href="#（2）绑定地址" class="headerlink" title="（2）绑定地址"></a>（2）绑定地址</h4><p>根据传输层协议（TCP、UDP）的不同，客户机及服务器的处理方式也有很大不同。但是，不管通信双方使用何种传输协议，都需要一种标识自己的机制。</p>
<p>通信双方一般由两个方面标识：地址和端口号（通常，一个IP地址和一个端口号常常被称为一个套接口）。根据地址可以寻址到主机，根据端口号则可以寻址到主机提供特定服务的进程，实际上，一个特定的端口号代表了一个提供特定服务的进程。</p>
<p>对于使用TCP传输协议通信方式来说，通信双方需要给自己绑定一个唯一标识自己的套接口，以便建立连接；对于使用UDP传输协议，只需要服务器绑定一个标识自己的套接口就可以了，用户则不需要绑定(在需要时，如调用connect时[注1]，内核会自动分配一个本地地址和本地端口号)。绑定操作由系统调用bind()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * my_addr, socklen_t my_addr_len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第二个参数对于Ipv4来说，实际上需要填充的结构是struct sockaddr_in，前面已经介绍了该结构。这里只想强调该结构的第一个域，它表明该套接口使用的通信协议，如AF_INET。联系socket系统调用的第一个参数，读者可能会想到PF_INET与AF_INET究竟有什么不同？实际上，原来的想法是每个通信域（如PF_INET）可能对应多个协议（如AF<em>INET），而事实上支持多个协议的通信域一直没有实现。因此，在linux内核中，AF</em><strong><em>与PF_</em></strong>被定义为同一个常数，因此，在编程时可以不加区分地使用他们。</p>
<p>注1：在采用非面向连接通信方式时，也会用到connect()调用，不过与在面向连接中的connect（）调用有本质的区别：在非面向连接通信中，connect调用只是先设置一下对方的地址，内核为本地套接口记下对方的地址，然后采用send()来发送数据，这样避免每次发送时都要提供相同的目的地址。其中的connect()调用不涉及握手过程；而在面向连接的通信方式中，connect()要完成一个严格的握手过程。</p>
<h4 id="（3）请求建立连接（由TCP客户发起）"><a href="#（3）请求建立连接（由TCP客户发起）" class="headerlink" title="（3）请求建立连接（由TCP客户发起）"></a>（3）请求建立连接（由TCP客户发起）</h4><p>对于采用面向连接的传输协议TCP实现通信来说，一个比较重要的步骤就是通信双方建立连接（如果采用udp传输协议则不需要），由系统调用connect()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * servaddr, socklen_t addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数为本地调用socket后返回的描述符，第二个参数为服务器的地址结构指针。connect（）向指定的套接口请求建立连接。</p>
<p>注：与connect（）相对应，在服务器端，通过系统调用listen()，指定服务器端的套接口为监听套接口，监听每一个向服务器套接口发出的连接请求，并通过握手机制建立连接。内核为listen()维护两个队列：已完成连接队列和未完成连接队列。</p>
<h4 id="（4）接受连接请求（由TCP服务器端发起）"><a href="#（4）接受连接请求（由TCP服务器端发起）" class="headerlink" title="（4）接受连接请求（由TCP服务器端发起）"></a>（4）接受连接请求（由TCP服务器端发起）</h4><p>服务器端通过监听套接口，为所有连接请求建立了两个队列：已完成连接队列和未完成连接队列（每个监听套接口都对应这样两个队列，当然，一般服务器只有一个监听套接口）。通过accept()调用，服务器将在监听套接口的已连接队列头中，返回用于代表当前连接的套接口描述字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr * cliaddr, socklen_t * addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数指明哪个监听套接口，一般是由listen（）系统调用指定的（由于每个监听套接口都对应已连接和未连接两个队列，因此它的内部机制实质是通过sockfd指定在哪个已连接队列头中返回一个用于当前客户的连接，如果相应的已连接队列为空，accept进入睡眠）。第二个参数指明客户的地址结构，如果对客户的身份不感兴趣，可指定其为空。</p>
<p>注：对于采用TCP传输协议进行通信的服务器和客户机来说，一定要经过客户请求建立连接，服务器接受连接请求这一过程；而对采用UDP传输协议的通信双方则不需要这一步骤。</p>
<h4 id="（5）通信"><a href="#（5）通信" class="headerlink" title="（5）通信"></a>（5）通信</h4><p>客户机可以通过套接口接收服务器传过来的数据，也可以通过套接口向服务器发送数据。前面所有的准备工作（创建套接口、绑定等操作）都是为这一步骤准备的。</p>
<p>常用的从套接口中接收数据的调用有：recv、recvfrom、recvmsg等，常用的向套接口中发送数据的调用有send、sendto、sendmsg等。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">void</span> *</span><br><span class="line">        buf, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvfrom</span>(<span class="params"><span class="keyword">int</span> s,  <span class="keyword">void</span> *</span><br><span class="line">        buf,  size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags, <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        <span class="keyword">from</span>, socklen_t *</span><br><span class="line">        fromlen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">send</span>(<span class="params"><span class="keyword">int</span> s,<span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendto</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        to, socklen_t</span><br><span class="line">        tolen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>这里不再对这些调用作具体的说明，只想强调一下，recvfrom（）以及recvmsg（）可用于面向连接的套接口，也可用于面向非连接的套接口；而recv（）一般用于面向连接的套接口。另外，在调用了connect()之后，就应给调用send()而不是sendto()了，因为调用了connect之后，目标就已经确定了。</p>
<p>前面讲到，socket（）系统调用返回套接口描述字，实际上它是一个文件描述符。所以，可以对套接口进行通常的读写操作，即使用read()及write()方法。在实际应用中，由于面向连接的通信（采用TCP传输协议）是可靠的，同时又保证字节流原有的顺序，所以更适合用read及write方法。而非面向连接的通信（采用UDP传输协议）是不可靠的，字节流也不一定保持原有的顺序，所以一般不宜用read及write方法。</p>
<h4 id="（6）通信的最后一步是关闭套接口"><a href="#（6）通信的最后一步是关闭套接口" class="headerlink" title="（6）通信的最后一步是关闭套接口"></a>（6）通信的最后一步是关闭套接口</h4><p>由close()来完成此项功能，它唯一的参数是套接口描述字，不再赘述。</p>
<h3 id="4、典型调用代码："><a href="#4、典型调用代码：" class="headerlink" title="4、典型调用代码："></a>4、典型调用代码：</h3><p>到处可以发现基于套接口的客户机及服务器程序，这里不再给出完整的范例代码，只是给出它们的典型调用代码，并给出简要说明。</p>
<h4 id="（1）典型的TCP服务器代码："><a href="#（1）典型的TCP服务器代码：" class="headerlink" title="（1）典型的TCP服务器代码："></a>（1）典型的TCP服务器代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="keyword">int</span> listen_fd, connect_fd;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in serv_addr, client_addr;</span><br><span class="line">... ...</span><br><span class="line">listen_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建网际Ipv4域的（由PF_INET指定）面向连接的（由SOCK_STREAM指定，</span><br><span class="line">如果创建非面向连接的套接口则指定为SOCK_DGRAM）</span><br><span class="line">的套接口。第三个参数0表示由内核确定缺省的传输协议，</span><br><span class="line">对于本例，由于创建的是可靠的面向连接的基于流的套接口，</span><br><span class="line">内核将选择TCP作为本套接口的传输协议） */</span></span><br><span class="line"></span><br><span class="line">bzero( &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr) );</span><br><span class="line">serv_addr.sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr.sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, &amp;serv_addr.sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">bind( listen_fd, (<span class="keyword">struct</span> sockaddr*) serv_addr, <span class="keyword">sizeof</span> ( <span class="keyword">struct</span> sockaddr_in )) ;</span><br><span class="line"><span class="comment">/* 实现绑定操作 */</span></span><br><span class="line">listen( listen_fd, max_num) ;</span><br><span class="line"><span class="comment">/* 套接口进入侦听状态，max_num规定了内核为此套接口排队的最大连接个数 */</span></span><br><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">... ...</span><br><span class="line">connect_fd = accept( listen_fd, (<span class="keyword">struct</span> sockaddr*)client_addr, &amp;len ) ; <span class="comment">/* 获得连接fd. */</span></span><br><span class="line">... ...					<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：端口号的分配是有一些惯例的，不同的端口号对应不同的服务或进程。比如一般都把端口号21分配给FTP服务器的TCP/IP实现。端口号一般分为3段，0-1023（受限的众所周知的端口，由分配数值的权威机构IANA管理），1024-49151（可以从IANA那里申请注册的端口），49152-65535（临时端口，这就是为什么代码中的端口号为49152）。</p>
<p>对于多字节整数在内存中有两种存储方式：一种是低字节在前，高字节在后，这样的存储顺序被称为低端字节序（little-endian）；高字节在前，低字节在后的存储顺序则被称为高端字节序（big-endian）。网络协议在处理多字节整数时，采用的是高端字节序，而不同的主机可能采用不同的字节序。因此在编程时一定要考虑主机字节序与网络字节序间的相互转换。这就是程序中使用htons函数的原因，它返回网络字节序的整数。</p>
<h4 id="（2）典型的TCP客户代码："><a href="#（2）典型的TCP客户代码：" class="headerlink" title="（2）典型的TCP客户代码："></a>（2）典型的TCP客户代码：</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">int socket_fd;</span><br><span class="line">struct sockaddr_in serv_addr ;</span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">socket_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">bzero( <span class="subst">&amp;</span>serv_addr, sizeof(serv_addr) );</span><br><span class="line">serv_addr<span class="built_in">.</span>sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr<span class="built_in">.</span>sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, <span class="subst">&amp;</span>serv_addr<span class="built_in">.</span>sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">connect( socket_fd, (struct sockaddr*)serv_addr, sizeof( serv_addr ) ) ; <span class="comment">/* 向服务器发起连接请求 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span>							<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<p>对比两段代码可以看出，许多调用是服务器或客户机所特有的。另外，对于非面向连接的传输协议，代码还有简单些，没有连接的发起请求和接收请求部分。</p>
<h3 id="5、网络编程中的其他重要概念"><a href="#5、网络编程中的其他重要概念" class="headerlink" title="5、网络编程中的其他重要概念"></a>5、网络编程中的其他重要概念</h3><p>下面列出了网络编程中的其他重要概念，基本上都是给出这些概念能够实现的功能，读者在编程过程中如果需要这些功能，可查阅相关概念。</p>
<h4 id="（1）、I-O复用的概念"><a href="#（1）、I-O复用的概念" class="headerlink" title="（1）、I/O复用的概念"></a>（1）、I/O复用的概念</h4><p>I/O复用提供一种能力，这种能力使得当一个I/O条件满足时，进程能够及时得到这个信息。I/O复用一般应用在进程需要处理多个描述字的场合。它的一个优势在于，进程不是阻塞在真正的I/O调用上，而是阻塞在select()调用上，select()可以同时处理多个描述字，如果它所处理的所有描述字的I/O都没有处于准备好的状态，那么将阻塞；如果有一个或多个描述字I/O处于准备好状态，则select()不阻塞，同时会根据准备好的特定描述字采取相应的I/O操作。</p>
<h4 id="（2）、Unix通信域"><a href="#（2）、Unix通信域" class="headerlink" title="（2）、Unix通信域"></a>（2）、Unix通信域</h4><p>前面主要介绍的是PF_INET通信域，实现网际间的进程间通信。基于Unix通信域（调用socket时指定通信域为PF_LOCAL即可）的套接口可以实现单机之间的进程间通信。采用Unix通信域套接口有几个好处：Unix通信域套接口通常是TCP套接口速度的两倍；另一个好处是，通过Unix通信域套接口可以实现在进程间传递描述字。所有可用描述字描述的对象，如文件、管道、有名管道及套接口等，在我们以某种方式得到该对象的描述字后，都可以通过基于Unix域的套接口来实现对描述字的传递。接收进程收到的描述字值不一定与发送进程传递的值一致（描述字是特定于进程的），但是特们指向内核文件表中相同的项。</p>
<h4 id="（3）、原始套接口"><a href="#（3）、原始套接口" class="headerlink" title="（3）、原始套接口"></a>（3）、原始套接口</h4><p>原始套接口提供一般套接口所不提供的功能：<br>原始套接口可以读写一些用于控制的控制协议分组，如ICMPv4等，进而可实现一些特殊功能。<br>原始套接口可以读写特殊的IPv4数据包。内核一般只处理几个特定协议字段的数据包，那么一些需要不同协议字段的数据包就需要通过原始套接口对其进行读写；<br>通过原始套接口可以构造自己的Ipv4头部，也是比较有意思的一点。</p>
<p>创建原始套接口需要root权限。</p>
<h4 id="（4）、对数据链路层的访问"><a href="#（4）、对数据链路层的访问" class="headerlink" title="（4）、对数据链路层的访问"></a>（4）、对数据链路层的访问</h4><p>对数据链路层的访问，使得用户可以侦听本地电缆上的所有分组，而不需要使用任何特殊的硬件设备，在linux下读取数据链路层分组需要创建SOCK_PACKET类型的套接口，并需要有root权限。</p>
<h4 id="（5）、带外数据（out-of-band-data）"><a href="#（5）、带外数据（out-of-band-data）" class="headerlink" title="（5）、带外数据（out-of-band data）"></a>（5）、带外数据（out-of-band data）</h4><p>如果有一些重要信息要立刻通过套接口发送（不经过排队），请查阅与带外数据相关的文献。</p>
<h4 id="（6）、多播"><a href="#（6）、多播" class="headerlink" title="（6）、多播"></a>（6）、多播</h4><p>linux内核支持多播，但是在默认状态下，多数linux系统都关闭了对多播的支持。因此，为了实现多播，可能需要重新配置并编译内核。具体请参考[4]及[2]。</p>
<p>结论：linux套接口编程的内容可以说是极大丰富，同时它涉及到许多的网络背景知识，有兴趣的读者可在[2]中找到比较系统而全面的介绍。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>Understanding the Linux Kernel, 2nd Edition, By Daniel P. Bovet, Marco Cesati , 对各主题阐述得重点突出，脉络清晰。网络部分分析集中在TCP/IP协议栈的数据连路层、网络层以及传输层。</li>
<li>UNIX网络编程第一卷：套接口API和X/Open传输接口API，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。不仅对套接口网络编程有极好的描述，而且极为详尽的阐述了相关的网络背景知识。不论是入门还是深入研究，都是不可多得的好资料。</li>
<li>Linux内核源代码情景分析（下），毛德操、胡希明著，浙江大学出版社，给出了unix域套接口部分的内核代码分析。</li>
<li>GNU/Linux编程指南，入门、应用、精通，第二版，Kurt Wall等著，张辉译</li>
</ol>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part6/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/套接字/" data-id="ciqarm458001ch8qy1f8tev9v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-信号灯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/信号灯/" class="article-date">
  <time datetime="2016-07-02T04:57:06.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/信号灯/">信号灯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。</p>
<h3 id="一、信号灯概述"><a href="#一、信号灯概述" class="headerlink" title="一、信号灯概述"></a>一、信号灯概述</h3><p>信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号灯有以下两种类型：</p>
<ol>
<li>二值信号灯：最简单的信号灯形式，信号灯的值只能取0或1，类似于互斥锁。<br>注：二值信号灯能够实现互斥锁的功能，但两者的关注内容不同。信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</li>
<li>计算信号灯：信号灯的值可以取任意非负值（当然受内核本身的约束）。</li>
</ol>
<h3 id="二、Linux信号灯"><a href="#二、Linux信号灯" class="headerlink" title="二、Linux信号灯"></a>二、Linux信号灯</h3><p>linux对信号灯的支持状况与消息队列一样，在red had 8.0发行版本中支持的是系统V的信号灯。因此，本文将主要介绍系统V信号灯及其相应API。在没有声明的情况下，以下讨论中指的都是系统V信号灯。</p>
<p>注意，通常所说的系统V信号灯指的是计数信号灯集。</p>
<h3 id="三、信号灯与内核"><a href="#三、信号灯与内核" class="headerlink" title="三、信号灯与内核"></a>三、信号灯与内核</h3><ol>
<li><p>系统V信号灯是随内核持续的，只有在内核重起或者显示删除一个信号灯集时，该信号灯集才会真正被删除。因此系统中记录信号灯的数据结构（struct ipc_ids sem_ids）位于内核中，系统中的所有信号灯都可以在结构sem_ids中找到访问入口。</p>
</li>
<li><p>下图说明了内核与信号灯是怎样建立起联系的：<br>其中：struct ipc_ids sem_ids是内核中记录信号灯的全局数据结构；描述一个具体的信号灯及其相关信息。<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯全局数据结构.png" alt=""></p>
</li>
</ol>
<p>其中，struct sem结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sem&#123;</span><br><span class="line"><span class="keyword">int</span> semval;		<span class="comment">// current value</span></span><br><span class="line"><span class="keyword">int</span> sempid		<span class="comment">// pid of last operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上图可以看出，全局数据结构struct ipc_ids sem_ids可以访问到struct kern_ipc_perm的第一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的信号灯对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个信号灯集；同时，结构struct kern_ipc_perm的最后一个成员sem_nsems确定了该信号灯在信号灯集中的顺序，这样内核就能够记录每个信号灯的信息了。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*系统中的每个信号灯集对应一个sem_array 结构 */</span><br><span class="line">struct sem_array &#123;</span><br><span class="line">  struct kern_ipc_perm  sem_perm;    /* permissions .. see ipc.h */</span><br><span class="line">  time_t      sem_otime;      /* last semop time */</span><br><span class="line">  time_t      sem_ctime;      /* last change time */</span><br><span class="line">  struct sem    *sem_base;      /* ptr to first semaphore in<span class="instruction"> array </span>*/</span><br><span class="line">  struct sem_queue  *sem_pending;    /* pending operations to be processed */</span><br><span class="line">  struct sem_queue  **sem_pending_last;   /* last pending operation */</span><br><span class="line">  struct sem_undo    *undo;      /* undo requests on this<span class="instruction"> array </span>*/</span><br><span class="line">  unsigned<span class="instruction"> long </span>   sem_nsems;    /* no. of semaphores in<span class="instruction"> array </span>*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，sem_queue结构如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span> 系统中每个因为信号灯而睡眠的进程，都对应一个sem_queue结构<span class="keyword">*</span>/</span><br><span class="line"> struct sem_queue &#123;</span><br><span class="line">  struct sem_queue <span class="keyword">*</span>  next;     /<span class="keyword">*</span> next entry in the queue <span class="keyword">*</span>/</span><br><span class="line">  struct sem_queue <span class="keyword">*</span><span class="keyword">*</span>  prev;</span><br><span class="line">  /<span class="keyword">*</span> previous entry in the queue, <span class="keyword">*</span>(q-&gt;prev) == q <span class="keyword">*</span>/</span><br><span class="line">  struct task_struct<span class="keyword">*</span>  sleeper;   /<span class="keyword">*</span> this process <span class="keyword">*</span>/</span><br><span class="line">  struct sem_undo <span class="keyword">*</span>  undo;     /<span class="keyword">*</span> undo structure <span class="keyword">*</span>/</span><br><span class="line">  int   pid;             /<span class="keyword">*</span> process id of requesting process <span class="keyword">*</span>/</span><br><span class="line">  int   status;           /<span class="keyword">*</span> completion status of operation <span class="keyword">*</span>/</span><br><span class="line">  struct sem_array <span class="keyword">*</span>  sma;       /<span class="keyword">*</span> semaphore array for operations <span class="keyword">*</span>/</span><br><span class="line">  int  id;               /<span class="keyword">*</span> internal sem id <span class="keyword">*</span>/</span><br><span class="line">  struct sembuf <span class="keyword">*</span>  sops;       /<span class="keyword">*</span> array of pending operations <span class="keyword">*</span>/</span><br><span class="line">  int  nsops;             /<span class="keyword">*</span> number of operations <span class="keyword">*</span>/</span><br><span class="line">  int  alter;             /<span class="keyword">*</span> operation will alter semaphore <span class="keyword">*</span>/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、操作信号灯"><a href="#四、操作信号灯" class="headerlink" title="四、操作信号灯"></a>四、操作信号灯</h3><p>对消息队列的操作无非有下面三种类型：</p>
<ol>
<li><p>打开或创建信号灯<br>与消息队列的创建及打开基本相同，不再详述。</p>
</li>
<li><p>信号灯值操作<br>linux可以增加或减小信号灯的值，相应于对共享资源的释放和占有。具体参见后面的semop系统调用。</p>
</li>
<li><p>获得或设置信号灯属性：<br>系统中的每一个信号灯集都对应一个struct sem_array结构，该结构记录了信号灯集的各种信息，存在于系统空间。为了设置、获得该信号灯集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即union semun。<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯union_semun数据结构.png" alt=""></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">	<span class="keyword">int</span> val;					<span class="comment">/* value for SETVAL */</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;		<span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;		<span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">	<span class="keyword">struct</span> seminfo *__buf;		<span class="comment">/* buffer for IPC_INFO */</span>   <span class="comment">//test!!</span></span><br><span class="line">	<span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span>  seminfo &#123;</span><br><span class="line">	<span class="keyword">int</span> semmap;</span><br><span class="line">	<span class="keyword">int</span> semmni;</span><br><span class="line">	<span class="keyword">int</span> semmns;</span><br><span class="line">	<span class="keyword">int</span> semmnu;</span><br><span class="line">	<span class="keyword">int</span> semmsl;</span><br><span class="line">	<span class="keyword">int</span> semopm;</span><br><span class="line">	<span class="keyword">int</span> semume;</span><br><span class="line">	<span class="keyword">int</span> semusz;</span><br><span class="line">	<span class="keyword">int</span> semvmx;</span><br><span class="line">	<span class="keyword">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="信号灯API"><a href="#信号灯API" class="headerlink" title="信号灯API"></a>信号灯API</h3><h4 id="1、文件名到键值"><a href="#1、文件名到键值" class="headerlink" title="1、文件名到键值"></a>1、文件名到键值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)；</span><br></pre></td></tr></table></figure>
<p>它返回与路径pathname相对应的一个键值.</p>
<h4 id="2、linux特有的ipc-调用："><a href="#2、linux特有的ipc-调用：" class="headerlink" title="2、linux特有的ipc()调用："></a>2、linux特有的ipc()调用：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> call, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> third, <span class="keyword">void</span> \*ptr, <span class="keyword">long</span> fifth)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数call取不同值时，对应信号灯的三个系统调用：</p>
<ol>
<li>当call为SEMOP时，对应int semop(int semid, struct sembuf *sops, unsigned nsops)调用；</li>
<li>当call为SEMGET时，对应int semget(key_t key, int nsems, int semflg)调用；</li>
<li>当call为SEMCTL时，对应int semctl(int semid，int semnum，int cmd，union semun arg)调用；<br>这些调用将在后面阐述。</li>
</ol>
<h3 id="3、系统V信号灯API"><a href="#3、系统V信号灯API" class="headerlink" title="3、系统V信号灯API"></a>3、系统V信号灯API</h3><p>系统V消息队列API只有三个，使用时需要包括几个头文件：<br> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="1）int-semget-key-t-key-int-nsems-int-semflg"><a href="#1）int-semget-key-t-key-int-nsems-int-semflg" class="headerlink" title="1）int semget(key_t key, int nsems, int semflg)"></a>1）int semget(key_t key, int nsems, int semflg)</h5><p>  参数key是一个键值，由ftok获得，唯一标识一个信号灯集，用法与msgget()中的key相同；参数nsems指定打开或者新创建的信号灯集中将包含信号灯的数目；semflg参数是一些标志位。参数key和semflg的取值，以及何时打开已有信号灯集或者创建一个新的信号灯集与msgget()中的对应部分相同，不再祥述。<br>  该调用返回与健值key相对应的信号灯集描述字。<br>  调用返回：成功返回信号灯集描述字，否则返回-1。<br>  注：如果key所代表的信号灯已经存在，且semget指定了IPC_CREAT|IPC_EXCL标志，那么即使参数nsems与原来信号灯的数目不等，返回的也是EEXIST错误；如果semget只指定了IPC_CREAT标志，那么参数nsems必须与原来的值一致，在后面程序实例中还要进一步说明。</p>
<h5 id="2）int-semop-int-semid-struct-sembuf-sops-unsigned-nsops"><a href="#2）int-semop-int-semid-struct-sembuf-sops-unsigned-nsops" class="headerlink" title="2）int semop(int semid, struct sembuf *sops, unsigned nsops);"></a>2）int semop(int semid, struct sembuf *sops, unsigned nsops);</h5><p>  semid是信号灯集ID，sops指向数组的每一个sembuf结构都刻画一个在特定信号灯上的操作。nsops为sops指向数组的大小。<br>  sembuf结构如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sembuf &#123;</span><br><span class="line">	unsigned short  	sem_num;		/* semaphore index in<span class="instruction"> array </span>*/</span><br><span class="line">	short			sem_op;		/* semaphore operation */</span><br><span class="line">	short			sem_flg;		/* operation flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sem_num对应信号集中的信号灯，0对应第一个信号灯。sem_flg可取IPC_NOWAIT以及SEM_UNDO两个标志。如果设置了SEM_UNDO标志，那么在进程结束时，相应的操作将被取消，这是比较重要的一个标志位。如果设置了该标志位，那么在进程没有释放共享资源就退出时，内核将代为释放。如果为一个信号灯设置了该标志，内核都要分配一个sem_undo结构来记录它，为的是确保以后资源能够安全释放。事实上，如果进程退出了，那么它所占用就释放了，但信号灯值却没有改变，此时，信号灯值反映的已经不是资源占有的实际情况，在这种情况下，问题的解决就靠内核来完成。这有点像僵尸进程，进程虽然退出了，资源也都释放了，但内核进程表中仍然有它的记录，此时就需要父进程调用waitpid来解决问题了。<br> sem_op的值大于0，等于0以及小于0确定了对sem_num指定的信号灯进行的三种操作。具体请参考linux相应手册页。<br> 这里需要强调的是semop同时操作多个信号灯，在实际应用中，对应多种资源的申请或释放。semop保证操作的原子性，这一点尤为重要。尤其对于多种资源的申请来说，要么一次性获得所有资源，要么放弃申请，要么在不占有任何资源情况下继续等待，这样，一方面避免了资源的浪费；另一方面，避免了进程之间由于申请共享资源造成死锁。<br> 也许从实际含义上更好理解这些操作：信号灯的当前值记录相应资源目前可用数目；sem_op&gt;0对应相应进程要释放sem_op数目的共享资源；sem_op=0可以用于对共享资源是否已用完的测试；sem_op&lt;0相当于进程要申请-sem_op个共享资源。再联想操作的原子性，更不难理解该系统调用何时正常返回，何时睡眠等待。<br> 调用返回：成功返回0，否则返回-1。</p>
<h5 id="3-int-semctl-int-semid，int-semnum，int-cmd，union-semun-arg"><a href="#3-int-semctl-int-semid，int-semnum，int-cmd，union-semun-arg" class="headerlink" title="3) int semctl(int semid，int semnum，int cmd，union semun arg)"></a>3) int semctl(int semid，int semnum，int cmd，union semun arg)</h5><p> 该系统调用实现对信号灯的各种控制操作，参数semid指定信号灯集，参数cmd指定具体的操作类型；参数semnum指定对哪个信号灯操作，只对几个特殊的cmd操作有意义；arg用于设置或返回信号灯信息。<br> 该系统调用详细信息请参见其手册页，这里只给出参数cmd所能指定的操作。</p>
<ol>
<li><p>IPC_STAT</p>
<p>获取信号灯信息，信息由arg.buf返回；</p>
</li>
</ol>
<ol>
<li><p>IPC_SET 设置信号灯信息，待设置信息保存在arg.buf中（在manpage中给出了可以设置哪些信息）；<br>GETALL 返回所有信号灯的值，结果保存在arg.array中，参数sennum被忽略；<br>GETNCNT 返回等待semnum所代表信号灯的值增加的进程数，相当于目前有多少进程在等待semnum代表的信号灯所代表的共享资源；<br>GETPID 返回最后一个对semnum所代表信号灯执行semop操作的进程ID；<br>GETVAL 返回semnum所代表信号灯的值；<br>GETZCNT 返回等待semnum所代表信号灯的值变成0的进程数；<br>SETALL 通过arg.array更新所有信号灯的值；同时，更新与本信号集相关的semid_ds结构的sem_ctime成员；<br>SETVAL 设置semnum所代表信号灯的值为arg.val；</p>
<p>调用返回：调用失败返回-1，成功返回与cmd相关：</p>
</li>
</ol>
<h6 id="Cmd-return-value"><a href="#Cmd-return-value" class="headerlink" title="Cmd          return value"></a>Cmd          return value</h6><p> GETNCNT      Semncnt<br> GETPID       Sempid<br> GETVAL       Semval<br> GETZCNT      Semzcnt</p>
<h3 id="五、信号灯的限制"><a href="#五、信号灯的限制" class="headerlink" title="五、信号灯的限制"></a>五、信号灯的限制</h3><ol>
<li><p>一次系统调用semop可同时操作的信号灯数目SEMOPM，semop中的参数nsops如果超过了这个数目，将返回E2BIG错误。SEMOPM的大小特定与系统，redhat 8.0为32。</p>
</li>
<li><p>信号灯的最大数目：SEMVMX，当设置信号灯值超过这个限制时，会返回ERANGE错误。在redhat 8.0中该值为32767。</p>
</li>
<li><p>系统范围内信号灯集的最大数目SEMMNI以及系统范围内信号灯的最大数目SEMMNS。超过这两个限制将返回ENOSPC错误。redhat 8.0中该值为32000。</p>
</li>
<li><p>每个信号灯集中的最大信号灯数目SEMMSL，redhat 8.0中为250。 SEMOPM以及SEMVMX是使用semop调用时应该注意的；SEMMNI以及SEMMNS是调用semget时应该注意的。SEMVMX同时也是semctl调用应该注意的。</p>
</li>
</ol>
<h3 id="六、竞争问题"><a href="#六、竞争问题" class="headerlink" title="六、竞争问题"></a>六、竞争问题</h3><p>第一个创建信号灯的进程同时也初始化信号灯，这样，系统调用semget包含了两个步骤：创建信号灯；初始化信号灯。由此可能导致一种竞争状态：第一个创建信号灯的进程在初始化信号灯时，第二个进程又调用semget，并且发现信号灯已经存在，此时，第二个进程必须具有判断是否有进程正在对信号灯进行初始化的能力。在参考文献[1]中，给出了绕过这种竞争状态的方法：当semget创建一个新的信号灯时，信号灯结构semid_ds的sem_otime成员初始化后的值为0。因此，第二个进程在成功调用semget后，可再次以IPC_STAT命令调用semctl，等待sem_otime变为非0值，此时可判断该信号灯已经初始化完毕。下图描述了竞争状态产生及解决方法：<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯竞争问题.png" alt=""><br>实际上，这种解决方法也是基于这样一个假定：第一个创建信号灯的进程必须调用semop，这样sem_otime才能变为非零值。另外，因为第一个进程可能不调用semop，或者semop操作需要很长时间，第二个进程可能无限期等待下去，或者等待很长时间。</p>
<h3 id="七、信号灯应用实例"><a href="#七、信号灯应用实例" class="headerlink" title="七、信号灯应用实例"></a>七、信号灯应用实例</h3><p>本实例有两个目的：1、获取各种信号灯信息；2、利用信号灯实现共享资源的申请和释放。并在程序中给出了详细注释。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SEM_PATH <span class="string">"/unix/my_sem"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> max_tries <span class="number">3</span></span></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flag1,flag2,key,i,init_ok,tmperrno;</span><br><span class="line"><span class="keyword">struct</span> semid_ds sem_info;</span><br><span class="line"><span class="keyword">struct</span> seminfo sem_info2;</span><br><span class="line"><span class="keyword">union</span> semun arg;       <span class="comment">//union semun： 请参考附录2</span></span><br><span class="line"><span class="keyword">struct</span> sembuf askfor_res, free_res;</span><br><span class="line">flag1=IPC_CREAT|IPC_EXCL|<span class="number">00666</span>;</span><br><span class="line">flag2=IPC_CREAT|<span class="number">00666</span>;</span><br><span class="line">key=ftok(SEM_PATH,<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//error handling for ftok here;</span></span><br><span class="line">init_ok=<span class="number">0</span>;</span><br><span class="line">semid=semget(key,<span class="number">1</span>,flag1);</span><br><span class="line"><span class="comment">//create a semaphore set that only includes one semphore.</span></span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  tmperrno=errno;</span><br><span class="line">  perror(<span class="string">"semget"</span>);</span><br><span class="line"><span class="keyword">if</span>(tmperrno==EEXIST)</span><br><span class="line"><span class="comment">//errno is undefined after a successful library call( including perror call)</span></span><br><span class="line"><span class="comment">//so it is saved  in tmperrno.</span></span><br><span class="line">    &#123;</span><br><span class="line">    semid=semget(key,<span class="number">1</span>,flag2);</span><br><span class="line"><span class="comment">//flag2 只包含了IPC_CREAT标志, 参数nsems(这里为1)必须与原来的信号灯数目一致</span></span><br><span class="line">    arg.buf=&amp;sem_info;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;max_tries; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_STAT, arg)==-<span class="number">1</span>)</span><br><span class="line">      &#123;  perror(<span class="string">"semctl error"</span>); i=max_tries;&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(arg.buf-&gt;sem_otime!=<span class="number">0</span>)&#123; i=max_tries;  init_ok=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span>   sleep(<span class="number">1</span>);  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!init_ok)</span><br><span class="line">  <span class="comment">// do some initializing, here we assume that the first process that creates the sem</span></span><br><span class="line">  <span class="comment">//  will finish initialize the sem and run semop in max_tries*1 seconds. else it will  </span></span><br><span class="line">  <span class="comment">// not run semop any more.</span></span><br><span class="line">    &#123;</span><br><span class="line">      arg.val=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,arg)==-<span class="number">1</span>) perror(<span class="string">"semctl setval error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;perror(<span class="string">"semget error, process exit"</span>);  <span class="built_in">exit</span>();  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//semid&gt;=0; do some initializing   </span></span><br><span class="line">&#123;</span><br><span class="line">  arg.val=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl setval error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get some information about the semaphore and the limit of semaphore in redhat8.0</span></span><br><span class="line">  arg.buf=&amp;sem_info;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_STAT, arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC STAT"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"owner's uid is %d\n"</span>,   arg.buf-&gt;sem_perm.uid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"owner's gid is %d\n"</span>,   arg.buf-&gt;sem_perm.gid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"creater's uid is %d\n"</span>,   arg.buf-&gt;sem_perm.cuid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"creater's gid is %d\n"</span>,   arg.buf-&gt;sem_perm.cgid);</span><br><span class="line">  arg.__buf=&amp;sem_info2;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,IPC_INFO,arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC_INFO"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the number of entries in semaphore map is %d \n"</span>,  arg.__buf-&gt;semmap);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of semaphore identifiers is %d \n"</span>,    arg.__buf-&gt;semmni);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"mas number of semaphores in system is %d \n"</span>,   arg.__buf-&gt;semmns);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the number of undo structures system wide is %d \n"</span>,  arg.__buf-&gt;semmnu);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of semaphores per semid is %d \n"</span>,   arg.__buf-&gt;semmsl);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of ops per semop call is %d \n"</span>,  arg.__buf-&gt;semopm);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of undo entries per process is %d \n"</span>,  arg.__buf-&gt;semume);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the sizeof of struct sem_undo is %d \n"</span>,  arg.__buf-&gt;semusz);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the maximum semaphore value is %d \n"</span>,  arg.__buf-&gt;semvmx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//now ask for available resource:  </span></span><br><span class="line">  askfor_res.sem_num=<span class="number">0</span>;</span><br><span class="line">  askfor_res.sem_op=-<span class="number">1</span>;</span><br><span class="line">  askfor_res.sem_flg=SEM_UNDO;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(semid,&amp;askfor_res,<span class="number">1</span>)==-<span class="number">1</span>)<span class="comment">//ask for resource</span></span><br><span class="line">      perror(<span class="string">"semop error"</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//do some handling on the sharing resource here, just sleep on it 3 seconds</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"now free the resource\n"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//now free resource  </span></span><br><span class="line">  free_res.sem_num=<span class="number">0</span>;</span><br><span class="line">  free_res.sem_op=<span class="number">1</span>;</span><br><span class="line">  free_res.sem_flg=SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span>(semop(semid,&amp;free_res,<span class="number">1</span>)==-<span class="number">1</span>)<span class="comment">//free the resource.</span></span><br><span class="line">    <span class="keyword">if</span>(errno==EIDRM)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"the semaphore set was removed\n"</span>);</span><br><span class="line"><span class="comment">//you can comment out the codes below to compile a different version:      </span></span><br><span class="line">  <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_RMID)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC_RMID"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"remove sem ok\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：读者可以尝试一下注释掉初始化步骤，进程在运行时会出现何种情况（进程在申请资源时会睡眠），同时可以像程序结尾给出的注释那样，把该程序编译成两个不同版本。下面是本程序的运行结果（操作系统redhat8.0）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">owne<span class="string">r's uid is 0</span><br><span class="line">owner'</span>s gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">create<span class="string">r's uid is 0</span><br><span class="line">creater'</span>s gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">the number of entries <span class="keyword">in</span> semaphore map <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">max number of semaphore identifiers <span class="keyword">is</span> <span class="number">128</span></span><br><span class="line">mas number of semaphores <span class="keyword">in</span> system <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">the number of undo structures system wide <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">max number of semaphores per semid <span class="keyword">is</span> <span class="number">250</span></span><br><span class="line">max number of ops per semop call <span class="keyword">is</span> <span class="number">32</span></span><br><span class="line">max number of undo entries per process <span class="keyword">is</span> <span class="number">32</span></span><br><span class="line">the sizeof of struct sem_undo <span class="keyword">is</span> <span class="number">20</span></span><br><span class="line">the maximum semaphore value <span class="keyword">is</span> <span class="number">32767</span></span><br><span class="line">now free the resource</span><br><span class="line">remove sem ok</span><br></pre></td></tr></table></figure></p>
<p>Summary：信号灯与其它进程间通信方式有所不同，它主要用于进程间同步。通常所说的系统V信号灯实际上是一个信号灯的集合，可用于多种共享资源的进程间同步。每个信号灯都有一个值，可以用来表示当前该信号灯代表的共享资源可用（available）数量，如果一个进程要申请共享资源，那么就从信号灯值中减去要申请的数目，如果当前没有足够的可用资源，进程可以睡眠等待，也可以立即返回。当进程要申请多种共享资源时，linux可以保证操作的原子性，即要么申请到所有的共享资源，要么放弃所有资源，这样能够保证多个进程不会造成互锁。Linux对信号灯有各种各样的限制，程序中给出了输出结果。另外，如果读者想对信号灯作进一步的理解，建议阅读sem.h源代码，该文件不长，但给出了信号灯相关的重要数据结构。</p>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part4/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/信号灯/" data-id="ciqarm4660029h8qyfmruigl1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-消息队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/消息队列/" class="article-date">
  <time datetime="2016-07-02T04:38:11.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/消息队列/">消息队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息队列（也叫做报文队列）能够克服早期unix通信机制的一些缺点。作为早期unix通信机制之一的信号能够传送的信息量有限，后来虽然POSIX 1003.1b在信号的实时性方面作了拓广，使得信号在传递信息量方面有了相当程度的改进，但是信号这种通信方式更像”即时”的通信方式，它要求接受信号的进程在某个时间范围内对信号做出反应，因此该信号最多在接受信号进程的生命周期内才有意义，信号所传递的信息是接近于随进程持续的概念（process-persistent），见 附录 1；管道及有名管道及有名管道则是典型的随进程持续IPC，并且，只能传送无格式的字节流无疑会给应用程序开发带来不便，另外，它的缓冲区大小也受到限制。</p>
<p>消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的（参见 附录 1）。</p>
<p>目前主要有两种类型的消息队列：POSIX消息队列以及系统V消息队列，系统V消息队列目前被大量使用。考虑到程序的可移植性，新开发的应用程序应尽量使用POSIX消息队列。</p>
<p>在本系列专题的序（深刻理解Linux进程间通信（IPC））中，提到对于消息队列、信号灯、以及共享内存区来说，有两个实现版本：POSIX的以及系统V的。Linux内核（内核2.4.18）支持POSIX信号灯、POSIX共享内存区以及POSIX消息队列，但对于主流Linux发行版本之一redhad8.0（内核2.4.18），还没有提供对POSIX进程间通信API的支持，不过应该只是时间上的事。</p>
<p>因此，本文将主要介绍系统V消息队列及其相应API。 在没有声明的情况下，以下讨论中指的都是系统V消息队列。</p>
<h3 id="消息队列基本概念"><a href="#消息队列基本概念" class="headerlink" title="消息队列基本概念"></a>消息队列基本概念</h3><p>1、系统V消息队列是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构（struct ipc_ids msg_ids）位于内核中，系统中的所有消息队列都可以在结构msg_ids中找到访问入口。<br>2、消息队列就是一个消息的链表。每个消息队列都有一个队列头，用结构struct msg_queue来描述（参见 附录 2）。队列头中包含了该消息队列的大量信息，包括消息队列键值、用户ID、组ID、消息队列中消息数目等等，甚至记录了最近对消息队列读写进程的ID。读者可以访问这些信息，也可以设置其中的某些信息。<br>3、下图说明了内核与消息队列是怎样建立起联系的：<br> 其中：struct ipc_ids msg_ids是内核中记录消息队列的全局数据结构；struct msg_queue是每个消息队列的队列头。</p>
<p><img src="/pictures/Linux/进程间通信/共享内存-消息队列全局数据结构.png" alt=""></p>
<p>从上图可以看出，全局数据结构 struct ipc_ids msg_ids 可以访问到每个消息队列头的第一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的消息队列对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个消息队列。kern_ipc_perm结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kern_ipc_perm&#123;   <span class="comment">//内核中记录消息队列的全局数据结构msg_ids能够访问到该结构；</span></span><br><span class="line">            <span class="keyword">key_t</span>   key;    <span class="comment">//该键值则唯一对应一个消息队列</span></span><br><span class="line">            <span class="keyword">uid_t</span>   uid;</span><br><span class="line">            <span class="keyword">gid_t</span>   gid;</span><br><span class="line"><span class="keyword">uid_t</span>   cuid;</span><br><span class="line"><span class="keyword">gid_t</span>   cgid;</span><br><span class="line"><span class="keyword">mode_t</span>  mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作消息队列"><a href="#操作消息队列" class="headerlink" title="操作消息队列"></a>操作消息队列</h3><h5 id="对消息队列的操作无非有下面三种类型："><a href="#对消息队列的操作无非有下面三种类型：" class="headerlink" title="对消息队列的操作无非有下面三种类型："></a>对消息队列的操作无非有下面三种类型：</h5><p>1、 打开或创建消息队列<br> 消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，只需提供该消息队列的键值即可；</p>
<p>注：消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。</p>
<p>2、 读写操作<br>消息读写操作非常简单，对开发人员来说，每个消息都类似如下的数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msgbuf&#123;</span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mtype成员代表消息类型，从消息队列中读取消息的一个重要依据就是消息的类型；mtext是消息内容，当然长度不一定为1。因此，对于发送消息来说，首先预置一个msgbuf缓冲区并写入消息类型和内容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个msgbuf缓冲区，然后把消息读入该缓冲区即可。</p>
<p>3、 获得或设置消息队列属性：<br>消息队列的信息基本上都保存在消息队列头中，因此，可以分配一个类似于消息队列头的结构(struct msqid_ds，见 附录 2)，来返回消息队列的属性；同样可以设置该数据结构。 <img src="/pictures/Linux/进程间通信/共享内存-消息队列数据结构.png" alt=""></p>
<h3 id="消息队列API"><a href="#消息队列API" class="headerlink" title="消息队列API"></a>消息队列API</h3><h4 id="1、文件名到键值"><a href="#1、文件名到键值" class="headerlink" title="1、文件名到键值"></a>1、文件名到键值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)；</span><br></pre></td></tr></table></figure>
<p>它返回与路径pathname相对应的一个键值。该函数不直接对消息队列操作，但在调用ipc(MSGGET,…)或msgget()来获得消息队列描述字前，往往要调用该函数。典型的调用代码是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key=ftok(path_ptr, <span class="string">'a'</span>);</span><br><span class="line">    ipc_id=ipc(MSGGET, (<span class="keyword">int</span>)key, flags,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    …</span><br></pre></td></tr></table></figure></p>
<h4 id="2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面："><a href="#2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面：" class="headerlink" title="2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面："></a>2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面：</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ipc(unsigned <span class="keyword">int</span> <span class="built_in">call</span>, <span class="keyword">int</span> <span class="keyword">first</span>, <span class="keyword">int</span> second, <span class="keyword">int</span> third, void * <span class="keyword">ptr</span>, long fifth);</span><br><span class="line">第一个参数指明对IPC对象的操作方式，对消息队列而言共有四种操作：MSGSND、MSGRCV、MSGGET以及MSGCTL，分别代表向消息队列发送消息、从消息队列读取消息、打开或创建消息队列、控制消息队列；<span class="keyword">first</span>参数代表唯一的IPC对象；下面将介绍四种操作.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGGET, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgget( (key_t)<span class="keyword">first</span>，second)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGCTL, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth)</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgctl( <span class="keyword">first</span>，second, (struct msqid_ds*) <span class="keyword">ptr</span>)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGSND, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgsnd( <span class="keyword">first</span>, (struct msgbuf*)<span class="keyword">ptr</span>, second, third)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGRCV, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgrcv( <span class="keyword">first</span>，(struct msgbuf*)<span class="keyword">ptr</span>, second, fifth,third)，</span><br></pre></td></tr></table></figure>
<p>注：本人不主张采用系统调用ipc()，而更倾向于采用系统V或者POSIX进程间通信API。原因如下：</p>
<li>虽然该系统调用提供了统一的用户界面，但正是由于这个特性，它的参数几乎不能给出特定的实际意义（如以first、second来命名参数），在一定程度上造成开发不便。</li><br><li>正如ipc手册所说的：ipc()是linux所特有的，编写程序时应注意程序的移植性问题；</li><br><li>该系统调用的实现不过是把系统V IPC函数进行了封装，没有任何效率上的优势；</li><br><li>系统V在IPC方面的API数量不多，形式也较简洁。</li>

<h3 id="系统V消息队列API"><a href="#系统V消息队列API" class="headerlink" title="系统V消息队列API"></a>系统V消息队列API</h3><p>系统V消息队列API共有四个，使用时需要包括几个头文件：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="int-msgget-key-t-key-int-msgflg"><a href="#int-msgget-key-t-key-int-msgflg" class="headerlink" title="int msgget(key_t key, int msgflg)"></a>int msgget(key_t key, int msgflg)</h5><p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。</p>
<p>在以下两种情况下，该调用将创建一个新的消息队列：</p>
<li>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位；</li><br><li>key参数为IPC_PRIVATE；</li>

<p>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。</p>
<p>调用返回：成功返回消息队列描述字，否则返回-1。</p>
<p>注：参数key设置成常数IPC_PRIVATE并不意味着其他进程不能访问该消息队列，只意味着即将创建新的消息队列。</p>
<h5 id="int-msgrcv-int-msqid-struct-msgbuf-msgp-int-msgsz-long-msgtyp-int-msgflg"><a href="#int-msgrcv-int-msqid-struct-msgbuf-msgp-int-msgsz-long-msgtyp-int-msgflg" class="headerlink" title="int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);"></a>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);</h5><p>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。</p>
<p>msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：</p>
<li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li><br><li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li><br><li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li>

<p>msgrcv手册中详细给出了消息类型取不同值时(&gt;0; &lt;0; =0)，调用将返回消息队列中的哪个消息。</p>
<p>msgrcv()解除阻塞的条件有三个：</p>
<p>1.消息队列中有了满足条件的消息；<br>2.msqid代表的消息队列被删除；<br>3.调用msgrcv（）的进程被信号中断；</p>
<p>调用返回：成功返回读出消息的实际字节数，否则返回-1。</p>
<h5 id="int-msgsnd-int-msqid-struct-msgbuf-msgp-int-msgsz-int-msgflg"><a href="#int-msgsnd-int-msqid-struct-msgbuf-msgp-int-msgsz-int-msgflg" class="headerlink" title="int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);"></a>int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);</h5><p>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。</p>
<p>对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p>
<p>  当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；<br>  当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</p>
<p>msgsnd()解除阻塞的条件有三个：<br>1.不满足上述两个条件，即消息队列中有容纳该消息的空间；<br>2.msqid代表的消息队列被删除；<br>3.调用msgsnd（）的进程被信号中断；</p>
<p>调用返回：成功返回0，否则返回-1。</p>
<h5 id="int-msgctl-int-msqid-int-cmd-struct-msqid-ds-buf"><a href="#int-msgctl-int-msqid-int-cmd-struct-msqid-ds-buf" class="headerlink" title="int msgctl(int msqid, int cmd, struct msqid_ds *buf);"></a>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</h5><p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。</p>
<ol>
<li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li>
<li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li>
<li>IPC_RMID：删除msqid标识的消息队列；</li>
</ol>
<p>调用返回：成功返回0，否则返回-1。</p>
<h3 id="消息队列的限制"><a href="#消息队列的限制" class="headerlink" title="消息队列的限制"></a>消息队列的限制</h3><p>每个消息队列的容量（所能容纳的字节数）都有限制，该值因系统不同而不同。在后面的应用实例中，输出了redhat 8.0的限制，结果参见 附录 3。</p>
<p>另一个限制是每个消息队列所能容纳的最大消息数：在redhad 8.0中，该限制是受消息队列容量制约的：消息个数要小于消息队列的容量（字节数）。</p>
<p>注：上述两个限制是针对每个消息队列而言的，系统对消息队列的限制还有系统范围内的最大消息队列个数，以及整个系统范围内的最大消息数。一般来说，实际开发过程中不会超过这个限制。</p>
<h3 id="消息队列应用实例"><a href="#消息队列应用实例" class="headerlink" title="消息队列应用实例"></a>消息队列应用实例</h3><p>消息队列应用相对较简单，下面实例基本上覆盖了对消息队列的所有操作，同时，程序输出结果有助于加深对前面所讲的某些规则及消息队列限制的理解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">struct</span> msqid_ds )</span></span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gflags,sflags,rflags;</span><br><span class="line"><span class="keyword">key_t</span> key;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line"><span class="keyword">struct</span> msgsbuf&#123;</span><br><span class="line">        <span class="keyword">int</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">    &#125;msg_sbuf;</span><br><span class="line"><span class="keyword">struct</span> msgmbuf</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">10</span>];</span><br><span class="line">    &#125;msg_rbuf;</span><br><span class="line"><span class="keyword">struct</span> msqid_ds msg_ginfo,msg_sinfo;</span><br><span class="line"><span class="keyword">char</span>* msgpath=<span class="string">"/unix/msgqueue"</span>;</span><br><span class="line">key=ftok(msgpath,<span class="string">'a'</span>);</span><br><span class="line">gflags=IPC_CREAT|IPC_EXCL;</span><br><span class="line">msgid=msgget(key,gflags|<span class="number">00666</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg create error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个消息队列后，输出消息队列缺省属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">sflags=IPC_NOWAIT;</span><br><span class="line">msg_sbuf.mtype=<span class="number">10</span>;</span><br><span class="line">msg_sbuf.mtext[<span class="number">0</span>]=<span class="string">'a'</span>;</span><br><span class="line">reval=msgsnd(msgid,&amp;msg_sbuf,<span class="keyword">sizeof</span>(msg_sbuf.mtext),sflags);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message send error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一个消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">rflags=IPC_NOWAIT|MSG_NOERROR;</span><br><span class="line">reval=msgrcv(msgid,&amp;msg_rbuf,<span class="number">4</span>,<span class="number">10</span>,rflags);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read msg error\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read from msg queue %d bytes\n"</span>,reval);</span><br><span class="line"><span class="comment">//从消息队列中读出消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">msg_sinfo.msg_perm.uid=<span class="number">8</span>;<span class="comment">//just a try</span></span><br><span class="line">msg_sinfo.msg_perm.gid=<span class="number">8</span>;<span class="comment">//</span></span><br><span class="line">msg_sinfo.msg_qbytes=<span class="number">16388</span>;</span><br><span class="line"><span class="comment">//此处验证超级用户可以更改消息队列的缺省msg_qbytes</span></span><br><span class="line"><span class="comment">//注意这里设置的值大于缺省值</span></span><br><span class="line">reval=msgctl(msgid,IPC_SET,&amp;msg_sinfo);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg set info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line"><span class="comment">//验证设置消息队列属性</span></span><br><span class="line">reval=msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//删除消息队列</span></span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlink msg queue error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span> msgid,<span class="keyword">struct</span> msqid_ds msg_info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">//只是为了后面输出时间的方便</span></span><br><span class="line">reval=msgctl(msgid,IPC_STAT,&amp;msg_info);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get msg info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"current number of bytes on queue is %d\n"</span>,msg_info.msg_cbytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number of messages in queue is %d\n"</span>,msg_info.msg_qnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max number of bytes on queue is %d\n"</span>,msg_info.msg_qbytes);</span><br><span class="line"><span class="comment">//每个消息队列的容量（字节数）都有限制MSGMNB，值的大小因系统而异。在创建新的消息队列时，//msg_qbytes的缺省值就是MSGMNB</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgsnd is %d\n"</span>,msg_info.msg_lspid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgrcv is %d\n"</span>,msg_info.msg_lrpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgsnd time is %s"</span>, ctime(&amp;(msg_info.msg_stime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgrcv time is %s"</span>, ctime(&amp;(msg_info.msg_rtime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last change time is %s"</span>, ctime(&amp;(msg_info.msg_ctime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg uid is %d\n"</span>,msg_info.msg_perm.uid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg gid is %d\n"</span>,msg_info.msg_perm.gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出结果见 附录 3。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>消息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大。</p>
<h4 id="附录-1：-在参考文献-1-中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义："><a href="#附录-1：-在参考文献-1-中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义：" class="headerlink" title="附录 1： 在参考文献[1]中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义："></a>附录 1： 在参考文献[1]中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义：</h4><ol>
<li>随进程持续：IPC一直存在到打开IPC对象的最后一个进程关闭该对象为止。如管道和有名管道；</li>
<li>随内核持续：IPC一直持续到内核重新自举或者显示删除该对象为止。如消息队列、信号灯以及共享内存等；</li>
<li>随文件系统持续：IPC一直持续到显示删除该对象为止。</li>
</ol>
<h4 id="附录-2："><a href="#附录-2：" class="headerlink" title="附录 2："></a>附录 2：</h4><p>结构msg_queue用来描述消息队列头，存在于系统空间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_queue &#123;</span><br><span class="line">    <span class="keyword">struct</span> kern_ipc_perm q_perm;</span><br><span class="line">    <span class="keyword">time_t</span> q_stime;         <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime;         <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime;         <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;     <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;       <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;     <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid;          <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid;          <span class="comment">/* last receive pid */</span></span><br><span class="line">    <span class="keyword">struct</span> list_head q_messages;</span><br><span class="line">    <span class="keyword">struct</span> list_head q_receivers;</span><br><span class="line">    <span class="keyword">struct</span> list_head q_senders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结构msqid_ds用来设置或返回消息队列的信息，存在于用户空间；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msqid_ds &#123;</span><br><span class="line">    <span class="keyword">struct</span> ipc_perm msg_perm;</span><br><span class="line">    <span class="keyword">struct</span> msg *msg_first;      <span class="comment">/* first message on queue,unused  */</span></span><br><span class="line">    <span class="keyword">struct</span> msg *msg_last;       <span class="comment">/* last message in queue,unused */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_stime;  <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_rtime;  <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_cbytes;  <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qnum;    <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qbytes;  <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lspid;   <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lrpid;   <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看出上述两个结构很相似。</p>
<h4 id="附录-3：-消息队列实例输出结果："><a href="#附录-3：-消息队列实例输出结果：" class="headerlink" title="附录 3： 消息队列实例输出结果："></a>附录 3： 消息队列实例输出结果：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">current number of bytes on queue is 0</span><br><span class="line">number of messages in queue is 0</span><br><span class="line">max number of bytes on queue is 16384</span><br><span class="line">pid of last msgsnd is 0</span><br><span class="line">pid of last msgrcv is 0</span><br><span class="line">last msgsnd time is Thu Jan  1 08:00:00 1970</span><br><span class="line">last msgrcv time is Thu Jan  1 08:00:00 1970</span><br><span class="line">last <span class="operator"><span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">//上面刚刚创建一个新消息队列时的输出</span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16384</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">read</span> <span class="keyword">from</span> msg queue <span class="number">1</span> <span class="keyword">bytes</span></span><br><span class="line">//实际读出的字节数</span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16384</span>   //每个消息队列最大容量（字节数）</span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">22</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16388</span>   //可看出超级用户可修改消息队列最大容量</span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">2510</span>  //对操作消息队列进程的跟踪</span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">22</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">23</span> <span class="number">2002</span>    //msgctl()调用对msg_ctime有影响</span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">8</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">8</span></span></span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>UNIX网络编程第二卷：进程间通信，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。对POSIX以及系统V消息队列都有阐述，对Linux环境下的程序开发有极大的启发意义</li>
</ol>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/消息队列/" data-id="ciqarm44z0013h8qyunwqrd9h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-共享内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/共享内存/" class="article-date">
  <time datetime="2016-07-02T04:09:19.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/共享内存/">共享内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。linux发行版本如Redhat 8.0支持mmap()系统调用及系统V共享内存，但还没实现Posix共享内存，本文将主要介绍mmap()系统调用及系统V共享内存API的原理及应用。</p>
<h2 id="一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"><a href="#一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面" class="headerlink" title="一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"></a>一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</h2><p>1、page cache及swap cache中页面的区分：一个被访问文件的物理页面都驻留在page cache或swap cache中，一个页面的所有信息由struct page来描述。struct page中有一个域为指针mapping ，它指向一个struct address_space类型结构。page cache或swap cache中的所有页面就是根据address_space结构以及一个偏移量来区分的。</p>
<p>2、文件与address_space结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个struct inode结构，其中的i_mapping域指向一个address_space结构。这样，一个文件就对应一个address_space结构，一个address_space与一个偏移量能够确定一个page cache 或swap cache中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。</p>
<p>3、进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。</p>
<p>4、对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。<br>注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新。</p>
<p>5、所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br> 注：一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区上。</p>
<p>上面涉及到了一些数据结构，围绕数据结构理解问题会容易一些。</p>
<h3 id="二、mmap-及其相关系统调用"><a href="#二、mmap-及其相关系统调用" class="headerlink" title="二、mmap()及其相关系统调用"></a>二、mmap()及其相关系统调用</h3><p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</p>
<p>注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
<h5 id="mmap-系统调用形式如下："><a href="#mmap-系统调用形式如下：" class="headerlink" title="mmap()系统调用形式如下："></a>mmap()系统调用形式如下：</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* mmap ( <span class="type">void</span> * <span class="keyword">addr</span> , size_t len , <span class="type">int</span> prot , <span class="type">int</span> flags , <span class="type">int</span> fd , off_t offset )</span><br></pre></td></tr></table></figure>
<p> 参数fd为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起。prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。flags由以下几个常值指定：MAP_SHARED , MAP_PRIVATE , MAP_FIXED，其中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。offset参数一般设为0，表示从文件头开始映射。参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。这里不再详细介绍mmap()的参数，读者可参考mmap()手册页获得进一步的信息。</p>
<h5 id="系统调用mmap-用于共享内存的两种方式："><a href="#系统调用mmap-用于共享内存的两种方式：" class="headerlink" title="系统调用mmap()用于共享内存的两种方式："></a>系统调用mmap()用于共享内存的两种方式：</h5><p> （1）使用普通文件提供的内存映射：适用于任何进程之间； 此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="built_in">name</span>, <span class="built_in">flag</span>, mode);</span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<p>ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，我们将在范例中进行具体说明。</p>
<p>（2）使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间； 由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。<br> 对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可，参见范例2。</p>
<h5 id="系统调用munmap"><a href="#系统调用munmap" class="headerlink" title="系统调用munmap()"></a>系统调用munmap()</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> munmap( <span class="type">void</span> * <span class="keyword">addr</span>, size_t len )</span><br></pre></td></tr></table></figure>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<h5 id="系统调用msync"><a href="#系统调用msync" class="headerlink" title="系统调用msync()"></a>系统调用msync()</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> msync ( <span class="type">void</span> * <span class="keyword">addr</span> , size_t len, <span class="type">int</span> flags)</span><br></pre></td></tr></table></figure>
<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="三、mmap-范例"><a href="#三、mmap-范例" class="headerlink" title="三、mmap()范例"></a>三、mmap()范例</h3><p>下面将给出使用mmap()的两个范例：范例1给出两个进程通过映射普通文件实现共享内存通信；范例2给出父子进程通过匿名映射实现共享内存。系统调用mmap()有许多有趣的地方，下面是通过mmap（）映射普通文件实现进程间的通信的范例，我们通过该范例来说明mmap()实现共享内存的特点及注意事项。</p>
<h4 id="范例1：两个进程通过映射普通文件实现共享内存通信"><a href="#范例1：两个进程通过映射普通文件实现共享内存通信" class="headerlink" title="范例1：两个进程通过映射普通文件实现共享内存通信"></a>范例1：两个进程通过映射普通文件实现共享内存通信</h4><p>范例1包含两个子程序：map_normalfile1.c及map_normalfile2.c。编译两个程序，可执行文件分别为map_normalfile1及map_normalfile2。两个程序通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。map_normalfile2试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。map_normalfile1把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。</p>
<p>下面是两个程序代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------map_normalfile1.c-----------*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">  fd=open(argv[<span class="number">1</span>],O_CREAT|O_RDWR|O_TRUNC,<span class="number">00777</span>);</span><br><span class="line">  lseek(fd,<span class="keyword">sizeof</span>(people)*<span class="number">5</span>-<span class="number">1</span>,SEEK_SET);</span><br><span class="line">  write(fd,<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  p_map = (people*) mmap( <span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">        MAP_SHARED,fd,<span class="number">0</span> );</span><br><span class="line">  close( fd );</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>( ( *(p_map+i) ).name, &amp;temp,<span class="number">2</span> );</span><br><span class="line">    ( *(p_map+i) ).age = <span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" initialize over \n "</span>)；</span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line">  munmap( p_map, <span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok \n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------map_normalfile2.c-----------*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)  <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  fd=open( argv[<span class="number">1</span>],O_CREAT|O_RDWR,<span class="number">00777</span> );</span><br><span class="line">  p_map = (people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"name: %s age %d;\n"</span>,(*(p_map+i)).name, (*(p_map+i)).age );</span><br><span class="line">  &#125;</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>map_normalfile1.c首先定义了一个people数据结构，（在这里采用数据结构的方式是因为，共享内存区的数据往往是有固定格式的，这由通信的各个进程决定，采用结构的方式有普遍代表性）。map_normfile1首先打开或创建一个文件，并把文件的长度设置为5个people结构大小。然后从mmap()的返回地址开始，设置了10个people结构。然后，进程睡眠10秒钟，等待其他进程映射同一个文件，最后解除映射。</p>
<p>map_normfile2.c只是简单的映射一个文件，并以people数据结构的格式从mmap()返回的地址处读取10个people结构，并输出读取的值，然后解除映射。</p>
<p>分别把两个程序编译成可执行文件map_normalfile1和map_normalfile2后，在一个终端上先运行./map_normalfile2 /tmp/test_shm，程序输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initialize <span class="keyword">over</span></span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<p>在map_normalfile1输出initialize over 之后，输出umap ok之前，在另一个终端上运行map_normalfile2 /tmp/test_shm，将会产生如下输出(为了节省空间，输出结果为稍作整理后的结果)：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>: g	age <span class="number">25</span>;	<span class="attribute">name</span>: h	age <span class="number">26</span>;	<span class="attribute">name</span>: I	age <span class="number">27</span>;	<span class="attribute">name</span>: j	age <span class="number">28</span>;	<span class="attribute">name</span>: k	age <span class="number">29</span>;</span><br></pre></td></tr></table></figure></p>
<p>在map_normalfile1 输出umap ok后，运行map_normalfile2则输出如下结果：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="从程序的运行结果中可以得出的结论"><a href="#从程序的运行结果中可以得出的结论" class="headerlink" title="从程序的运行结果中可以得出的结论"></a>从程序的运行结果中可以得出的结论</h5><p>1、最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文件的大小；</p>
<p>2、可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不完全受限于文件大小。打开文件被截短为5个people结构大小，而在map_normalfile1中初始化了10个people数据结构，在恰当时候（map_normalfile1输出initialize over 之后，输出umap ok之前）调用map_normalfile2会发现map_normalfile2将输出全部10个people结构的值，后面将给出详细讨论。<br> 注：在linux中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从mmap()返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。</p>
<p>3、文件一旦被映射后，调用mmap()的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对mmap()返回地址空间的操作只在内存中有意义，只有在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件，所写内容仍然不能超过文件的大小。</p>
<h4 id="范例2：父子进程通过匿名映射实现共享内存"><a href="#范例2：父子进程通过匿名映射实现共享内存" class="headerlink" title="范例2：父子进程通过匿名映射实现共享内存"></a>范例2：父子进程通过匿名映射实现共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line">  p_map=(people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED|MAP_ANONYMOUS,-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child read: the %d people's age is %d\n"</span>,i+<span class="number">1</span>,(*(p_map+i)).age);</span><br><span class="line">    (*p_map).age = <span class="number">100</span>;</span><br><span class="line">    munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>); <span class="comment">//实际上，进程终止时，会自动解除映射。</span></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((*(p_map+i)).name, &amp;temp,<span class="number">2</span>);</span><br><span class="line">    (*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"parent read: the first people,s age is %d\n"</span>,(*p_map).age );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"umap\n"</span>);</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察程序的输出结果，体会父子进程匿名共享内存：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">1</span> people's age <span class="keyword">is</span> <span class="number">20</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">2</span> people's age <span class="keyword">is</span> <span class="number">21</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">3</span> people's age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">4</span> people's age <span class="keyword">is</span> <span class="number">23</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">5</span> people's age <span class="keyword">is</span> <span class="number">24</span></span><br><span class="line">parent <span class="command">read</span>: <span class="keyword">the</span> <span class="keyword">first</span> people,s age <span class="keyword">is</span> <span class="number">100</span></span><br><span class="line">umap</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure></p>
<h3 id="四、对mmap-返回地址的访问"><a href="#四、对mmap-返回地址的访问" class="headerlink" title="四、对mmap()返回地址的访问"></a>四、对mmap()返回地址的访问</h3><p>前面对范例运行结构的讨论中已经提到，linux采用的是页式管理机制。对于用mmap()映射普通文件来说，进程会在自己的地址空间新增一块空间，空间大小由mmap()的len参数指定，注意，进程并不一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面个数决定了进程从mmap()返回的地址开始，能够有效访问的地址空间大小。超过这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如下图示说明：<br><img src="/pictures/Linux/进程间通信/共享内存-mmap地址映射.png" alt=""><br>注意：文件被映射部分而不是整个文件决定了进程能够访问的空间大小，另外，如果指定文件的偏移部分，一定要注意为页面大小的整数倍。下面是对进程映射地址空间的访问范例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd,i;</span><br><span class="line">	<span class="keyword">int</span> pagesize,offset;</span><br><span class="line">	people *p_map;</span><br><span class="line"></span><br><span class="line">	pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pagesize is %d\n"</span>,pagesize);</span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_CREAT|O_RDWR|O_TRUNC,<span class="number">00777</span>);</span><br><span class="line">	lseek(fd,pagesize*<span class="number">2</span>-<span class="number">100</span>,SEEK_SET);</span><br><span class="line">	write(fd,<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line">	offset = <span class="number">0</span>;	<span class="comment">//此处offset = 0编译成版本1；offset = pagesize编译成版本2</span></span><br><span class="line">	p_map = (people*)mmap(<span class="literal">NULL</span>,pagesize*<span class="number">3</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,offset);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i-<span class="number">2</span>)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d over\n"</span>,i);</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i-<span class="number">1</span>)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d edge over, now begin to access page %d\n"</span>,i, i+<span class="number">1</span>);</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d over\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如程序中所注释的那样，把程序编译成两个版本，两个版本主要体现在文件被映射部分的大小不同。文件的大小介于一个页面与两个页面之间（大小为：pagesize<em>2-99），版本1的被映射部分是整个文件，版本2的文件被映射部分是文件大小减去一个页面后的剩余部分，不到一个页面大小(大小为：pagesize-99)。程序中试图访问每一个页面边界，两个版本都试图在进程空间中映射pagesize</em>3的字节数。</p>
<h4 id="版本1的输出结果如下："><a href="#版本1的输出结果如下：" class="headerlink" title="版本1的输出结果如下："></a>版本1的输出结果如下：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pagesize is 4096</span><br><span class="line">access page 1 over</span><br><span class="line">access page 1 edge over, now <span class="operator"><span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">2</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> <span class="keyword">over</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> <span class="keyword">over</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> edge <span class="keyword">over</span>, <span class="keyword">now</span> <span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">3</span></span><br><span class="line">Bus <span class="keyword">error</span>		//被映射文件在进程空间中覆盖了两个页面，此时，进程试图访问第三个页面</span></span><br></pre></td></tr></table></figure>
<h4 id="版本2的输出结果如下："><a href="#版本2的输出结果如下：" class="headerlink" title="版本2的输出结果如下："></a>版本2的输出结果如下：</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pagesize <span class="keyword">is</span> <span class="number">4096</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">1</span> over</span><br><span class="line"><span class="keyword">access</span> page <span class="number">1</span> edge over, now <span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">2</span></span><br><span class="line"><span class="keyword">Bus</span> error		//被映射文件在进程空间中覆盖了一个页面，此时，进程试图访问第二个页面</span><br></pre></td></tr></table></figure>
<p>结论：采用系统调用mmap()实现进程间通信是很方便的，在应用层上接口非常简洁。内部实现机制区涉及到了linux存储管理以及文件系统等方面的内容，可以参考一下相关重要数据结构来加深理解。在本专题的后面部分，将介绍系统v共享内存的实现。</p>
<h3 id="系统V共享内存原理"><a href="#系统V共享内存原理" class="headerlink" title="系统V共享内存原理"></a>系统V共享内存原理</h3><p>系统调用mmap()通过映射一个普通文件实现共享内存。系统V则是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统shm中的一个文件（这是通过shmid_kernel结构联系起来的），后面还将阐述。<br>进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过shmget获得或创建一个IPC共享内存区域，并返回相应的标识符。内核在保证shmget获得或创建一个共享内存区，初始化该共享内存区相应的shmid_kernel结构注同时，还将在特殊文件系统shm中，创建并打开一个同名文件，并在内存中建立起该文件的相应dentry及inode结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用shmget完成的。</p>
<p>注：每一个共享内存区都有一个控制结构struct shmid_kernel，shmid_kernel是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁，定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> shmid_kernel <span class="comment">/* private to the kernel */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> kern_ipc_perm	shm_perm;</span><br><span class="line">	<span class="keyword">struct</span> file *		shm_file;</span><br><span class="line">	<span class="keyword">int</span>			id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_nattch;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_segsz;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_atim;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_dtim;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_ctim;</span><br><span class="line">	<span class="keyword">pid_t</span>			shm_cprid;</span><br><span class="line">	<span class="keyword">pid_t</span>			shm_lprid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构中最重要的一个域应该是shm_file，它存储了将被映射文件的地址。每个共享内存区对象都对应特殊文件系统shm中的一个文件，一般情况下，特殊文件系统shm中的文件是不能用read()、write()等方法访问的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可直接采用访问内存的方式对其访问。</p>
<p>这里我们采用下图表给出与系统V共享内存相关数据结构：<br><img src="/pictures/Linux/进程间通信/共享内存-系统V相关数据结构.png" alt=""></p>
<p>正如消息队列和信号灯一样，内核通过数据结构struct ipc_ids shm_ids维护系统中的所有共享内存区域。上图中的shm_ids.entries变量指向一个ipc_id结构数组，而每个ipc_id结构数组中有个指向kern_ipc_perm结构的指针。到这里读者应该很熟悉了，对于系统V共享内存区来说，kern_ipc_perm的宿主是shmid_kernel结构，shmid_kernel是用来描述一个共享内存区域的，这样内核就能够控制系统中所有的共享区域。同时，在shmid_kernel结构的file类型指针shm_file指向文件系统shm中相应的文件，这样，共享内存区域就与shm文件系统中的文件对应起来。</p>
<p>在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用shmat()完成此项功能。由于在调用shmget()时，已经创建了文件系统shm中的一个同名文件与共享内存区域相对应，因此，调用shmat()的过程相当于映射文件系统shm中的同名文件过程，原理与mmap()大同小异。</p>
<h3 id="系统V共享内存API"><a href="#系统V共享内存API" class="headerlink" title="系统V共享内存API"></a>系统V共享内存API</h3><p>对于系统V共享内存，主要有以下几个API：shmget()、shmat()、shmdt()及shmctl()。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>shmget（）用来获得共享内存区域的ID，如果不存在指定的共享区域就创建相应的区域。shmat()把共享内存区域映射到调用进程的地址空间中去，这样，进程就可以方便地对共享区域进行访问操作。shmdt()调用用来解除进程对共享内存区域的映射。shmctl实现对共享内存区域的控制操作。这里我们不对这些系统调用作具体的介绍，读者可参考相应的手册页面，后面的范例中将给出它们的调用方法。</p>
<p>注：shmget的内部实现包含了许多重要的系统V共享内存机制；shmat在把共享内存区域映射到进程空间时，并不真正改变进程的页表。当进程第一次访问内存映射区域访问时，会因为没有物理页表的分配而导致一个缺页异常，然后内核再根据相应的存储管理机制为共享内存映射区域分配相应的页表。</p>
<h3 id="系统V共享内存限制"><a href="#系统V共享内存限制" class="headerlink" title="系统V共享内存限制"></a>系统V共享内存限制</h3><p>在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如一个共享内存区的最大字节数shmmax，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做。</p>
<h3 id="系统V共享内存范例"><a href="#系统V共享内存范例" class="headerlink" title="系统V共享内存范例"></a>系统V共享内存范例</h3><p>本部分将给出系统V共享内存API的使用方法，并对比分析系统V共享内存机制与mmap()映射普通文件实现共享内存之间的差异，首先给出两个进程通过系统V共享内存通信的范例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** testwrite.c *******/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> shm_id,i;</span><br><span class="line">	<span class="keyword">key_t</span> key;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	people *p_map;</span><br><span class="line">	<span class="keyword">char</span>* name = <span class="string">"/dev/shm/myshm2"</span>;</span><br><span class="line">	key = ftok(name,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key==-<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">	shm_id=shmget(key,<span class="number">4096</span>,IPC_CREAT);</span><br><span class="line">	<span class="keyword">if</span>(shm_id==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p_map=(people*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	temp=<span class="string">'a'</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>((*(p_map+i)).name,&amp;temp,<span class="number">1</span>);</span><br><span class="line">		(*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shmdt(p_map)==-<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">" detach error "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********** testread.c ************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> shm_id,i;</span><br><span class="line">	<span class="keyword">key_t</span> key;</span><br><span class="line">	people *p_map;</span><br><span class="line">	<span class="keyword">char</span>* name = <span class="string">"/dev/shm/myshm2"</span>;</span><br><span class="line">	key = ftok(name,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">	shm_id = shmget(key,<span class="number">4096</span>,IPC_CREAT);</span><br><span class="line">	<span class="keyword">if</span>(shm_id == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p_map = (people*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"name:%s\n"</span>,(*(p_map+i)).name );</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"age %d\n"</span>,(*(p_map+i)).age );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shmdt(p_map) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">" detach error "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testwrite.c创建一个系统V共享内存区，并在其中写入格式化数据；testread.c访问同一个系统V共享内存区，读出其中的格式化数据。分别把两个程序编译为testwrite及testread，先后执行./testwrite及./testread 则./testread输出结果如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>: g	age <span class="number">25</span>;	<span class="attribute">name</span>: h	age <span class="number">26</span>;	<span class="attribute">name</span>: I	age <span class="number">27</span>;	<span class="attribute">name</span>: j	age <span class="number">28</span>;	<span class="attribute">name</span>: k	age <span class="number">29</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过对试验结果分析，对比系统V与mmap()映射普通文件实现共享内存通信，可以得出如下结论：<br>1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。 注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。</p>
<p>2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。</p>
<p>3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。 注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。</p>
<p>共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统shm中的。通过shmget可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过shmat将这个内存区映射到本进程的虚拟地址空间。</p>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/共享内存/" data-id="ciqarm4630026h8qyflhid1j2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之auto和decltype/">C++11常规特性之auto和decltype</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/">C++11常规特性之统一初始化和初始化器列表</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之右值引用和move语义/">C++11常规特性之右值引用和move语义</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之lambda/">C++11常规特性之lambda</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之noexcept/">C++11常规特性之noexcept</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>