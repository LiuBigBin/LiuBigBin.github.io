<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-管道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/管道/" class="article-date">
  <time datetime="2016-07-02T02:33:05.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/管道/">管道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="管道及有名管道"><a href="#管道及有名管道" class="headerlink" title="管道及有名管道"></a>管道及有名管道</h1><p>管道和有名管道是最早的进程间通信机制之一，管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<h2 id="管道概述及相关API应用"><a href="#管道概述及相关API应用" class="headerlink" title="管道概述及相关API应用"></a>管道概述及相关API应用</h2><h4 id="管道相关的关键概念"><a href="#管道相关的关键概念" class="headerlink" title="管道相关的关键概念"></a>管道相关的关键概念</h4><p>管道是Linux支持的最初Unix IPC形式之一，具有以下特点：</p>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><br><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；</li><br><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li><br><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>

<h4 id="管道的创建："><a href="#管道的创建：" class="headerlink" title="管道的创建："></a>管道的创建：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。</p>
<h4 id="管道的读写规则："><a href="#管道的读写规则：" class="headerlink" title="管道的读写规则："></a>管道的读写规则：</h4><p>管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的I/O函数都可以用于管道，如close、read、write等等。</p>
<p>从管道中读取数据：</p>
<li>如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0；</li><br><li>当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的数据字节数，如果请求的字节数目不大于PIPE_BUF，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。注：（PIPE_BUF在include/linux/limits.h中定义，不同的内核版本可能会有所不同。Posix.1要求PIPE_BUF至少为512字节，red hat 7.2中为4096）。</li>

<p>关于管道的读规则验证：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> readtest.c <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int pipe_fd[2];</span><br><span class="line">	pid_t pid;</span><br><span class="line">	char r_buf[100];</span><br><span class="line">	char w_buf[4];</span><br><span class="line">	char<span class="keyword">*</span> p_wbuf;</span><br><span class="line">	int r_num;</span><br><span class="line">	int cmd;</span><br><span class="line"></span><br><span class="line">	memset(r_buf,0,sizeof(r_buf));</span><br><span class="line">	memset(w_buf,0,sizeof(r_buf));</span><br><span class="line">	p_wbuf=w_buf;</span><br><span class="line">	if(pipe(pipe_fd)<span class="variable">&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf("pipe create error\n");</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if((pid=fork())==0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf("\n");</span><br><span class="line">		close(pipe_fd[1]);</span><br><span class="line">		sleep(3);//确保父进程关闭写端</span><br><span class="line">	    r_num=read(pipe_fd[0],r_buf,100);</span><br><span class="line">printf(	"read num is %d   the data read from the pipe is %d\n",r_num,atoi(r_buf));</span><br><span class="line"></span><br><span class="line">		close(pipe_fd[0]);</span><br><span class="line">		exit();</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;</span>0)</span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[0]);//read</span><br><span class="line">	strcpy(w_buf,<span class="string">"111"</span>);</span><br><span class="line">	if(write(pipe_fd[1],w_buf,4)!=-1)</span><br><span class="line">		printf(<span class="string">"parent write over\n"</span>);</span><br><span class="line">	close(pipe_fd[1]);//write</span><br><span class="line">		printf(<span class="string">"parent close fd[1] over\n"</span>);</span><br><span class="line">	sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> /<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> 程序输出结果：</span><br><span class="line"> <span class="keyword">*</span> parent write over</span><br><span class="line"> <span class="keyword">*</span> parent close fd[1] over</span><br><span class="line"> <span class="keyword">*</span> read num is 4   the data read from the pipe is 111</span><br><span class="line"> <span class="keyword">*</span> 附加结论：</span><br><span class="line"> <span class="keyword">*</span> 管道写端关闭后，写入的数据将一直存在，直到读出为止.</span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<p>向管道中写入数据：</p>
<li>向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。<br>注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。</li>

<p>对管道的写规则的验证1：写端对读端存在的依赖性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span>* w_buf;</span><br><span class="line">	<span class="keyword">int</span> writenum;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	sleep(<span class="number">1</span>);  <span class="comment">//等待子进程完成关闭读端的操作</span></span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);<span class="comment">//write</span></span><br><span class="line">	w_buf=<span class="string">"111"</span>;</span><br><span class="line">	<span class="keyword">if</span>((writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">4</span>))==-<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"write to pipe error\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the bytes write to pipe is %d \n"</span>, writenum);</span><br><span class="line"></span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则输出结果为： Broken pipe,原因就是该管道以及它的所有fork()产物的读端都已经被关闭。如果在父进程中保留读端，即在写完pipe后，再关闭父进程的读端，也会正常写入pipe，读者可自己验证一下该结论。因此，在向管道写入数据时，至少应该存在某一个进程，其中管道读端没有被关闭，否则就会出现上述错误（管道断裂,进程收到了SIGPIPE信号，默认动作是进程终止）</p>
<p>对管道的写规则的验证2：linux不保证写管道的原子性验证<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> writenum;</span><br><span class="line">	<span class="keyword">int</span> rnum;</span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		rnum=read(pipe_fd[<span class="number">0</span>],r_buf,<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child: readnum is %d\n"</span>,rnum);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);<span class="comment">//write</span></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>((writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">1024</span>))==-<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"write to pipe error\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the bytes write to pipe is %d \n"</span>, writenum);</span><br><span class="line">	writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">4096</span>);</span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">120</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>结论：</p>
<p>写入数目小于4096时写入是非原子的！<br>如果把父进程中的两次写入字节数都改为5000，则很容易得出下面结论：<br>写入管道的数据量大于4096字节时，缓冲区的空闲空间将被写入数据（补齐），直到写完所有数据为止，如果没有进程读数据，则一直阻塞。</p>
<h3 id="管道应用实例："><a href="#管道应用实例：" class="headerlink" title="管道应用实例："></a>管道应用实例：</h3><h4 id="实例一：用于shell"><a href="#实例一：用于shell" class="headerlink" title="实例一：用于shell"></a>实例一：用于shell</h4><p>管道可用于输入输出重定向，它将一个命令的输出直接定向到另一个命令的输入。比如，当在某个shell程序（Bourne shell或C shell等）键入who│wc -l后，相应shell程序将创建who以及wc两个进程和这两个进程间的管道。考虑下面的命令行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$kill -l 运行结果见 附一。</span><br><span class="line"></span><br><span class="line">$kill -l | grep SIGRTMIN 运行结果如下：</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>) SIGPWR	<span class="number">31</span>) SIGSYS	<span class="number">32</span>) SIGRTMIN	<span class="number">33</span>) SIGRTMIN+<span class="number">1</span></span><br><span class="line"><span class="number">34</span>) SIGRTMIN+<span class="number">2</span>	<span class="number">35</span>) SIGRTMIN+<span class="number">3</span>	<span class="number">36</span>) SIGRTMIN+<span class="number">4</span>	<span class="number">37</span>) SIGRTMIN+<span class="number">5</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">6</span>	<span class="number">39</span>) SIGRTMIN+<span class="number">7</span>	<span class="number">40</span>) SIGRTMIN+<span class="number">8</span>	<span class="number">41</span>) SIGRTMIN+<span class="number">9</span></span><br><span class="line"><span class="number">42</span>) SIGRTMIN+<span class="number">10</span>	<span class="number">43</span>) SIGRTMIN+<span class="number">11</span>	<span class="number">44</span>) SIGRTMIN+<span class="number">12</span>	<span class="number">45</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">46</span>) SIGRTMIN+<span class="number">14</span>	<span class="number">47</span>) SIGRTMIN+<span class="number">15</span>	<span class="number">48</span>) SIGRTMAX-<span class="number">15</span>	<span class="number">49</span>) SIGRTMAX-<span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实例二：用于具有亲缘关系的进程间通信"><a href="#实例二：用于具有亲缘关系的进程间通信" class="headerlink" title="实例二：用于具有亲缘关系的进程间通信"></a>实例二：用于具有亲缘关系的进程间通信</h4><p>下面例子给出了管道的具体应用，父进程通过管道发送一些命令给子进程，子进程解析命令，并根据命令作相应处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span>** w_buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">int</span> childexit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	<span class="comment">//子进程：解析从管道中获取的命令，并作相应的处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(!childexit)</span><br><span class="line">		&#123;</span><br><span class="line">			read(pipe_fd[<span class="number">0</span>],r_buf,<span class="number">4</span>);</span><br><span class="line">			cmd=atoi(r_buf);</span><br><span class="line">			<span class="keyword">if</span>(cmd==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: receive command from parent over\n now child process exit\n"</span>);</span><br><span class="line">				childexit=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		       <span class="keyword">else</span> <span class="keyword">if</span>(handle_cmd(cmd)!=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="comment">//parent: send commands to child</span></span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">	w_buf[<span class="number">0</span>]=<span class="string">"003"</span>;</span><br><span class="line">	w_buf[<span class="number">1</span>]=<span class="string">"005"</span>;</span><br><span class="line">	w_buf[<span class="number">2</span>]=<span class="string">"777"</span>;</span><br><span class="line">	w_buf[<span class="number">3</span>]=<span class="string">"000"</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		write(pipe_fd[<span class="number">1</span>],w_buf[i],<span class="number">4</span>);</span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是子进程的命令处理函数（特定于应用）：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_cmd</span><span class="params">(<span class="keyword">int</span> cmd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((cmd&lt;<span class="number">0</span>)||(cmd&gt;<span class="number">256</span>))</span><br><span class="line"><span class="comment">//suppose child only support 256 commands</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child: invalid command \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: the cmd from parent is %d\n"</span>, cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h4><p>管道的主要局限性正体现在它的特点上：</p>
<li>只支持单向数据流；</li><br><li>只能用于具有亲缘关系的进程之间；</li><br><li>没有名字；</li><br><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><br><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>

<h2 id="有名管道概述及相关API应用"><a href="#有名管道概述及相关API应用" class="headerlink" title="有名管道概述及相关API应用"></a>有名管道概述及相关API应用</h2><h3 id="有名管道相关的关键概念"><a href="#有名管道相关的关键概念" class="headerlink" title="有名管道相关的关键概念"></a>有名管道相关的关键概念</h3><p>管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
<h3 id="有名管道的创建"><a href="#有名管道的创建" class="headerlink" title="有名管道的创建"></a>有名管道的创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_t mode)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数的第一个参数是一个普通的路径名，也就是创建后FIFO的名字。第二个参数与打开普通文件的open()函数中的mode 参数相同。 如果mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开FIFO的函数就可以了。一般文件的I/O函数都可以用于FIFO，如close、read、write等等。</p>
<h3 id="有名管道的打开规则"><a href="#有名管道的打开规则" class="headerlink" title="有名管道的打开规则"></a>有名管道的打开规则</h3><p>有名管道比管道多了一个打开操作：open。</p>
<p>FIFO的打开规则：</p>
<p>如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。</p>
<p>如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。</p>
<p>对打开规则的验证：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r_rd;</span><br><span class="line">	<span class="keyword">int</span> w_fd;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cannot create fifoserver\n"</span>);</span><br><span class="line">	handle_client(FIFO_SERVER);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client</span><span class="params">(<span class="keyword">char</span>* arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret=w_open(arg);</span><br><span class="line"><span class="keyword">switch</span>(ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"open %s error\n"</span>,arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"no process has the fifo open for reading\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"something wrong with open the fifo except for ENXIO"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"open server ok\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"w_no_r return ----\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;		</span><br><span class="line">unlink(FIFO_SERVER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w_open</span><span class="params">(<span class="keyword">char</span>*arg)</span></span><br><span class="line"><span class="comment">//0  open error for no reading</span></span><br><span class="line"><span class="comment">//-1 open error for other reasons</span></span><br><span class="line"><span class="comment">//1  open ok</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(open(arg,O_WRONLY|O_NONBLOCK,<span class="number">0</span>)==-<span class="number">1</span>)</span><br><span class="line">	&#123;	<span class="keyword">if</span>(errno==ENXIO)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="有名管道的读写规则"><a href="#有名管道的读写规则" class="headerlink" title="有名管道的读写规则"></a>有名管道的读写规则</h3><p>从FIFO中读取数据：</p>
<p>约定：如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。</p>
<li>如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。</li><br><li>对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。</li><br><li>读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。</li><br><li>如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。</li>

<p>注：如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。</p>
<p>向FIFO中写入数据：</p>
<p>约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。</p>
<p>对于设置了阻塞标志的写操作：</p>
<li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。</li><br><li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。</li>

<p>对于没有设置阻塞标志的写操作：</p>
<li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。</li><br><li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；</li>

<p>对FIFO读写规则的验证：</p>
<p>下面提供了两个对FIFO的读写程序，适当调节程序中的很少地方或者程序的命令行参数就可以对各种FIFO读写规则进行验证。</p>
<h5 id="程序1：写FIFO的程序"><a href="#程序1：写FIFO的程序" class="headerlink" title="程序1：写FIFO的程序"></a>程序1：写FIFO的程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line"><span class="comment">//参数为即将写入的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> real_wnum;</span><br><span class="line">	<span class="built_in">memset</span>(w_buf,<span class="number">0</span>,<span class="number">4096</span>*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cannot create fifoserver\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(errno==ENXIO)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"open error; no reading process\n"</span>);</span><br><span class="line"></span><br><span class="line">     	fd=open(FIFO_SERVER,O_WRONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置非阻塞标志</span></span><br><span class="line">	<span class="comment">//fd=open(FIFO_SERVER,O_WRONLY,0);</span></span><br><span class="line">	<span class="comment">//设置阻塞标志</span></span><br><span class="line">	real_wnum=write(fd,w_buf,<span class="number">2048</span>);</span><br><span class="line">	<span class="keyword">if</span>(real_wnum==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"write to fifo error; try later\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"real write num is %d\n"</span>,real_wnum);</span><br><span class="line">	real_wnum=write(fd,w_buf,<span class="number">5000</span>);</span><br><span class="line">	<span class="comment">//5000用于测试写入字节大于4096时的非原子性</span></span><br><span class="line">	<span class="comment">//real_wnum=write(fd,w_buf,4096);</span></span><br><span class="line">	<span class="comment">//4096用于测试写入字节不大于4096时的原子性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(real_wnum==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"try later\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数"><a href="#程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数" class="headerlink" title="程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数"></a>程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span>  fd;</span><br><span class="line">	<span class="keyword">int</span>  r_size;</span><br><span class="line">	<span class="keyword">int</span>  ret_size;</span><br><span class="line">	r_size=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"requred real read bytes %d\n"</span>,r_size);</span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	fd=open(FIFO_SERVER,O_RDONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//fd=open(FIFO_SERVER,O_RDONLY,0);</span></span><br><span class="line">	<span class="comment">//在此处可以把读程序编译成两个不同版本：阻塞版本及非阻塞版本</span></span><br><span class="line">	<span class="keyword">if</span>(fd==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"open %s for read error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">		ret_size=read(fd,r_buf,r_size);</span><br><span class="line">		<span class="keyword">if</span>(ret_size==-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"no data avlaible\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"real read bytes %d\n"</span>,ret_size);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pause();</span><br><span class="line">	unlink(FIFO_SERVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序应用说明：</p>
<p>把读程序编译成两个不同版本：</p>
<li>阻塞读版本:br</li><br><li>以及非阻塞读版本nbr</li>

<p>把写程序编译成两个四个版本：</p>
<li>非阻塞且请求写的字节数大于PIPE_BUF版本：nbwg</li><br><li>非阻塞且请求写的字节数不大于PIPE_BUF版本：版本nbw</li><br><li>阻塞且请求写的字节数大于PIPE_BUF版本：bwg</li><br><li>阻塞且请求写的字节数不大于PIPE_BUF版本：版本bw</li>


<p>下面将使用br、nbr、w代替相应程序中的阻塞读、非阻塞读</p>
<p>验证阻塞写操作：<br>1.当请求写入的数据量大于PIPE_BUF时的非原子性：<br>      nbr 1000<br>      bwg</p>
<p>2.当请求写入的数据量不大于PIPE_BUF时的原子性：<br>      nbr 1000<br>      bw</p>
<p>验证非阻塞写操作：<br>1.当请求写入的数据量大于PIPE_BUF时的非原子性：<br>      nbr 1000<br>      nbwg</p>
<p>2.请求写入的数据量不大于PIPE_BUF时的原子性：<br>      nbr 1000<br>      nbw</p>
<p>不管写打开的阻塞标志是否设置，在请求写入的字节数大于4096时，都不保证写入的原子性。但二者有本质区别：</p>
<p>对于阻塞写来说，写操作在写满FIFO的空闲区域后，会一直等待，直到写完所有数据为止，请求写入的数据最终都会写入FIFO；</p>
<p>而非阻塞写则在写满FIFO的空闲区域后，就返回(实际写入的字节数)，所以有些数据最终不能够写入。</p>
<p>对于读操作的验证则比较简单，不再讨论。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>管道常用于两个方面：<br>（1）在shell中时常会用到管道（作为输入输入的重定向），在这种应用方式下，管道的创建对于用户来说是透明的；<br>（2）用于具有亲缘关系的进程间通信，用户自己创建管道，并完成读写操作。</p>
<p>FIFO可以说是管道的推广，克服了管道无名字的限制，使得无亲缘关系的进程同样可以采用先进先出的通信机制进行通信。</p>
<p>管道和FIFO的数据是字节流，应用程序之间必须事先确定特定的传输”协议”，采用传播具有特定意义的消息。</p>
<p>要灵活应用管道及FIFO，理解它们的读写规则是关键。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/管道/" data-id="ciq4lsqhd000ktsqyswjf2a24" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP-Nagel算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/TCP-Nagel算法/" class="article-date">
  <time datetime="2016-05-10T06:24:13.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/TCP-Nagel算法/"> TCP Nagel算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>Nagel算法</li>
</ol>
<p>TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p>
  <font color="blue">Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</font>

<p>Nagle算法的规则（可参考tcp_output.c文件里tcp_nagle_check函数注释）：</p>
<pre><code>（1）如果包长度达到MSS，则允许发送；

（2）如果该包含有FIN，则允许发送；

（3）设置了TCP_NODELAY选项，则允许发送；

（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
</code></pre><p>Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低。</p>
<p>Nagle算法是silly window syndrome(SWS)预防算法的一个半集。SWS算法预防发送少量的数据，Nagle算法是其在发送方的实现，而接收方要做的时不要通告缓冲空间的很小增长，不通知小窗口，除非缓冲区空间有显著的增长。这里显著的增长定义为完全大小的段（MSS）或增长到大于最大窗口的一半。</p>
<font color="red">注意：BSD的实现是允许在空闲链接上发送大的写操作剩下的最后的小段，也就是说，当超过1个MSS数据发送时，内核先依次发送完n个MSS的数据包，然后再发送尾部的小数据包，其间不再延时等待。（假设网络不阻塞且接收窗口足够大）</font>


<p>举个例子，比如之前的blog中的实验，一开始client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\r\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。</p>
<p>这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个TCP确认延迟机制 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么’\r\n’（B块）总是在A块之后40ms才发出。<br>当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。</p>
<h4 id="TCP-NODELAY-选项"><a href="#TCP-NODELAY-选项" class="headerlink" title="TCP_NODELAY 选项"></a>TCP_NODELAY 选项</h4><p>默认情况下，发送数据采用Negale 算法。这样虽然提高了网络吞吐量，但是实时性却降低了，在一些交互性很强的应用程序来说是不允许的，使用TCP_NODELAY选项可以禁止Negale 算法。</p>
<p>此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了Negale 算法，但网络的传输仍然受到TCP确认延迟机制的影响。</p>
<h4 id="TCP-CORK-选项"><a href="#TCP-CORK-选项" class="headerlink" title="TCP_CORK 选项"></a>TCP_CORK 选项</h4><p>所谓的CORK就是塞子的意思，形象地理解就是用CORK将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽力把小数据包拼接成一个大的数据包（一个MTU）再发送出去，当然若一定时间后（一般为200ms，该值尚待确认），内核仍然没有组合成一个MTU时也必须发送现有的数据（不可能让数据一直等待吧）。</p>
<p>然而，TCP_CORK的实现可能并不像你想象的那么完美，CORK并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到MTU的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包（努力接近MTU）的话，内核就会无条件发送。也就是说若应用层程序发送小包数据的间隔不够短时，TCP_CORK就没有一点作用，反而失去了数据的实时性（每个小包数据都会延时一定时间再发送）。</p>
<h4 id="Nagle算法与CORK算法区别"><a href="#Nagle算法与CORK算法区别" class="headerlink" title="Nagle算法与CORK算法区别"></a>Nagle算法与CORK算法区别</h4><p>Nagle算法和CORK算法非常类似，但是它们的着眼点不一样，Nagle算法主要避免网络因为太多的小包（协议头的比例非常之大）而拥塞，而CORK算法则是为了提高网络的利用率，使得总体上协议头占用的比例尽可能的小。如此看来这二者在避免发送小包上是一致的，在用户控制的层面上，Nagle算法完全不受用户socket的控制，你只能简单的设置TCP_NODELAY而禁用它，CORK算法同样也是通过设置或者清除TCP_CORK使能或者禁用之，然而Nagle算法关心的是网络拥塞问题，只要所有的ACK回来则发包，而CORK算法却可以关心内容，在前后数据包发送间隔很短的前提下（很重要，否则内核会帮你将分散的包发出），即使你是分散发送多个小数据包，你也可以通过使能CORK算法将这些内容拼接在一个包内，如果此时用Nagle算法的话，则可能做不到这一点。</p>
<p>以上内容转自<a href="http://blog.163.com/li_xiang1102/blog/static/607140762011111103213616/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/05/10/TCP-Nagel算法/" data-id="ciq4lsqiu002xtsqyp49r1hgl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-连续发送多份小数据时40ms延迟问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/连续发送多份小数据时40ms延迟问题/" class="article-date">
  <time datetime="2016-05-10T06:15:32.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/连续发送多份小数据时40ms延迟问题/">连续发送多份小数据时40ms延迟问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="连续发送多份小数据时40ms延迟问题"><a href="#连续发送多份小数据时40ms延迟问题" class="headerlink" title="连续发送多份小数据时40ms延迟问题"></a>连续发送多份小数据时40ms延迟问题</h2><h3 id="以及TCP-NODELAY、TCP-CORK失效问题的定位与解决"><a href="#以及TCP-NODELAY、TCP-CORK失效问题的定位与解决" class="headerlink" title="以及TCP_NODELAY、TCP_CORK失效问题的定位与解决"></a>以及TCP_NODELAY、TCP_CORK失效问题的定位与解决</h3><p>提到TCP_NODELAY和TCP_CORK，相信很多人都很熟悉。然而由于Linux实现上的问题，这两个参数在实际使用中，并不像书里介绍的那么简单。最近DTS在解决一个TCP超时问题时，对这两个参数和它们背后所隐藏的问题有了比较深刻的认识，在此与同学们分享一下我们的经验和教训。</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>和许多经典的分布式程序类似，DTS使用TCP长连接用于client和server的数据交互：client发送请求给server，然后等待server回应。有时候出于数据结构上的考虑，client需要先连续发送多份数据，再等待server的回应。测试发现这种情况下，server端有时会出现接收数据延迟。比如说某个case里，client会先发送275个字节，接着发送24个字节，然后再发送292字节数据等等；此时如果该TCP连接被复用过，则server端在收取24字节这批数据时会很容易出现40ms延迟。</p>
<p>由于client每次发送的数据都很小，很自然想到是nagle算法延迟了client端的数据发送，于是在client端和server端都设置了TCP_NODELAY。然而测试发现，此时server虽然顺利接受了24字节数据，却在接受随后292字节数据时依然出现了40ms延迟。难道是数据太多导致TCP_NODELAY失效？因此又在client端添加了TCP_CORK选项：即如果client需要连续发送多次数据，则先关闭TCP_NODELAY，打开TCP_CORK；所有数据write完后，再关闭TCP_CORK，打开TCP_NODELAY。按照设想，client应该会把所有数据打包在一起发送，但测试结果依然和以前一样，server还是在收取第三份数据时出现了40ms的延迟。</p>
<h4 id="不得已使用tcpdump进行分析，结果如下："><a href="#不得已使用tcpdump进行分析，结果如下：" class="headerlink" title="不得已使用tcpdump进行分析，结果如下："></a>不得已使用tcpdump进行分析，结果如下：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.640134</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 551<span class="pseudo">:826(275)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499424 1712127318&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.640151</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 826<span class="pseudo">:850(24)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499424 1712127318&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.680812</span> <span class="tag">IP</span> <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span> &gt; <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span>: . <span class="tag">ack</span> 850 <span class="tag">win</span> 2252 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 1712127359 2551499424&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.680818</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 850<span class="pseudo">:1142(292)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499465 1712127359&gt;</span><br></pre></td></tr></table></figure>
<p>注意红色的部分，可见client并没有将所有数据打成一个包，每次write的数据还是作为单独的包发送；此外，client在发送完24字节的数据后，一直等到server告知ack才接着发送剩下的292字节。由于server延迟了40ms才告知ack，因此导致了其接收292字节数据时也出现了40ms延迟。</p>
<p>既然查出了延迟是server端delayed ack的原因，通过设置server端TCP_QUICKACK，40ms延迟的问题得到了解决。</p>
<h4 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h4><p>虽然DTS的延时问题暂时得到了解决，但其内在原因却使人百思不得其解：为什么TCP_NODELAY会失效？为什么TCP_CORK无作为？…… 在STL同学的帮助下，我们逐渐对这些困惑有了答案。</p>
<p>首先介绍下delayed ack算法：当协议栈接受到TCP数据时，并不一定会立刻发送ACK响应，而是倾向于等待一个超时或者满足特殊条件时再发送。对于Linux实现，这些特殊条件如下：</p>
<p>1）收到的数据已经超过了full frame size</p>
<p>2）或者处于快速回复模式</p>
<p>3）或者出现了乱序的包</p>
<p>4）或者接收窗口的数据足够多</p>
<p>如果接收方有数据回写，则ACK也会搭车一起发送。当以上条件都不满足时，接收方会延迟40ms再回应ACK。</p>
<h4 id="1-为什么TCP-NODELAY失效"><a href="#1-为什么TCP-NODELAY失效" class="headerlink" title="1.为什么TCP_NODELAY失效"></a>1.为什么TCP_NODELAY失效</h4><p>UNIX网络编程这本书介绍说，TCP_NODELAY同时禁止了nagle算法和delayed ACK算法，因此小块数据可以直接发送。然而Linux实现中，TCP_NODELAY只禁止了nagle算法。另一方面，协议栈在发送包的时候，不仅受到TCP_NODELAY的影响，还受到协议栈里面拥塞窗口的影响。由于server端delayed ack，client迟迟无法收到ack应答，拥塞窗口堵满，从而无法继续发送更多数据；一直到40ms后ack达到，才能继续发送（题外话： TCP_NODELAY在FREEBSD上性能优于Linux上，因为FREEBSD并不像Linux一样需要第一个包到达后就响应ACK）。</p>
<p>这也解释了为什么延时现象在重用过的TCP连接上特别容易出现：目前使用的52bs内核中，连接刚建立时拥塞窗口默认是3，因此可以发送3个数据包，而后拥塞窗口变为2，就会导致第3个292字节的包发不出去。</p>
<h4 id="2-为什么TCP-CORK失效"><a href="#2-为什么TCP-CORK失效" class="headerlink" title="2.为什么TCP_CORK失效"></a>2.为什么TCP_CORK失效</h4><p>TCP_CORK会将发送端多份数据打成一个包，待到TCP_CORK关闭后一起发送。Linux Man手册上也描述了TCP_CORK选项和TCP_NODELAY一起使用的情形。然而根据之前tcpdump的结果，client端设置TCP_CORK后并没有发挥效果。继续测试发现，只要设置过TCP_NODELAY选项，即使随后关闭也会导致TCP_CORK无效；如果从未设置过TCP_NODELAY，则TCP_CORK可以产生效果。</p>
<p>根据STL同学对协议栈代码的调研，发现这个是Linux实现上的问题。在内核中，设置启动TCP_NODELAY选项后，内核会为socket增加两个标志位TCP_NAGLE_OFF和TCP_NAGLE_PUSH，关闭TCP_NODELAY的时候，内核只去掉了TCP_NAGLE_OFF标志位。而在发包的时候判断的却恰恰是TCP_NAGLE_PUSH标志位，如果该位置位设置，就直接把包发出去，从而导致TCP_CORK发挥不了作用。这很可能是这一版本Linux内核实现上的bug。</p>
<h4 id="3-TCP-QUICKACK的作用和限制"><a href="#3-TCP-QUICKACK的作用和限制" class="headerlink" title="3.TCP_QUICKACK的作用和限制"></a>3.TCP_QUICKACK的作用和限制</h4><p>前面介绍delayed ack算法时，讲到协议栈迅速回复ack的情形之一就是进入到快速回复模式。而TCP_QUICKACK选项就是向内核建议进入快速回复模式。快速回复ack模式的判断条件如下：(tp-&gt;ack.quick &amp;&amp; tp-&gt;ack.pingpong)，其中设置QUICKACK选项会置pingpong=0。</p>
<p>然而，随着TCP连接的重用和数据的不断收发，快速回复模式有可能失效。例如在后续的交互过程当中，pingpong变为1的条件就有：1.收到fin后；2. 发送方发送数据时，发现当前时间与上次接收数据的时间小于40ms。此外，发送方发现数据包带有ack标志位时，也会减小ack.quick值。这些都会导致快速回复模式的退出。因此，即使每次接受数据前都设置TCP_QUICKACK选项，也不能完全解决delayed ack问题。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>经过上述的测试与分析，可以认识到当连续发送多个小数据时，TCP_NODELAY作用并不明显，TCP_CORK无法像宣传的那样和TCP_NODELAY混合使用，而TCP_QUICKACK也不能完全解决问题。因此，我们最终的解决方案如下：</p>
<p>（1）在client端多次发送数据时，先打开TCP_CORK选项，发送完后再关闭TCP_CORK，将多份小数据打成一个包发送；此外，client端不能设置TCP_NODELAY选项，以避免TCP_CORK失效。</p>
<p>（2）server端开启TCP_QUICKACK选项，尽量快速回复ack。</p>
<p>通过这个延时问题的解决，可以看到由于Linux实现策略上的问题，TCP_NODELAY和TCP_CORK还是暗藏了不少陷阱。实际应用中，其实也可以绕过这些参数，在应用层将多份数据序列化到一个buffer中，或者使用writev系列函数。然而，这些方法需要额外的内存拷贝，或者让传输对象对外暴露过多的数据结构信息，并不一定容易实现，也会添加代码重构的代价。</p>
<p>另一方面，考虑到那些使用TCP进行异步请求的应用，由于多个请求需要同时复用一个TCP连接，也很容易出现延时问题；而无论是通过TCP_CORK还是writev哪种方法，都不太适合这种异步场景。最近STL推出的新内核添加了一个禁止delayed ack的系统参数，使用该参数理论上讲可以彻底根除40ms的延迟问题。</p>
<p>以上内容转自<a href="http://www.cnblogs.com/tangr206/articles/3284203.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/05/10/连续发送多份小数据时40ms延迟问题/" data-id="ciq4lsqha000ftsqymz4x8tp8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ICMP-协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/ICMP-协议/" class="article-date">
  <time datetime="2016-04-26T12:05:10.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/ICMP-协议/">ICMP 协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ICMP 经常被认为是 IP 层的一个组成部分，它传递差错报文以及其他需要注意的信息。ICMP 报文通常被 IP 层或更高层协议(TCP 或 UDP)使用。ICMP 报文是在 IP 数据报内部传输的。IP 协议是不可靠协议，不能保证 IP 数据报能够成功的到达目的主机，无法进行差错控制，而 ICMP 协议能够协助 IP 协议完成这些功能。下面是 ICMP 报文的数据结构：</p>
<p>类型：一个 8 位类型字段，表示 ICMP 数据包类型;</p>
<p>代码：一个 8 位代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0;</p>
<p>检验和：数据包中 ICMP 部分上的一个 16 位检验和;</p>
<p><img src="/pictures/计算机网络/ICMP协议/ICMP报文格式.png" alt=""></p>
<p>以下针对 ICMP 差错报文的类型进行分析：</p>
<p>1、ICMP 目标不可达消息：IP 路由器无法将 IP 数据报发送给目的地址时，会给发送端主机返回一个目标不可达 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>2、ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。</p>
<p>3、ICMP 超时消息：IP 数据包中有一个字段 TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减 1，直到减到 0 时该 IP 数据包被丢弃。此时，IP 路由器将发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>4、源抑制消息：当 TCP/IP 主机发送数据到另一主机时，如果速度达到路由器或者链路的饱和状态，路由器发出一个 ICMP 源抑制消息。</p>
<h4 id="ICMP-查询报文"><a href="#ICMP-查询报文" class="headerlink" title="ICMP 查询报文"></a>ICMP 查询报文</h4><p>ICMP 回送消息：用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。</p>
<p>ICMP 地址掩码消息：主要用于主机或路由想要了解子网掩码的情况。可以向那些主机或路由器发送 ICMP 地址掩码请求消息，然后通过接收 ICMP 地址掩码应答消息获取子网掩码信息。</p>
<p>ICMP 时间戳消息：可以向那些主机或路由器发送 ICMP 时间戳请求消息，然后通过接收 ICMP 时间戳应答消息获取时间信息。</p>
<h4 id="Ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序"></a>Ping 程序</h4><p>Ping 程序利用 ICMP 回显请求报文和回显应答报文(而不用经过传输层)来测试目标主机是否可达。它是一个检查系统连接性的基本诊断工具。</p>
<p>ICMP 回显请求和 ICMP 回显应答报文是配合工作的。当源主机向目标主机发送了 ICMP 回显请求数据包后，它期待着目标主机的回答。目标主机在收到一个 ICMP 回显请求数据包后，它会交换源、目的主机的地址，然后将收到的 ICMP 回显请求数据包中的数据部分原封不动地封装在自己的 ICMP 回显应答数据包中，然后发回给发送 ICMP 回显请求的一方。如果校验正确，发送者便认为目标主机的回显服务正常，也即物理连接畅通。</p>
<h4 id="Traceroute-程序"><a href="#Traceroute-程序" class="headerlink" title="Traceroute 程序"></a>Traceroute 程序</h4><p>Traceroute 程序主要用来侦测源主机到目的主机之间所经过的路由的情况。</p>
<p>Traceroute 使用 ICMP 报文和 IP 首部中的 TTL 字段，它充分利用了 ICMP 超时消息。其原理很简单，开始时发送一个 TTL 字段为 1 的 UDP 数据报，而后每次收到 ICMP 超时萧后，按顺序再发送一个 TTL 字段加 1 的 UDP 数据报，以确定路径中的每个路由器，而每个路由器在丢弃 UDP 数据报时都会返回一个 ICMP 超时报文，而最终到达目的主机后，由于 ICM P选择了一个不可能的值作为 UDP 端口(大于30000)。这样目的主机就会发送一个端口不可达的 ICMP 差错报文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/ICMP-协议/" data-id="ciq4lsqjm0049tsqyivn5jw6y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DDOS攻击简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/DDOS攻击简介/" class="article-date">
  <time datetime="2016-04-26T08:34:37.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/DDOS攻击简介/">DDOS攻击简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DDOs攻击主要有两种类型：流量攻击和占用服务器资源攻击</p>
<p>针对于TCP/IP协议的不同，ddos可以利用好几个协议的漏洞进行攻击。</p>
<h2 id="基于TCP协议的攻击"><a href="#基于TCP协议的攻击" class="headerlink" title="基于TCP协议的攻击"></a>基于TCP协议的攻击</h2><h4 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h4><p>基于TCP协议的攻击主要利用的是TCP的三次握手漏洞，由于TCP建立连接的时候需要三次握手，当服务器收到一个SYN包后，服务器会处于SYN_Received状态，并且在系统中保存半连接的数据，同时发送SYN-ACK包给客户端，但是此时客户端消失了，而处于这个状态的服务器会有一个定时器，在收不到客户端的回复的时候，会重新的发送SYN-ACk数据包（3-5次，并且等待一个SYN-time，一般是30秒到2分钟），此时半连接的数据一直占着系统资源，这样的话，如果有大量这种行为就会导致服务器资源被一直占用着，而正常连接行为的客户却得不到处理。这就是所谓的SYN攻击</p>
<h4 id="ACK-Flood-攻击"><a href="#ACK-Flood-攻击" class="headerlink" title="ACK Flood 攻击"></a>ACK Flood 攻击</h4><p>ACK Flood攻击是在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应RST包告诉对方此端口不存在。<br>这里，服务器要做两个动作：查表、回应 ACK/RST。这种攻击方式显然没有SYN Flood给服务器带来的冲击大，因此攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。按照我们对TCP协议的理解，随机源IP的ACK小包应该会被Server很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。但是实际上通过测试，发现有一些TCP服务会对ACK Flood比较敏感，比如说JSP Server，在数量并不多的ACK小包的打击下，JSP Server就很难处理正常的连接请求。对于Apache或者IIS来说，10kpps的ACK Flood不构成危胁，但是更高数量的ACK Flood会造成服务器网卡中断频率过高，负载过重而停止响应。可以肯定的是，ACK Flood不但可以危害路由器等网络设备，而且对服务器上的应用有不小的影响。</p>
<p>也有另外一种攻击：connection 攻击，就是大量的肉机与服务器建立连接，占用服务器的资源不放，而一台服务器的连接数量是有限的，大量的连接都被占用了，新的正常连接得不到服务。</p>
<h2 id="基于UDP的攻击"><a href="#基于UDP的攻击" class="headerlink" title="基于UDP的攻击"></a>基于UDP的攻击</h2><p>UDP Flood是日渐猖厥的流量型DoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。 100k pps的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。</p>
<h2 id="基于ICMP的攻击"><a href="#基于ICMP的攻击" class="headerlink" title="基于ICMP的攻击"></a>基于ICMP的攻击</h2><h4 id="死亡之ping"><a href="#死亡之ping" class="headerlink" title="死亡之ping"></a>死亡之ping</h4><p>IP协议规定IP包最大尺寸为65536，大部分的处理程序在处理IP包的时候，会假定报文不会超过最大的尺寸，利用该漏洞，可以发送大于65536的数据包，使得系统在处理报文的时候发生内存溢出，从而使得系统崩溃。这就是死亡之ping的实现原理，发送大于限制长度的报文来使得服务器出现系统奔溃</p>
<h4 id="echo攻击"><a href="#echo攻击" class="headerlink" title="echo攻击"></a>echo攻击</h4><p>利用ICMP的echo机制，对服务器发送大量的ICMP包，占用服务器的带宽，也可以利用ICMP的广播机制，将源端IP伪造成服务器的IP，向网络广播ICMP echo request，从而使得大量的网络机器向服务器发送ICMP echo应答包，占用服务器的大量带宽。</p>
<h4 id="针对链接的ICMP-DoS"><a href="#针对链接的ICMP-DoS" class="headerlink" title="针对链接的ICMP DoS"></a>针对链接的ICMP DoS</h4><p>针对连接的DoS攻击，可以终止现有的网络连接。针对网络连接的DoS攻击会影响所有的IP设备，因为它使用了合法的ICMP消息。Nuke通过发送一个伪造的ICMP Destination Unreachable或Redirect消息来终止合法的网络连接。更具恶意的攻击，如puke和smack，会给某一个范围内的端口发送大量的数据包，毁掉大量的网络连接，同时还会消耗受害主机CPU的时钟周期。</p>
<h4 id="基于ICMP重定向的路由欺骗技术"><a href="#基于ICMP重定向的路由欺骗技术" class="headerlink" title="基于ICMP重定向的路由欺骗技术"></a>基于ICMP重定向的路由欺骗技术</h4><p>攻击者可利用ICMP重定向报文破坏路由，并以此增强其窃听能力。除了路由器，主机必须服从ICMP重定向。如果一台机器想网络中的另一台机器发送了一个ICMP重定向消息，这就可能引起其他机器具有一张无效的路由表。如果一台机器伪装成路由器截获所有到某些目标网络或全部目标网络的IP数据包，这样就形成了窃听。通过ICMP技术还可以抵达防火墙后的机器进行攻击和窃听。</p>
<p>注：重定向路由欺骗技术尚无实际应用。</p>
<h2 id="HTTP-Get-攻击"><a href="#HTTP-Get-攻击" class="headerlink" title="HTTP Get 攻击"></a>HTTP Get 攻击</h2><p>这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQLServer、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。一般来说，提交一个GET或POST指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是很大的，常见的数据库服务器很少能支持数百个查询指令同时执行，而这对于客户端来说却是轻而易举的，因此攻击者只需通过Proxy代理向主机服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务，常见的现象就是网站慢如蜗牛、ASP程序失效、PHP连接数据库失败、数据库主程序占用CPU偏高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/DDOS攻击简介/" data-id="ciq4lsqjo004ctsqykvaflm2t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内网穿透简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/内网穿透简介/" class="article-date">
  <time datetime="2016-04-26T06:13:50.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/内网穿透简介/">内网穿透简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NAT的类型"><a href="#NAT的类型" class="headerlink" title="NAT的类型"></a>NAT的类型</h2><p>NAT一般有两种大的类型：cone（漏斗）类型和symmetric（对称）类型</p>
<h3 id="cone"><a href="#cone" class="headerlink" title="cone"></a>cone</h3><p>cone类型又分为三种小的类型，分别为：full cone、restricted cone和port restricted cone</p>
<p>在cone类型中，内网ip-port对在NAT中的映射是不变的，即使所访问的外网ip-port端口不一样，这也是其命名为cone的原因。</p>
<h4 id="full-cone"><a href="#full-cone" class="headerlink" title="full cone"></a>full cone</h4><p>full cone是限制最少的类型，在NAT服务器上，一个内网的ip-port对只映射到一个公网的ip-port对，而不管内网主机访问的外网ip-port对的不同。</p>
<h4 id="restricted-cone"><a href="#restricted-cone" class="headerlink" title="restricted cone"></a>restricted cone</h4><p>restricted cone相对于full cone类型增加了外网ip的限制，只有内网的机器访问了某个外网的机器，该外网机器的数据包才可以通过NAT的限制。在NAT的映射中，NAT维持一个映射关系：<br>{对端外网ip：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个外网ip的机器不同的port都可以通过该映射，从而实现与内网的通讯。</p>
<h4 id="port-restricted-cone"><a href="#port-restricted-cone" class="headerlink" title="port restricted cone"></a>port restricted cone</h4><p> port restricted cone类型在restricted cone类型的基础上增加了port的限制，必须又内网的机器访问外网机器的某个端口，该外网机器的对应端口发出的数据包才可以通过NAT。NAT维持的映射关系如下：<br> {对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个机器的特定端口才可以通过该映射。</p>
 <font color="red">注意，在以上的三种类型中，只要内网ip-port对不变，其在NAT的映射所对应的公网ip-port对就不会改变，也就是说，同一个内网ip-port在通讯过程中，其所对外的公网ip-port是不变的</font>

<h3 id="symmetric"><a href="#symmetric" class="headerlink" title="symmetric"></a>symmetric</h3><p>该类型的限制最严格，端口对端口的通讯都会有一个特定的映射，就拿port restricted cone来说，对于映射：{对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}， 只要是四元组中的内网ip：内网port不变，那么所有的四元组都会被映射到同一个{公网ip：公网port}，而在symmetric类型下，只要四元组中有一个是变化的，都会被映射到不同的而且唯一的{公网ip：公网port}。</p>
<p>cone 的映射是多对一的映射，类似于一个漏斗，而symmetric的映射是一个一对一的映射，也就是对称的映射。</p>
<h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p>根据NAT的类型不同，具体的实现细节也是不同的。但是不管是NAT类型不同，还是所采用的打洞技术不同，都需要使用到第三方服务器作为彼此信息的转发者。采用UDP来实现打洞，成功率会比较高，实现起来也比较容易。而采用TCP来打洞的话，成功率较低，而且实现起来会比较的麻烦，主要的原因就是对于TCP来说，既要打洞又要建立监听，而两者所使用的端口都是一样的，而且如果两端同时收到对端的SYN，那么两端都会处于SYN-Received状态，具体进一步的处理就要看不同的系统的TCP栈处理程序了，这个也就会导致TCP在打洞方面的成功率低于UDP。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/内网穿透简介/" data-id="ciq4lsqi7001xtsqypi3kjii0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-typedef与define的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/typedef与define的区别/" class="article-date">
  <time datetime="2016-04-12T02:50:47.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/typedef与define的区别/">typedef与define的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef故名思意就是类型定义的意思，但是它并不是定义一个新的类型而是给已有的类型起一个别名，在这一点上与引用的含义类似，引用是变量或对象的别名，而typedef定义的是类型的别名。typedef的作用主要有两点：</p>
<h4 id="1-1-简化复杂的类型声明"><a href="#1-1-简化复杂的类型声明" class="headerlink" title="1.1  简化复杂的类型声明"></a>1.1  简化复杂的类型声明</h4><p>简化复杂的类型声明，或给已有类型起一含义明确的别名；如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个返回 bool 类型并带有两个(int和double)形参的函数的指针类型FuncPointer</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncPointer)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了一个FuncPointer类型的函数指针对象pFunc</span></span><br><span class="line">FuncPointer pFunc;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-定义与平台无关的类型"><a href="#1-2-定义与平台无关的类型" class="headerlink" title="1.2  定义与平台无关的类型"></a>1.2  定义与平台无关的类型</h4><p>定义与平台无关的类型，屏蔽不同平台的类型差异化；如：<br>用typedef来定义与平台无关的类型。<br>比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：<br>typedef long double REAL;<br>在不支持 long double 的平台二上，改为：<br>typedef double REAL;<br>在连 double 都不支持的平台三上，改为：<br>typedef float REAL;<br>也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。<br>标准库就广泛使用了这个技巧，比如size_t。另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健。</p>
<h4 id="1-3-与struct的结合使用"><a href="#1-3-与struct的结合使用" class="headerlink" title="1.3  与struct的结合使用"></a>1.3  与struct的结合使用</h4><p>在C++中，struct与class的作用相同，就是默认的访问权限不同，struct默认为public，而class默认为private的。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Person  </span><br><span class="line">&#123;  </span><br><span class="line">    string name<span class="comment">;  </span></span><br><span class="line">    int age<span class="comment">;  </span></span><br><span class="line">    float height<span class="comment">;  </span></span><br><span class="line">&#125;<span class="comment">;  </span></span><br><span class="line">Person person<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，定义一个Person的对象person。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，在定义的同时还声明了一个Person的对象person。</p>
<p>但是在C语言中，struct的定义和声明要用typedef。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;Person;    <span class="comment">//这是Person是结构体的一个别名  </span></span><br><span class="line">Person person;</span><br></pre></td></tr></table></figure></p>
<p>如果没有typedef就必须用struct Person person;来声明，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">struct</span> Person person;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;    <span class="comment">//person是Person的对象</span></span><br></pre></td></tr></table></figure></p>
<h2 id="typedef与-define的区别"><a href="#typedef与-define的区别" class="headerlink" title="typedef与#define的区别"></a>typedef与#define的区别</h2><h4 id="2-1-执行时间不同"><a href="#2-1-执行时间不同" class="headerlink" title="2.1.  执行时间不同"></a>2.1.  执行时间不同</h4><p>关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。</p>
<p>#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。<br>typedef会做相应的类型检查：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT value = <span class="string">"abc"</span>; <span class="comment">// error C2440: 'initializing' : cannot convert from 'const char [4]' to 'UINT'  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#define不做类型检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define用法例子：  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> f(x) x*x  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">6</span>, b=<span class="number">2</span>, c;  </span><br><span class="line">    c=f(a) / f(b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是: 36，根本原因就在于#define只是简单的字符串替换。</p>
<h4 id="2-2-功能有差异"><a href="#2-2-功能有差异" class="headerlink" title="2.2. 功能有差异"></a>2.2. 功能有差异</h4><p>typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。</p>
<p>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<h4 id="2-3．作用域不同"><a href="#2-3．作用域不同" class="headerlink" title="2.3．作用域不同"></a>2.3．作用域不同</h4><p>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。<br>而typedef有自己的作用域。</p>
<p>【例2.3.1】没有作用域的限制，只要是之前预定义过就可以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="preprocessor">#<span class="keyword">define</span> HW <span class="string">"HelloWorld"</span>;  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> str = HW;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【例<span class="number">2.3</span><span class="number">.2</span>】而<span class="keyword">typedef</span>有自己的作用域</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT uValue = <span class="number">5</span>;<span class="comment">//error C2065: 'UINT' : undeclared identifier  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例2.3.3】<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    typedef unsigned <span class="keyword">int</span> <span class="keyword">UINT</span>;  </span><br><span class="line">    <span class="keyword">UINT</span> valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">UINT</span> valueB;  </span><br><span class="line">    <span class="comment">//error C2146: syntax error : missing ';' before identifier 'valueB'  </span></span><br><span class="line">    <span class="comment">//error C4430: missing type specifier - int assumed. Note: C++ does not support default-int  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面例子在B类中使用UINT会出错，因为UINT只在类A的作用域中。此外，在类中用typedef定义的类型别名还具有相应的访问权限<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// error C2248: 'A::UINT' : cannot access private typedef declared in class 'A'  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而给UINT加上public访问权限后，则可编译通过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4．-对指针的操作"><a href="#2-4．-对指针的操作" class="headerlink" title="2.4． 对指针的操作"></a>2.4． 对指针的操作</h4><p>二者修饰指针类型时，作用不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * pint;  </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PINT int *  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;    <span class="comment">//p不可更改，p指向的内容可以更改，相当于 int * const p;  </span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;    <span class="comment">//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；  </span></span><br><span class="line"></span><br><span class="line">pint s1, s2;    <span class="comment">//s1和s2都是int型指针  </span></span><br><span class="line">PINT s3, s4;    <span class="comment">//相当于int * s3，s4；只有一个是指针。  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//p1 = &amp;i2; //error C3892: 'p1' : you cannot assign to a variable that is const  </span></span><br><span class="line">    *p1 = <span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//*p2 = 10; //error C3892: 'p2' : you cannot assign to a variable that is const  </span></span><br><span class="line">    p2 = &amp;i1;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">1</span></span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">5</span></span><br><span class="line">p2:<span class="number">00</span>EFD098  *p2:<span class="number">2</span></span><br><span class="line">p2:<span class="number">00</span>EFD094  *p2:<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.csdn.net/luoweifu/article/details/41630195" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/12/typedef与define的区别/" data-id="ciq4lsqib0024tsqy7kpo1tt1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-epoll之ET和LT编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/epoll之ET和LT编程/" class="article-date">
  <time datetime="2016-04-07T07:45:11.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/epoll之ET和LT编程/">epoll之ET和LT编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK(注: EAGAIN就是EWOULDBLOCK)<br>从字面上看, 意思是:EAGAIN: 再试一次，EWOULDBLOCK: 如果这是一个阻塞socket, 操作将被block，perror输出: Resource temporarily unavailable</p>
<p>总结:<br>这个错误表示资源暂时不够，能read时，读缓冲区没有数据，或者write时，写缓冲区满了。遇到这种情况，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。<br>所以，对于阻塞socket，read/write返回-1代表网络出错了。但对于非阻塞socket，read/write返回-1不一定网络真的出错了。可能是Resource temporarily unavailable。这时你应该再试，直到Resource available。</p>
<p>综上，对于non-blocking的socket，正确的读写操作为:<br>读：忽略掉errno = EAGAIN的错误，下次继续读<br>写：忽略掉errno = EAGAIN的错误，下次继续写</p>
<p>对于select和epoll的LT模式，这种读写方式是没有问题的。但对于epoll的ET模式，这种方式还有漏洞。</p>
<p>epoll的两种模式LT和ET<br>二者的差异在于level-trigger模式下只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket；而edge-trigger模式下只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</p>
<p>所以，在epoll的ET模式下，正确的读写方式为:<br>读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN<br>写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</p>
<p>正确的读<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">    perror(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正确的写</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int nwrite, data_size = <span class="literal">strlen</span>(buf);</span><br><span class="line"><span class="keyword">n</span> = data_size;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">n</span> &gt; 0) &#123;</span><br><span class="line">    nwrite = write(fd, buf + data_size - <span class="keyword">n</span>, <span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">if</span> (nwrite &lt; <span class="keyword">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nwrite == -1 &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">            perror(<span class="string">"write error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">n</span> -= nwrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确的accept，accept-要考虑-2-个问题"><a href="#正确的accept，accept-要考虑-2-个问题" class="headerlink" title="正确的accept，accept 要考虑 2 个问题"></a>正确的accept，accept 要考虑 2 个问题</h3><h4 id="1-阻塞模式-accept-存在的问题"><a href="#1-阻塞模式-accept-存在的问题" class="headerlink" title="(1) 阻塞模式 accept 存在的问题"></a>(1) 阻塞模式 accept 存在的问题</h4><p>考虑这种情况：TCP连接被客户端夭折，即在服务器调用accept之前，客户端主动发送RST终止连接，导致刚刚建立的连接从就绪队列中移出，如果套接口被设置成阻塞模式，服务器就会一直阻塞在accept调用上，直到其他某个客户建立一个新的连接为止。但是在此期间，服务器单纯地阻塞在accept调用上，就绪队列中的其他描述符都得不到处理。</p>
<p>解决办法是把监听套接口设置为非阻塞，当客户在服务器调用accept之前中止某个连接时，accept调用可以立即返回-1，这时源自Berkeley的实现会在内核中处理该事件，并不会将该事件通知给epool，而其他实现把errno设置为ECONNABORTED或者EPROTO错误，我们应该忽略这两个错误。</p>
<h4 id="2-ET模式下accept存在的问题"><a href="#2-ET模式下accept存在的问题" class="headerlink" title="(2)ET模式下accept存在的问题"></a>(2)ET模式下accept存在的问题</h4><p>考虑这种情况：多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。</p>
<p>解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。</p>
<p>综合以上两种情况，服务器应该使用非阻塞地accept，accept在ET模式下的正确使用方式为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote, (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handle_client(conn_sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">    perror(<span class="string">"accept"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll ET 模式简单HTTP服务器代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_EVENTS <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT <span class="number">8080</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置socket连接为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts;</span><br><span class="line"></span><br><span class="line">    opts = fcntl(sockfd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_GETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = (opts | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(sockfd, F_SETFL, opts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_SETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line">    <span class="keyword">int</span> addrlen, listenfd, conn_sock, nfds, epfd, fd, i, nread, n;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in local, remote;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建listen socket</span></span><br><span class="line">    <span class="keyword">if</span>( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sockfd\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setnonblocking(listenfd);</span><br><span class="line">    bzero(&amp;local, <span class="keyword">sizeof</span>(local));</span><br><span class="line">    local.sin_family = AF_INET;</span><br><span class="line">    local.sin_addr.s_addr = htonl(INADDR_ANY);;</span><br><span class="line">    local.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>( bind(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;local, <span class="keyword">sizeof</span>(local)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(MAX_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epfd == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_ctl: listen_sock"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == -<span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_pwait"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == listenfd) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote,</span><br><span class="line">                                (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    setnonblocking(conn_sock);</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = conn_sock;</span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                                &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"epoll_ctl: add"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED</span><br><span class="line">                            &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">                        perror(<span class="string">"accept"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    n += nread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                    perror(<span class="string">"read error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ev.data.fd = fd;</span><br><span class="line">                ev.events = events[i].events | EPOLLOUT;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">"epoll_ctl: mod"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\nHello World"</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">int</span> nwrite, data_size = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                n = data_size;</span><br><span class="line">                <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nwrite = write(fd, buf + data_size - n, n);</span><br><span class="line">                    <span class="keyword">if</span> (nwrite &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwrite == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                            perror(<span class="string">"write error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    n -= nwrite;</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://www.ccvita.com/515.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/epoll之ET和LT编程/" data-id="ciq4lsqij002itsqyq5grdmvm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket非阻塞读写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/socket非阻塞读写/" class="article-date">
  <time datetime="2016-04-07T07:39:46.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/socket非阻塞读写/">socket非阻塞读写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>对于阻塞的socket,当socket的接收缓冲区中没有数据时，read调用会一直阻塞住，直到有数据到来才返回。当socket缓冲区中的数据量小于期望读取的数据量时，返回实际读取的字节数。当sockt的接收缓冲区中的数据大于期望读取的字节数时，读取期望读取的字节数，返回实际读取的长度。对于非阻塞socket而言，socket的接收缓冲区中有没有数据，read调用都会立刻返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的，如果接收缓冲区中没有数据，则返回-1，错误号为EWOULDBLOCK或EAGAIN,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。如果返回值是其它负值，则表明读取错误。因此，非阻塞的read调用一般这样写:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(sock_fd, buffer, <span class="built_in">len</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//没有读到数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读取失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读到数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>对于写操作write,原理是类似的，非阻塞socket在发送缓冲区没有空间时会直接返回-1，错误号EWOULDBLOCK或EAGA,表示没有空间可写数据，如果错误号是别的值，则表明发送失败。如果发送缓冲区中有足够空间或者是不足以拷贝所有待发送数据的空间的话，则拷贝前面N个能够容纳的数据，返回实际拷贝的字节数。而对于阻塞Socket而言，如果发送缓冲区没有空间或者空间不足的话，write操作会直接阻塞住，如果有足够空间，则拷贝所有数据到发送缓冲区，然后返回.非阻塞的write操作一般写法是:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> write_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nLeft = nLen;</span><br><span class="line"><span class="keyword">while</span>(nLeft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nWrite = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( (nWrite = write(sock_fd, data+write_pos, nLeft)) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;</span><br><span class="line">nWrite = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//写失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nLeft -= nWrite;</span><br><span class="line">wirte_pos += nWrite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.163.com/hbu_lijian/blog/static/126129153201311742750909/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/socket非阻塞读写/" data-id="ciq4lsqie002atsqyji8ckm9l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-之auto、static、extern、register" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/C-之auto、static、extern、register/" class="article-date">
  <time datetime="2016-04-07T02:56:21.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/C-之auto、static、extern、register/">C++之auto、static、extern、register</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern 用来声明一个外部变量或是函数，表示该变量已经在其他的地方定义了，这里只是做一个引用而已，不会产生新的变量。对于extern修饰的变量，编译器会在所在的文件先看看有没有对该变量的定义，有的话，直接应用，没有的话再到其他的文件里面进行查找。由于变量已经在其他的地方定义了，所以<code>extern int a = 10;</code>这种写法是不对的，会造成重定义错误！</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static可以用来修饰变量和函数。</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><p>static修饰的变量都存在静态数据区里面，由于静态数据区内存都是被系统初始化为0的，所以static修饰的变量默认初始值为0。<br>static修饰的变量的作用域只限制于该变量所在的文件，外面的文件不可以使用该变量，所以多个文件可以有相同的变量名（需要使用static修饰），只要在编译的最后链接阶段，在全局情况下，不出现相同的变量名就好。</p>
<h4 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h4><p>static修饰的函数主要有两个作用：限定该函数的作用域为本文件可见以及static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝，因此对于static函数的调用会比普通函数快很多。</p>
<h4 id="类中的static"><a href="#类中的static" class="headerlink" title="类中的static"></a>类中的static</h4><p>在类中，static修饰的成员变量或是函数表明该变量或是函数是属于类的，所以没有对应的this指针。static修饰的函数只能访问类的static修饰的成员变量，并且static修饰的函数不能是虚函数。</p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序都变量大多是自动变量。auto不能修饰全局变量，因为该变量的内存是放在栈上面的，有系统自动创建和销毁，所以不能用来修饰全局变量。在函数里面，一般所声明的变量都是直接的默认为auto的。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行。系统的寄存器是有限制的,声明变量时如:<code>register int i</code>.这种存储类型可以用于频繁使用的变量。实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。</p>
<p>使用register修饰符有几点限制</p>
<p>（1）register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。最好不要这样去用</p>
<p>（2）因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。</p>
<p>（3）只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。所以说不要用register修饰全局变量等，因为他长时间的占用寄存器不允许再被使用了。</p>
<p>（4）局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c，同样的道理，因为static变量函数结束不会被销毁，下面进入还会使用之前的数据，生命周期直到程序退出才结束，数据存放在静态区。</p>
<p>（5）由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。</p>
<p>auto register 是用来修饰变量的,static extern 变量函数都可以</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/C-之auto、static、extern、register/" data-id="ciq4lsqjr004htsqy7fw9ucsh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux-网络编程/" style="font-size: 18px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 18px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 16px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 10px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 14px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 14px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 12px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 12px;">爬虫</a> <a href="/tags/随记/" style="font-size: 12px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/02/管道/">管道</a>
          </li>
        
          <li>
            <a href="/2016/05/10/TCP-Nagel算法/"> TCP Nagel算法</a>
          </li>
        
          <li>
            <a href="/2016/05/10/连续发送多份小数据时40ms延迟问题/">连续发送多份小数据时40ms延迟问题</a>
          </li>
        
          <li>
            <a href="/2016/04/26/ICMP-协议/">ICMP 协议</a>
          </li>
        
          <li>
            <a href="/2016/04/26/DDOS攻击简介/">DDOS攻击简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>