<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式之单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/设计模式之单例模式/" class="article-date">
  <time datetime="2016-07-07T04:08:13.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/设计模式之单例模式/">设计模式之单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单例模式的定义：确保一个类只有一个实例，并提供一个全局访问点</p>
<h4 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;     <span class="comment">//属于类的，只能通过函数得到,也是唯一的单例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;              <span class="comment">//私有的构造函数，不允许外界直接实例化对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;          <span class="comment">//获得单例对象的全局访问点</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)                    </span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在单线程的环境下运行的很好，但是在多线程的情况下，就会出现问题。主要在于<code>getInstance</code>函数在多线程情况下会出现资源竞争，可以对<code>getInstance</code>函数变成同步的方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;          <span class="comment">//获得单例对象的全局访问点</span></span><br><span class="line">  <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)                    </span><br><span class="line">      uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是同步一个方法可能造成程序执行效率降低100倍，而且其实在<code>getInstance</code>函数中，并不是整一个方法都属于资源竞争的范围，只有<code>uniqueInstance = new Singleton()</code>语句才是，而且只有在单例对象第一次初始化的时候才会执行该语句，其余的都不会进入到该语句中，所以直接对整一个方法进行同步有点浪费。<br>可以双重检查加锁，在<code>getInstance</code>函数中减少同步<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">  <span class="comment">//volatile 表明该变量是易变的，编译器不要对其进行优化，每一个反问的时候都要在内存中进行读取，不要存放在寄存器中</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.<span class="keyword">class</span>)&#123;</span><br><span class="line">        <span class="comment">//在执行到这里面是，并不知道uniqueInstance对象会不会被其他的线程改变，所以需要在检查一下</span></span><br><span class="line">        <span class="comment">//以确保在null的情况下才实例化一个对象</span></span><br><span class="line">        <span class="comment">//volatile关键字表明每一次对uniqueInstance变量的读取都是直接在内存中读的     </span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以在多线程的情况下保证代码的正确运行同时对程序执行效率没有影响，只有在第一次初始化是才会执行同步方法。</p>
<p>以上的单例程序都是在程序调用<code>getInstance</code>方法时，才会实例化Singleton对象的，这也就是所谓的”延迟实例化”，这样可以保证资源不被浪费。如果单例对象所占有的资源不大，那么也可以直接的实例化——“急切”实例化。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sinngleton</span>&#123;</span><br><span class="line">  <span class="comment">//在类加载的时候直接的实例化，不存在多线程的问题</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们依赖JVM在加载这个类的时候就直接创建单例实例。JVM确保在任何线程反问uniqueInstance静态变量前，一定先创建此实例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/设计模式之单例模式/" data-id="ciqbvirls000ppsqy2mr4evtz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式之观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/设计模式之观察者模式/" class="article-date">
  <time datetime="2016-07-06T15:42:23.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/设计模式之观察者模式/">设计模式之观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>观察者模式有由两部分组成：主题和观察者。主题负责生产数据，观察者通过订阅主题来获得需要观察的数据<br>观察者模式定义：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都收到通知并自动更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主题接口</span></span><br><span class="line"><span class="keyword">public</span> Interface Subject&#123;</span><br><span class="line">  registerObserver(Observer);</span><br><span class="line">  removeObserver(Observer);</span><br><span class="line">  notifyObservers();  <span class="comment">//有新数据的时候，调用该函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line"><span class="keyword">public</span> Interface Observer&#123;</span><br><span class="line">  <span class="comment">//在主题有数据更新时，在notifyObservers函数里面，</span></span><br><span class="line">  <span class="comment">//会对每一个已经注册的Observer调用该函数，实现对Observer的通知</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer ob)</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer ob)</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;              <span class="comment">//有新数据的时候，调用该函数</span></span><br><span class="line">    <span class="keyword">for</span>(Observer ob : Observers)&#123;</span><br><span class="line">      ob.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;  </span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的观察者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Subject sbj;     <span class="comment">//对主题的应用，以实现对所感兴趣的主题的订阅与取消订阅</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ol>
<li><p>“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。</p>
</li>
<li><p>在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义的字符串方式：String str = “Java String”;</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/设计模式之观察者模式/" data-id="ciqbvirlo000kpsqyeqcfmobi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式之工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/设计模式之工厂模式/" class="article-date">
  <time datetime="2016-07-06T14:52:50.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/设计模式之工厂模式/">设计模式之工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工厂模式分为两种：工厂方法模式和抽象工厂模式<br>一个Pizaa店的订单：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PizzaStore&#123;</span><br><span class="line">  <span class="keyword">public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    Pizza p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"aa"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">      p =  <span class="literal">new</span> AAPizaa();   <span class="comment">//AAPizza为Pizaa的子类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"bb"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">        p =  BBPizaa();     <span class="comment">//BBPizza为Pizaa的子类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>简单工厂只是一种编程习惯，并不是真正的设计模式。他只是把类中实例化一个对象的工作给抽出来，用一个工厂类来负责对象的实例化<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化的工作被抽离出来</span></span><br><span class="line"><span class="keyword">public</span> class SimplePizzaFactory&#123;</span><br><span class="line">  <span class="keyword">public</span> SimplePizzaFactory()&#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span> Pizza createPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"aa"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">      reutrn <span class="literal">new</span> AAPizza();   <span class="comment">//AAPizza为Pizza的子类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"bb"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">        <span class="keyword">return</span> BBPizza();     <span class="comment">//BBPizza为Pizza的子类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class PizzaStore&#123;</span><br><span class="line">  SimplePizzaFactory spf;</span><br><span class="line">  <span class="keyword">public</span> PizzaStore(SimplePizzaFactory spf)&#123;</span><br><span class="line">    this<span class="built_in">.</span>spf = spf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    Pizza p;</span><br><span class="line">    p = spf<span class="built_in">.</span>createPizza(<span class="keyword">type</span>);</span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式只是定义一个实例化子类的接口，具体子类的实例化由其派生类来决定实现<br>工厂方法模式定义：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个类，工厂方法让类把实例化推迟到子类里。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span>(</span>)&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>);</span>   <span class="comment">//工厂方法，具体pizza类的实例化由派生类来实现</span></span><br><span class="line">  public <span class="type">Pizza</span> orderPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">    <span class="type">Pizza</span> p;</span><br><span class="line">    p = createPizza(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的对象实例化由派生类决定</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AAPizzaStore</span>(</span>) <span class="keyword">extends</span> <span class="type">PizzaStore</span>&#123;</span><br><span class="line">   <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="type">System</span>.out.println(<span class="string">"I'm AAPizzaStore"</span>);</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"aa"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>       reutrn <span class="keyword">new</span> <span class="type">AA1Pizza</span>();   <span class="comment">//AA1Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"bb"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>         <span class="keyword">return</span> <span class="type">AA2Pizza</span>();     <span class="comment">//AA2Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span> ...</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BBPizzaStore</span>(</span>) <span class="keyword">extends</span> <span class="type">PizzaStore</span>&#123;</span><br><span class="line">   <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="type">System</span>.out.println(<span class="string">"I'm BBPizzaStore"</span>);</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"aa"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>       reutrn <span class="keyword">new</span> <span class="type">BB1Pizza</span>();   <span class="comment">//BB1Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"bb"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>         <span class="keyword">return</span> <span class="type">BB2Pizza</span>();     <span class="comment">//BB2Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span> ...</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式里面有很多个工厂方法，每一个工厂方法就是一个用来实例化类的接口<br>抽象工厂模式定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类<br>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出来的具体产品是什么。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> Interface PizzaIngredientFactory&#123;</span><br><span class="line">  <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Cheese <span class="title">crateCheese</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Clam <span class="title">CreateClam</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYDough</span><span class="params">()</span></span>;  <span class="comment">//NYDough 为 Dough的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYSauce</span><span class="params">()</span></span>;  <span class="comment">//NYSauce 为 Sauce的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYCheese</span><span class="params">()</span></span>;  <span class="comment">//NYCheese 为 Cheese的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Clam <span class="title">createClam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYClam</span><span class="params">()</span></span>;  <span class="comment">//NYClam 为 Clam的子类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoDough</span><span class="params">()</span></span>;  <span class="comment">//ChicagoDough 为 Dough的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoSauce</span><span class="params">()</span></span>;  <span class="comment">//ChicagoSauce 为 Sauce的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoCheese</span><span class="params">()</span></span>;  <span class="comment">//ChicagoCheese 为 Cheese的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Clam <span class="title">createClam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoClam</span><span class="params">()</span></span>;  <span class="comment">//ChicagoClam 为 Clam的子类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/设计模式之工厂模式/" data-id="ciqbvirlq000npsqy8n5xzfpt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之auto和decltype" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之auto和decltype/" class="article-date">
  <time datetime="2016-07-06T10:48:56.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之auto和decltype/">C++11常规特性之auto和decltype</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++11之前，auto用来声明对象的存储期，修饰普通局部栈变量，是自动存储，这种对象会自动创建和销毁。在C++11新特性中，用来实现类型的推判。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。特别是在循环遍历容器的时候，auto会显得很有用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> Ptr();</span><br><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>,&amp;r=i;</span><br><span class="line"><span class="keyword">auto</span> a=r;<span class="comment">//a为int，因为r是i的别名，i为int。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> b = v.begin();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = begin(<span class="built_in">map</span>); it != end(<span class="built_in">map</span>); ++it) &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，auto不能用来声明函数的返回值。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T1, typename T2&gt;</span><br><span class="line"><span class="keyword">auto</span> compose(T1 t1, T2 t2) -&gt; decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> v = compose(<span class="number">2</span>, <span class="number">3.14</span>); <span class="comment">// v's type is double</span></span><br></pre></td></tr></table></figure></p>
<p>使用auto时,你只是需要一个变量的类型初始化。如果你需要一个类型不是一个变量，那么你需要用到decltype,例如返回类型。decltype是根据变量推导获取出变量的类型。目的是选择并返回操作数的数据类型，重要的是，在此过程中编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum=x;  <span class="comment">//sum的类型就是f返回值的类型， 但是这里不执行函数f()</span></span><br><span class="line"><span class="keyword">auto</span> x= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(x*y)</span> Type</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x*y) xy;  <span class="comment">//xy的类型为int</span></span><br><span class="line"><span class="comment">//decltype声明函数指针的时，关键是要记住decltype返回的是一个函数的类型的，因此要加上*声明符才能构成完整的函数指针的类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(f)* k = f; <span class="comment">//直接decltype(f) k = f 是不可以的</span></span><br><span class="line">k(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果decltype使用表达式的结果类型可以作为一条赋值语句的左值，那么decltype返回一个引用类型，例如解引用操作和变量加括号的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c=k; <span class="comment">//c为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = k;  <span class="comment">//d为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) e = k <span class="comment">//e为int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i++) f; <span class="comment">//f 为int类型</span></span><br><span class="line">tecltype(f=k) g <span class="comment">//g为int&amp;类型，必须初始化</span></span><br></pre></td></tr></table></figure></p>
<h4 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h4><h5 id="const和引用"><a href="#const和引用" class="headerlink" title="const和引用"></a>const和引用</h5><p>auto和const的推断与decltype不一样，对于auto，变量顶层的const会被忽略，只保留底层的const<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="keyword">int</span> ci=i,&amp;cr=i;</span><br><span class="line"><span class="keyword">auto</span> a=ci;      <span class="comment">//a为int（忽略顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> b=cr;      <span class="comment">//b为int（忽略顶层const，cr是引用）</span></span><br><span class="line"><span class="keyword">auto</span> c=&amp;i;      <span class="comment">//c为int *</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;ci;     <span class="comment">//d是pointer to const int(&amp;ci为底层const）</span></span><br><span class="line"><span class="comment">//要声明顶层const，前面要加上const关键字；要声明引用要加上&amp;标识符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f=ci; <span class="comment">//ci的推演类型是int,f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g=ci;<span class="comment">// g是一个绑定到ci的引用</span></span><br></pre></td></tr></table></figure></p>
<p>对于decltype，其对const和应用的处理如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x=<span class="number">0</span>;   <span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p=&amp;i,&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b; <span class="comment">//b为int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) y=x;   <span class="comment">//y的类型是const int&amp;，y绑定到x上</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之auto和decltype/" data-id="ciqbvirqa005ipsqyozclnsrx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之统一初始化和初始化器列表" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/" class="article-date">
  <time datetime="2016-07-06T10:43:47.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/">C++11常规特性之统一初始化和初始化器列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在c++11以前，程序员，或者初学者经常会感到疑惑关于怎样去初始化一个变量或者是一个对象。<br>初始化经常使用括号，或者是使用大括号，或者是复赋值操作。<br>因为这个原因，c++11提出了统一初始化，以为着使用这初始化列表，下面的做法都是正确的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value[] &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi &#123;<span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">56</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; cities &#123;<span class="string">"Berlin"</span> , <span class="string">"New York "</span> , <span class="string">"london "</span> , <span class="string">"cairo"</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">4.0</span> , <span class="number">3.0</span>&#125;;  <span class="comment">//相当于c（4.0 ， 3.0）；</span></span><br></pre></td></tr></table></figure></p>
<p>一个初始化列表强制使用赋值操作， 也就是为每个变量设置一个默认的初始化值，被初始化为0（NULL 或者是 nullptr）<br>如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">//这是一个未定义的行为</span></span><br><span class="line"><span class="keyword">int</span> i&#123;&#125;； <span class="comment">//i调用默认的构造函数为i赋值为0</span></span><br><span class="line"><span class="keyword">int</span> *p； <span class="comment">//这是一个未定义的行为</span></span><br><span class="line"><span class="keyword">int</span> *p&#123;&#125; ;<span class="comment">// p被初始化为一个nullptr</span></span><br></pre></td></tr></table></figure></p>
<p>初始化类表不会进行隐式转换<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  x1（<span class="number">5.3</span>）； <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5.3</span> <span class="comment">//5</span></span><br><span class="line"><span class="keyword">int</span> xi&#123;<span class="number">5.0</span>&#125; <span class="comment">//精确地   所以会出现error</span></span><br><span class="line"><span class="keyword">int</span> x4 = &#123;<span class="number">5.3</span>&#125; <span class="comment">// 精确地   所以会出现error</span></span><br><span class="line"><span class="keyword">char</span> ci&#123;<span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c9&#123;<span class="number">9999</span>&#125;; <span class="comment">//error  9999不合适是一个char类型</span></span><br></pre></td></tr></table></figure></p>
<p>如果是自己想实现初始化列表构造函数，拷贝函数，赋值函数，需要包含initializer_list 这个头文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> a):a_(a)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"normal initializer list\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass(<span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; a):b_(a) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"initializer list constructor\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass(MyClass&amp; my) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor\n"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a_ = my.a_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b_ = my.b_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; my) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"operator = constructor\n"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a_ = my.a_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b_ = my.b_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是初始化以及输出结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyClass ma&#123;<span class="number">1</span>&#125;;               <span class="comment">// (a)</span></span><br><span class="line">MyClass mb = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;      <span class="comment">// (b)</span></span><br><span class="line"><span class="function">MyClass <span class="title">mc</span><span class="params">(<span class="number">2</span>)</span></span>;               <span class="comment">// (c)</span></span><br><span class="line">MyClass md = b;              <span class="comment">// (d)</span></span><br><span class="line"><span class="function">MyClass <span class="title">me</span><span class="params">(c)</span></span>;               <span class="comment">// (e)</span></span><br><span class="line">MyClass mf&#123;e&#125;;               <span class="comment">// (f)</span></span><br><span class="line"><span class="keyword">auto</span> l&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">MyClass mh&#123;l&#125;;               <span class="comment">// (e)</span></span><br><span class="line">ma = mb;                     <span class="comment">// (h)</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initializer list <span class="function"><span class="keyword">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">initializer</span> <span class="title">list</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">normal</span> <span class="title">constructor</span> <span class="title">list</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">copy</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">initializer</span> <span class="title">list</span> <span class="title">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title">operator</span> = <span class="title">constructor</span></span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之统一初始化和初始化器列表/" data-id="ciqbvirq00052psqy0c0v8x51" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之右值引用和move语义" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之右值引用和move语义/" class="article-date">
  <time datetime="2016-07-06T10:43:33.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之右值引用和move语义/">C++11常规特性之右值引用和move语义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++11加入了右值引用(rvalue reference)的概念（用&amp;&amp;标识），用来区分对左值和右值的引用。左值就是一个有名字的对象，而右值则是一个无名对象（临时对象）。move语义允许修改右值（以前右值被看作是不可修改的，等同于const T&amp;类型）。<br>C++的class或者struct以前都有一些隐含的成员函数：默认构造函数（仅当没有显示定义任何其他构造函数时才存在），拷贝构造函数，析构函数还有拷贝赋值操作符。拷贝构造函数和拷贝赋值操作符提供bit-wise的拷贝（浅拷贝），也就是逐个bit拷贝对象。也就是说，如果你有一个类包含指向其他对象的指针，拷贝时只会拷贝指针的值而不会管指向的对象。在某些情况下这种做法是没问题的，但在很多情况下，实际上你需要的是深拷贝，也就是说你希望拷贝指针所指向的对象。而不是拷贝指针的值。这种情况下，你需要显示地提供拷贝构造函数与拷贝赋值操作符来进行深拷贝。</p>
<p>如果你用来初始化或拷贝的源对象是个右值（临时对象）会怎么样呢？你仍然需要拷贝它的值，但随后很快右值就会被释放。这意味着产生了额外的操作开销，包括原本并不需要的空间分配以及内存拷贝。</p>
<p>现在说说move constructor和move assignment operator。这两个函数接收T&amp;&amp;类型的参数，也就是一个右值。在这种情况下，它们可以修改右值对象，例如“偷走”它们内部指针所指向的对象。举个例子，一个容器的实现（例如vector或者queue）可能包含一个指向元素数组的指针。当用一个临时对象初始化一个对象时，我们不需要分配另一个数组，从临时对象中把值复制过来，然后在临时对象析构时释放它的内存。我们只需要将指向数组内存的指针值复制过来，由此节约了一次内存分配，一次元数组的复制以及后来的内存释放。</p>
<p>以下代码实现了一个简易的buffer。这个buffer有一个成员记录buffer名称（为了便于以下的说明），一个指针（封装在unique_ptr中）指向元素为T类型的数组，还有一个记录数组长度的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// default constructor</span></span><br><span class="line">   Buffer():</span><br><span class="line">      _size(<span class="number">16</span>),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[<span class="number">16</span>])</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">size_t</span> size):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[size])</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[copy._size])</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Buffer&amp; copy)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> != ©)</span><br><span class="line">      &#123;</span><br><span class="line">         _name = copy._name;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(_size != copy._size)</span><br><span class="line">         &#123;</span><br><span class="line">            _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">            _size = copy._size;</span><br><span class="line">            _buffer = _size &gt; <span class="number">0</span> &gt; <span class="keyword">new</span> T[_size] : <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         T* source = copy._buffer.get();</span><br><span class="line">         T* dest = _buffer.get();</span><br><span class="line">         <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):</span><br><span class="line">      _name(<span class="built_in">std</span>::move(temp._name)),</span><br><span class="line">      _size(temp._size),</span><br><span class="line">      _buffer(<span class="built_in">std</span>::move(temp._buffer))</span><br><span class="line">   &#123;</span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; temp)</span><br><span class="line">   &#123;</span><br><span class="line">      assert(<span class="keyword">this</span> != &amp;temp); <span class="comment">// assert if this is not a temporary</span></span><br><span class="line"></span><br><span class="line">      _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      _size = temp._size;</span><br><span class="line">      _buffer = <span class="built_in">std</span>::move(temp._buffer);</span><br><span class="line"></span><br><span class="line">      _name = <span class="built_in">std</span>::move(temp._name);</span><br><span class="line"></span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Buffer&lt;T&gt; getBuffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">   Buffer&lt;T&gt; b(name, <span class="number">128</span>);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b1;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b2(<span class="string">"buf2"</span>, <span class="number">64</span>);</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b3 = b2;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b4 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf4"</span>);</span><br><span class="line">   b1 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf5"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的copy constructor以及copy assignment operator大家应该很熟悉了。C++11中新增的是move constructor以及move assignment operator，这两个函数根据上文所描述的move语义实现。如果你运行这段代码，你就会发现b4构造时，move constructor会被调用。同样，对b1赋值时，move assignment operator会被调用。原因就在于getBuffer()的返回值是一个临时对象——也就是右值。</p>
<p>你也许注意到了，move constuctor中当我们初始化变量name和指向buffer的指针时，我们使用了std::move。name实际上是一个string，std::string实现了move语义。std::unique_ptr也一样。但是如果我们写_name(temp._name)，那么copy constructor将会被调用。不过对于_buffer来说不能这么写，因为std::unique_ptr没有copy constructor。但为什么std::string的move constructor此时没有被调到呢？这是因为虽然我们使用一个右值调用了Buffer的move constructor，但在这个构造函数内，它实际上是个左值。为什么？因为它是有名字的——“temp”。一个有名字的对象就是左值。为了再把它变为右值（以便调用move constructor)必须使用std::move。这个函数仅仅是把一个左值引用变为一个右值引用。</p>
<p>更新：虽然这个例子是为了说明如何实现move constructor以及move assignment operator，但具体的实现方式并不是唯一的。在本文的回复中Member 7805758同学提供了另一种可能的实现。为了方便查看，我把它也列在下面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = <span class="string">""</span>, <span class="keyword">size_t</span> size = <span class="number">16</span>):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(size? <span class="keyword">new</span> T[size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(copy._size? <span class="keyword">new</span> T[copy._size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer copy)</span><br><span class="line">   &#123;</span><br><span class="line">       swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):Buffer()</span><br><span class="line">   &#123;</span><br><span class="line">      swap(*<span class="keyword">this</span>, temp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; first, Buffer&amp; second)</span> <span class="keyword">noexcept</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">       swap(first._name  , second._name);</span><br><span class="line">       swap(first._size  , second._size);</span><br><span class="line">       swap(first._buffer, second._buffer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>move语义不仅仅用于右值，也用于左值。标准库提供了std::move方法，将左值转换成右值。因此，对于swap函数，我们可以这样实现<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    T temp(st<span class="number">d::</span>move(a))<span class="comment">;</span></span><br><span class="line">    a = st<span class="number">d::</span>move(b)<span class="comment">;</span></span><br><span class="line">    b = st<span class="number">d::</span>move(temp)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.jobbole.com/44015/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之右值引用和move语义/" data-id="ciqbvirq20056psqyepdv31w7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之lambda" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之lambda/" class="article-date">
  <time datetime="2016-07-06T10:42:44.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之lambda/">C++11常规特性之lambda</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多语言都提供了 lambda 表达式，如 Python，Java 8。lambda 表达式可以方便地构造匿名函数，如果你的代码里面存在大量的小函数，而这些函数一般只被调用一次，那么不妨将他们重构成 lambda 表达式。举一个例子。标准 C++ 库中有一个常用算法的库，其中提供了很多算法函数，比如 sort() 和 find()。这些函数通常需要提供一个“谓词函数 predicate function”。所谓谓词函数，就是进行一个操作用的临时函数。比如 find() 需要一个谓词，用于查找元素满足的条件；能够满足谓词函数的元素才会被查找出来。这样的谓词函数，使用临时的匿名函数，既可以减少函数数量，又会让代码变得清晰易读。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="keyword">mutable</span>:当capture为传值的时候，函数不能修改外部的局部变量，如果需要修改，可以使用该关键字，</span><br><span class="line">        但是由于是传值，即使修改，也不会影响到capture的变量；传引用的时候，是可以修改变量的</span><br><span class="line">        而且会影响到所capture的变量</span><br><span class="line"><span class="keyword">exception</span>：说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f<span class="literal">()</span> throw(<span class="type">X</span>, <span class="type">Y</span>)。</span><br><span class="line">attribute: 用来声明属性</span><br><span class="line">returnType: lambda函数的返回类型，可以不需要，lambda可以根据返回表达式自己推导</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">exception</span> attribute三个属性可以省略</span><br><span class="line"></span><br><span class="line">capture 指定了在可见域范围内 lambda 表达式的代码内可见得外部变量的列表，具体解释如下：</span><br><span class="line">[a,&amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获。</span><br><span class="line">[this] 以值的方式捕获 this 指针。</span><br><span class="line">[&amp;] 以引用的方式捕获所有的外部自动变量。</span><br><span class="line">[=] 以值的方式捕获所有的外部自动变量。</span><br><span class="line"><span class="literal">[]</span> 不捕获外部的任何变量。</span><br><span class="line">*/</span><br><span class="line">[ capture ] ( params ) <span class="keyword">mutable</span> <span class="keyword">exception</span> attribute -&gt; returnType &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [](<span class="keyword">float</span> f) &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [](<span class="keyword">float</span> f) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们想引用一个 lambda 表达式时，我们可以使用auto关键字</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [] () -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> val * <span class="number">100</span>; &#125;;</span><br><span class="line"><span class="comment">//auto关键字实际会将 lambda表达式转换成一种类似于std::function的内部类型</span></span><br><span class="line"><span class="comment">//（但并不是std::function类型，虽然与std::function“兼容”）。所以，我们也可以这么写：</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>()&gt; lambda = [] () -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> val * <span class="number">100</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传值方式，改变capture变量</span></span><br><span class="line"><span class="keyword">float</span> f0 = <span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; [=](<span class="keyword">float</span> f) <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> f0 += <span class="built_in">std</span>::<span class="built_in">abs</span>(f); &#125; (-<span class="number">3.5</span>); <span class="comment">//f0仍然是1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。</span></span><br><span class="line"><span class="comment">//但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</span></span><br><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;someFunc(); &#125;();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之lambda/" data-id="ciqbvirq6005fpsqyw1ep23o4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之noexcept" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之noexcept/" class="article-date">
  <time datetime="2016-07-06T10:42:33.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之noexcept/">C++11常规特性之noexcept</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在异常处理的代码中，程序员有可能看到过如下的异常声明表达形式：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> excpt_func() <span class="keyword">throw</span>(<span class="keyword">int</span>, <span class="keyword">double</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>在excpt_func函数声明之后，我们定义了一个动态异常声明throw(int, double)，该声明指出了excpt_func可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了（参见附录B），而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。</p>
<p>noexcept形如其名地，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行，这比基于异常机制的throw()在效率上会高一些。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。</p>
<p>从语法上讲，noexcept修饰符有两种形式，一种就是简单地在函数声明后加上noexcept关键字。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>另外一种则可以接受一个常量表达式作为参数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>常量表达式的结果会被转换成一个bool类型的值。该值为true，表示函数不会抛出异常，反之，则有可能抛出异常。这里，不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。</p>
<p>在通常情况下，在C++11中使用noexcept可以有效地阻止异常的传播与扩散。我们可以看看下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Throw</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NoBlockThrow</span><span class="params">()</span> </span>&#123; Throw(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; Throw(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Throw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw."</span> &lt;&lt; endl;     <span class="comment">// Found throw.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NoBlockThrow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Throw is not blocked."</span> &lt;&lt; endl;    <span class="comment">// Throw is not blocked.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BlockThrow();   <span class="comment">// terminate called after throwing an instance of 'int'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Found throw 1."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项:g++ -std=c++11 2-6-1.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码清单2-12中，我们定义了Throw函数，该函数的唯一作用是抛出一个异常。而NoBlockThrow是一个调用Throw的普通函数，BlockThrow则是一个noexcept修饰的函数。从main的运行中我们可以看到，NoBlockThrow会让Throw函数抛出的异常继续抛出，直到main中的catch语句将其捕捉。而BlockThrow则会直接调用std::terminate中断程序的执行，从而阻止了异常的继续传播。从使用效果上看，这与C++98中的throw()是一样的。<br>而noexcept作为一个操作符时，通常可以用于模板。比如：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  void <span class="function"><span class="keyword">fun</span>() <span class="title">noexcept</span></span>(noexcept(<span class="constant">T</span>())) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式的时候，其返回值为false，反之为true（实际noexcept参数返回false还包括一些情况，这里就不展开讲了）。这样一来，我们就可以使模板函数根据条件实现noexcept修饰的版本或无noexcept修饰的版本。从泛型编程的角度看来，这样的设计保证了关于“函数是否抛出异常”这样的问题可以通过表达式进行推导。因此这也可以视作C++11为了更好地支持泛型编程而引入的特性。</p>
<p>虽然noexcept修饰的函数通过std::terminate的调用来结束程序的执行的方式可能会带来很多问题，比如无法保证对象的析构函数的正常调用，无法保证栈的自动释放等，但很多时候，“暴力”地终止整个程序确实是很简单有效的做法。事实上，noexcept被广泛地、系统地应用在C++11的标准库中，用于提高标准库的性能，以及满足一些阻止异常扩散的需求。</p>
<p>比如在C++98中，存在着使用throw()来声明不抛出异常的函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用noexcept来替换throw()。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">min</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">max</span><span class="params">()</span> <span class="keyword">noexcept</span>  </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> T <span class="title">lowest</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> T(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>又比如，在C++98中，new可能会包含一些抛出的std::bad_alloc异常。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc);</span><br></pre></td></tr></table></figure></p>
<p>而在C++11中，则使用noexcept(false)来进行替代。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">noexcept</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然，noexcept更大的作用是保证应用程序的安全。比如一个类析构函数不应该抛出异常，那么对于常被析构函数调用的delete函数来说，C++11默认将delete函数设置成noexcept，就可以提高应用程序的安全性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>而同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的。当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持默认值。我们可以看看下面的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> A &#123;</span><br><span class="line">    ~A() &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> B &#123;</span><br><span class="line">    ~B() <span class="keyword">noexcept</span>(<span class="literal">false</span>) &#123; <span class="keyword">throw</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> C &#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funA</span><span class="params">()</span> </span>&#123; A a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funB</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funC</span><span class="params">()</span> </span>&#123; C c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funB."</span> &lt;&lt; endl; <span class="comment">// caught funB.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funC."</span> &lt;&lt; endl; <span class="comment">// caught funC.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        funA(); <span class="comment">// terminate called after throwing an instance of 'int'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"caught funA."</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译选项:g++ -std=c++11 2-6-2.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中，无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。这在实际的使用中，应该引起程序员的注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之noexcept/" data-id="ciqbvirq5005cpsqyyl8dl9mw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-11常规特性之其他一些新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之其他一些新特性/" class="article-date">
  <time datetime="2016-07-06T04:01:15.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之其他一些新特性/">C++11常规特性之其他一些新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++11有很多的新特性，这里只记录一下一些比较会常用到的新特性，有：auto和decltype、nullptr、noexcept、lambda、基于范围的for语句、初始化器列表、右值引用和move语义、constexpr、override和final、强类型枚举（Strong-type enums）、智能指针（Smart Pointers）、非成员begin()和end()以及static_assert和type traits</p>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>以前都是用0来表示空指针的，但由于0可以被隐式类型转换为整形，这就会存在一些问题。关键字nullptr是std::nullptr_t类型的值，用来指代空指针。nullptr和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。但是为了向前兼容，0仍然是个合法的空指针值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="literal">nullptr</span>;   </span><br><span class="line"><span class="keyword">if</span>(p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">nullptr</span>);</span><br><span class="line">bar(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="literal">nullptr</span>; <span class="comment">// error: A native nullptr can only be converted to bool or, using reinterpret_cast, to an integral type</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Range-based-for-loops-（基于范围的for循环）"><a href="#Range-based-for-loops-（基于范围的for循环）" class="headerlink" title="Range-based for loops （基于范围的for循环）"></a>Range-based for loops （基于范围的for循环）</h3><p>为了在遍历容器时支持”foreach”用法，C++11扩展了for语句的语法。用这个新的写法，可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> x : &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span> &#125;) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v) ++x;  <span class="comment">// using a reference to allow us to change the value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr) &#123;e=e*e;&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="constexpr和const"><a href="#constexpr和const" class="headerlink" title="constexpr和const"></a>constexpr和const</h3><p>const并未区分出编译期常量和运行期常量<br>constexpr限定在了编译期常量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">// 如果size()是常量表达式则编译通过，否则报错</span></span><br></pre></td></tr></table></figure></p>
<p>constexpr修饰的函数，返回值不一定是编译期常量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(5)&gt; arr; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    foo(i); <span class="comment">// Call is Ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// But...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(i)&gt; arr1; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了。不过，我们不必因此而写两个版本，所以如果函数体适用于constexpr函数的条件，可以尽量加上constexpr。</p>
<p>而检测constexpr函数是否产生编译时期值的方法很简单，就是利用std::array需要编译期常值才能编译通过的小技巧。这样的话，即可检测你所写的函数是否真的产生编译期常值了。</p>
<p>以上内容来自<a href="https://www.zhihu.com/question/35614219/answer/63798713" target="_blank" rel="external">知乎</a></p>
<p>通常，我们希望编译时期计算可以保护全局或者名字空间内的对象，对名字空间内的对象，我们希望它保存在只读空间内。<br>对于那些构造函数比较简单，可以成为常量表达式（也就是可以使用constexpr进行修饰）的对象可以做到这一点<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">      <span class="keyword">int</span> x,y;</span><br><span class="line">      constexpr Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy) : x(xx), y(yy) &#123; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  constexpr <span class="function">Point <span class="title">origo</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  constexpr <span class="keyword">int</span> z = origo.x;</span><br><span class="line">  constexpr Point a[] = &#123;Point(<span class="number">0</span>,<span class="number">0</span>), Point(<span class="number">1</span>,<span class="number">1</span>), Point(<span class="number">2</span>,<span class="number">2</span>) &#125;;</span><br><span class="line">  constexpr <span class="keyword">int</span> x = a[<span class="number">1</span>].x;   <span class="comment">// x becomes 1</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>const的主要功能是修饰一个对象而不是通过一个接口（即使对象很容易通过其他接口修改）。只不过声明一个对象常量为编译器提供了优化的机会。特别是，如果一个声明了一个对象常量而他的地址没有取到，编译器通常可以在编译时对他进行初始化（尽管这不是肯定的）保证这个对象在他的列表里而不是把它添加到生成代码里。</li>
<li>constexpr的主要功能可以在编译时计算表达式的值进行了范围扩展，这是一种计算安全而且可以用在编译时期（如初始化枚举或者整体模板参数）。constexpr声明对象可以在初始化编译的时候计算出结果来。他们基本上只保存在编译器的列表，如果需要的话会释放到生成的代码里。</li>
</ol>
<p>以上内容来自<a href="http://blog.jobbole.com/55063/" target="_blank" rel="external">知乎</a></p>
<h3 id="override和final"><a href="#override和final" class="headerlink" title="override和final"></a>override和final</h3><p>我总觉得C++中虚函数的设计很差劲，因为时至今日仍然没有一个强制的机制来标识虚函数会在派生类里被改写。vitual关键字是可选的，这使得阅读代码变得很费劲。因为可能需要追溯到继承体系的源头才能确定某个方法是否是虚函数。为了增加可读性，我总是在派生类里也写上virtual关键字，并且也鼓励大家都这么做。即使这样，仍然会产生一些微妙的错误。看下面这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>D::f 按理应当重写 B::f。然而二者的声明是不同的，一个参数是short，另一个是int。因此D::f（原文为B::f，可能是作者笔误——译者注）只是拥有同样名字的另一个函数（重载）而不是重写。当你通过B类型的指针调用f()可能会期望打印出D::f，但实际上则会打出 B::f 。</p>
<p>另一个很微妙的错误情况：参数相同，但是基类的函数是const的，派生类的函数却不是。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f "</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>同样，这两个函数是重载而不是重写，所以你通过B类型指针调用f()将打印B::f，而不是D::f。</p>
<p>幸运的是，现在有一种方式能描述你的意图。新标准加入了两个新的标识符（不是关键字）:：</p>
<ol>
<li>override，表示函数应当重写基类中的虚函数。</li>
<li>final，表示派生类不应当重写这个虚函数。<br>第一个的例子如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在这将触发一个编译错误（后面那个例子，如果也写上override标识，会得到相同的错误提示）：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'D::f' : <span class="keyword">method</span> <span class="keyword">with</span> override specifier 'override' did <span class="keyword">not</span> override <span class="type">any</span> base class methods</span><br></pre></td></tr></table></figure></p>
<p>另一方面，如果你希望函数不要再被派生类进一步重写，你可以把它标识为final。可以在基类或任何派生类中使用final。在派生类中，可以同时使用override和final标识。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override final </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"D::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> F : <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"F::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>被标记成final的函数将不能再被F::f重写。</p>
<h3 id="Strongly-typed-enums-强类型枚举"><a href="#Strongly-typed-enums-强类型枚举" class="headerlink" title="Strongly-typed enums 强类型枚举"></a>Strongly-typed enums 强类型枚举</h3><p>传统的C++枚举类型存在一些缺陷：它们会将枚举常量暴露在外层作用域中（这可能导致名字冲突，如果同一个作用域中存在两个不同的枚举类型，但是具有相同的枚举常量就会冲突），而且它们会被隐式转换为整形，无法拥有特定的用户定义类型。</p>
<p>在C++11中通过引入了一个称为强类型枚举的新类型，修正了这种情况。强类型枚举由关键字enum class标识。它不会将枚举常量暴露到外层作用域中，也不会隐式转换为整形，并且拥有用户指定的特定类型（传统枚举也增加了这个性质）。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Options</span> &#123;<span class="title">None</span>, <span class="title">One</span>, <span class="title">All</span>&#125;;</span></span><br><span class="line"><span class="constant">Options</span> o = <span class="constant">Options::All</span>;</span><br></pre></td></tr></table></figure></p>
<p>在标准C++中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。C++03 唯一提供的安全机制是一个整数或一个枚举型值不能隐式转换到另一个枚举别型。 此外，枚举所使用整数类型及其大小都由实现方法定义，皆无法明确指定。 最后，枚举的名称全数暴露于一般范围中，因此C++03两个不同的枚举，不可以有相同的枚举名。 (好比 enum Side{ Right, Left }; 和 enum Thing{ Wrong, Right }; 不能一起使用。)<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Enumeration</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="constant">Val1</span>,</span><br><span class="line">  <span class="constant">Val2</span>,</span><br><span class="line">  <span class="constant">Val3</span> = <span class="number">100</span>,</span><br><span class="line">  <span class="constant">Val4</span> /* = <span class="number">101</span> *<span class="regexp">/,</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>此种枚举为类型安全的。枚举类型不能隐式地转换为整数；也无法与整数数值做比较。 (表示式 Enumeration::Val4 == 101 会触发编译期错误)。</p>
<p>枚举类型所使用类型必须显式指定。在上面的示例中，使用的是默认类型 int，但也可以指定其他类型：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">Enum2</span> : <span class="title">unsigned</span> <span class="title">int</span> &#123;<span class="title">Val1</span>, <span class="title">Val2</span>&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>枚举类型的语汇范围(scoping)定义于枚举类型的名称范围中。 使用枚举类型的枚举名时，必须明确指定其所属范围。 由前述枚举类型 Enum2 为例，Enum2::Val1是有意义的表示法， 而单独的 Val1 则否。</p>
<p>此外，C++11 允许为传统的枚举指定使用类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum3 : <span class="keyword">unsigned</span> <span class="keyword">long</span> &#123;Val1 = <span class="number">1</span>, Val2&#125;;</span><br></pre></td></tr></table></figure></p>
<p>枚举名 Val1 定义于 Enum3 的枚举范围中(Enum3::Val1)，但为了兼容性， Val1 仍然可以于一般的范围中单独使用。</p>
<p>在 C++11 中，枚举类型的前置声明 (forward declaration) 也是可行的，只要使用可指定类型的新式枚举即可。 之前的 C++ 无法写出枚举的前置声明，是由于无法确定枚举参数所占的空间大小， C++11 解决了这个问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum1;                     <span class="comment">// 不合法的 C++ 與 C++11; 無法判別大小</span></span><br><span class="line"><span class="keyword">enum</span> Enum2 : <span class="keyword">unsigned</span> <span class="keyword">int</span>;      <span class="comment">// 合法的 C++11</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Enum3;               <span class="comment">// 合法的 C++11，列舉類別使用預設型別 int</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Enum4: <span class="keyword">unsigned</span> <span class="keyword">int</span>; <span class="comment">// 合法的 C++11</span></span><br><span class="line"><span class="keyword">enum</span> Enum2 : <span class="keyword">unsigned</span> <span class="keyword">short</span>;    <span class="comment">// 不合法的 C++11，Enum2 已被聲明為 unsigned int</span></span><br></pre></td></tr></table></figure></p>
<h3 id="static-assert和-type-traits"><a href="#static-assert和-type-traits" class="headerlink" title="static_assert和 type traits"></a>static_assert和 type traits</h3><p>static_assert提供一个编译时的断言检查。如果断言为真，什么也不会发生。如果断言为假，编译器会打印一个特殊的错误信息。是在编译的时候进行断言，所以在实时编译的环境下编辑代码的时候，如果断言为假的话，就会直接提示错误<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sj = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static_assert</span>(sj&lt;<span class="number">9</span>, <span class="string">"Size is too small"</span>); <span class="comment">//OK and assert is true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// error 因为是在编译期的断言，所以在编译期必须能够对断言的内容进行确定，由于a是运行时动态确定的，所以这里编译错误</span></span><br><span class="line"><span class="keyword">static_assert</span>(a&lt;<span class="number">9</span>, <span class="string">"Size is too small"</span>);</span><br></pre></td></tr></table></figure></p>
<p>static_assert和type traits一起使用能发挥更大的威力。type traits是一些class，在编译时提供关于类型的信息。在头文件<type_traits>中可以找到它们。这个头文件中有好几种class: helper class，用来产生编译时常量。type traits class，用来在编译时获取类型信息，还有就是type transformation class，他们可以将已存在的类型变换为新的类型。</type_traits></p>
<p>下面这段代码原本期望只做用于整数类型。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">auto add<span class="function"><span class="params">(T1 t1, T2 t2)</span> -&gt;</span> decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果有人写出如下代码，编译器并不会报错<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"one"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>程序会打印出4.14和”e”。但是如果我们加上编译时断言，那么以上两行将产生编译错误。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="constant">T1,</span> typename <span class="constant">T2&gt;</span></span><br><span class="line">auto add(<span class="constant">T1 </span>t1, <span class="constant">T2 </span>t2) -&gt; decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line">   static_assert(<span class="symbol">std:</span><span class="symbol">:is_integral&lt;T1&gt;</span><span class="symbol">:</span><span class="symbol">:value</span>, <span class="string">"Type T1 must be integral"</span>);</span><br><span class="line">   static_assert(<span class="symbol">std:</span><span class="symbol">:is_integral&lt;T2&gt;</span><span class="symbol">:</span><span class="symbol">:value</span>, <span class="string">"Type T2 must be integral"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error</span> C2338: Type T2 must be integral</span><br><span class="line">see reference <span class="keyword">to</span> <span class="keyword">function</span> template instantiation <span class="comment">'T2 add<span class="xmlDocTag">&lt;int,double&gt;</span>(T1,T2)' being compiled</span></span><br><span class="line">   <span class="keyword">with</span></span><br><span class="line">   [</span><br><span class="line">      T2=<span class="built_in">double</span>,</span><br><span class="line">      T1=int</span><br><span class="line">   ]</span><br><span class="line"><span class="keyword">error</span> C2338: Type T1 must be integral</span><br><span class="line">see reference <span class="keyword">to</span> <span class="keyword">function</span> template instantiation <span class="comment">'T1 add<span class="xmlDocTag">&lt;const char*,int&gt;</span>(T1,T2)' being compiled</span></span><br><span class="line">   <span class="keyword">with</span></span><br><span class="line">   [</span><br><span class="line">      T1=<span class="keyword">const</span> <span class="built_in">char</span> *,</span><br><span class="line">      T2=int</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之其他一些新特性/" data-id="ciqbvirq40059psqyxf1i578a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-套接字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/套接字/" class="article-date">
  <time datetime="2016-07-02T06:37:39.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/套接字/">套接字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息队列、信号灯、共享内存等，都是基于Sys V的IPC机制进行讨论的，它们的应用局限在单一计算机内的进程间通信；基于BSD套接口不仅可以实现单机内的进程间通信，还可以实现不同计算机进程之间的通信。</p>
<p>一个套接口可以看作是进程间通信的端点（endpoint），每个套接口的名字都是唯一的（唯一的含义是不言而喻的），其他进程可以发现、连接并且与之通信。通信域用来说明套接口通信的协议，不同的通信域有不同的通信协议以及套接口的地址结构等等，因此，创建一个套接口时，要指明它的通信域。比较常见的是unix域套接口（采用套接口机制实现单机内的进程间通信）及网际通信域。</p>
<h3 id="1、背景知识"><a href="#1、背景知识" class="headerlink" title="1、背景知识"></a>1、背景知识</h3><p>linux目前的网络内核代码主要基于伯克利的BSD的unix实现，整个结构采用的是一种面向对象的分层机制。层与层之间有严格的接口定义。这里我们引用[1]中的一个图表来描述linux支持的一些通信协议：<br><img src="/pictures/Linux/进程间通信/共享内存-套接字通信协议.png" alt=""></p>
<p>我们这里只关心IPS，即因特网协议族，也就是通常所说的TCP/IP网络。我们这里假设读者具有网络方面的一些背景知识，如了解网络的分层结构，通常所说的7层结构；了解IP地址以及路由的一些基本知识。</p>
<p>目前linux网络API是基于BSD套接口的（系统V提供基于流I/O子系统的用户接口，但是linux内核目前不支持流I/O子系统）。套接口可以说是网络编程中一个非常重要的概念，linux以文件的形式实现套接口，与套接口相应的文件属于sockfs特殊文件系统，创建一个套接口就是在sockfs中创建一个特殊文件，并建立起为实现套接口功能的相关数据结构。换句话说，对每一个新创建的BSD套接口，linux内核都将在sockfs特殊文件系统中创建一个新的inode。描述套接口的数据结构是socket，将在后面给出。</p>
<h3 id="2、重要数据结构"><a href="#2、重要数据结构" class="headerlink" title="2、重要数据结构"></a>2、重要数据结构</h3><p>下面是在网络编程中比较重要的几个数据结构，读者可以在后面介绍编程API部分再回过头来了解它们。</p>
<h4 id="（1）表示套接口的数据结构struct-socket"><a href="#（1）表示套接口的数据结构struct-socket" class="headerlink" title="（1）表示套接口的数据结构struct socket"></a>（1）表示套接口的数据结构struct socket</h4><p>套接口是由socket数据结构代表的，形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket</span><br><span class="line">&#123;</span><br><span class="line">socket_state  state;     <span class="comment">/* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种</span><br><span class="line">套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>    flags;</span><br><span class="line">  <span class="keyword">struct</span> proto_ops  ops;  <span class="comment">/* 指明可对套接口进行的各种操作 */</span></span><br><span class="line">  <span class="keyword">struct</span> inode    inode;    <span class="comment">/* 指向sockfs文件系统中的相应inode */</span></span><br><span class="line">  <span class="keyword">struct</span> fasync_struct  *fasync_list;  <span class="comment">/* Asynchronous wake up list  */</span></span><br><span class="line">  <span class="keyword">struct</span> file    *file;          <span class="comment">/* 指向sockfs文件系统中的相应文件  */</span></span><br><span class="line"><span class="keyword">struct</span> sock    sk;  <span class="comment">/* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对</span><br><span class="line">象。 */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>  wait;</span><br><span class="line">  <span class="keyword">short</span>      type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>    passcred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（2）描述套接口通用地址的数据结构struct-sockaddr"><a href="#（2）描述套接口通用地址的数据结构struct-sockaddr" class="headerlink" title="（2）描述套接口通用地址的数据结构struct sockaddr"></a>（2）描述套接口通用地址的数据结构struct sockaddr</h4><p>由于历史的缘故，在bind、connect等系统调用中，特定于协议的套接口地址结构指针都要强制转换成该通用的套接口地址结构指针。结构形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr &#123;</span><br><span class="line">	<span class="keyword">sa_family_t</span>	sa_family;	<span class="comment">/* address family, AF_xxx	*/</span></span><br><span class="line">	<span class="keyword">char</span>		sa_data[<span class="number">14</span>];	<span class="comment">/* 14 bytes of protocol address	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）："><a href="#（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）：" class="headerlink" title="（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）："></a>（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in</span><br><span class="line">  &#123;</span><br><span class="line">    __SOCKADDR_COMMON (sin_);	<span class="comment">/* 描述协议族 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;			<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="keyword">struct</span> in_addr sin_addr;		<span class="comment">/* 因特网地址 */</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">			   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，读者最关心的是前三个域，即通信协议、端口号及地址。</p>
<h3 id="3、套接口编程的几个重要步骤："><a href="#3、套接口编程的几个重要步骤：" class="headerlink" title="3、套接口编程的几个重要步骤："></a>3、套接口编程的几个重要步骤：</h3><h4 id="（1）创建套接口，由系统调用socket实现："><a href="#（1）创建套接口，由系统调用socket实现：" class="headerlink" title="（1）创建套接口，由系统调用socket实现："></a>（1）创建套接口，由系统调用socket实现：</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> ptotocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数domain指明通信域，如PF_UNIX（unix域），PF_INET（IPv4），PF_INET6(IPv6)等；type指明通信类型，如SOCK_STREAM(面向连接方式)、SOCK_DGRAM(非面向连接方式)等。一般来说，参数protocol可设置为0，除非用在原始套接口上（原始套接口有一些特殊功能，后面还将介绍）。</p>
<p>注：socket（）系统调用为套接口在sockfs文件系统中分配一个新的文件和dentry对象，并通过文件描述符把它们与调用进程联系起来。进程可以像访问一个已经打开的文件一样访问套接口在sockfs中的对应文件。但进程绝不能调用open()来访问该文件（sockfs文件系统没有可视安装点，其中的文件永远不会出现在系统目录树上），当套接口被关闭时，内核会自动删除sockfs中的inodes。</p>
<h4 id="（2）绑定地址"><a href="#（2）绑定地址" class="headerlink" title="（2）绑定地址"></a>（2）绑定地址</h4><p>根据传输层协议（TCP、UDP）的不同，客户机及服务器的处理方式也有很大不同。但是，不管通信双方使用何种传输协议，都需要一种标识自己的机制。</p>
<p>通信双方一般由两个方面标识：地址和端口号（通常，一个IP地址和一个端口号常常被称为一个套接口）。根据地址可以寻址到主机，根据端口号则可以寻址到主机提供特定服务的进程，实际上，一个特定的端口号代表了一个提供特定服务的进程。</p>
<p>对于使用TCP传输协议通信方式来说，通信双方需要给自己绑定一个唯一标识自己的套接口，以便建立连接；对于使用UDP传输协议，只需要服务器绑定一个标识自己的套接口就可以了，用户则不需要绑定(在需要时，如调用connect时[注1]，内核会自动分配一个本地地址和本地端口号)。绑定操作由系统调用bind()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * my_addr, socklen_t my_addr_len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第二个参数对于Ipv4来说，实际上需要填充的结构是struct sockaddr_in，前面已经介绍了该结构。这里只想强调该结构的第一个域，它表明该套接口使用的通信协议，如AF_INET。联系socket系统调用的第一个参数，读者可能会想到PF_INET与AF_INET究竟有什么不同？实际上，原来的想法是每个通信域（如PF_INET）可能对应多个协议（如AF<em>INET），而事实上支持多个协议的通信域一直没有实现。因此，在linux内核中，AF</em><strong><em>与PF_</em></strong>被定义为同一个常数，因此，在编程时可以不加区分地使用他们。</p>
<p>注1：在采用非面向连接通信方式时，也会用到connect()调用，不过与在面向连接中的connect（）调用有本质的区别：在非面向连接通信中，connect调用只是先设置一下对方的地址，内核为本地套接口记下对方的地址，然后采用send()来发送数据，这样避免每次发送时都要提供相同的目的地址。其中的connect()调用不涉及握手过程；而在面向连接的通信方式中，connect()要完成一个严格的握手过程。</p>
<h4 id="（3）请求建立连接（由TCP客户发起）"><a href="#（3）请求建立连接（由TCP客户发起）" class="headerlink" title="（3）请求建立连接（由TCP客户发起）"></a>（3）请求建立连接（由TCP客户发起）</h4><p>对于采用面向连接的传输协议TCP实现通信来说，一个比较重要的步骤就是通信双方建立连接（如果采用udp传输协议则不需要），由系统调用connect()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * servaddr, socklen_t addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数为本地调用socket后返回的描述符，第二个参数为服务器的地址结构指针。connect（）向指定的套接口请求建立连接。</p>
<p>注：与connect（）相对应，在服务器端，通过系统调用listen()，指定服务器端的套接口为监听套接口，监听每一个向服务器套接口发出的连接请求，并通过握手机制建立连接。内核为listen()维护两个队列：已完成连接队列和未完成连接队列。</p>
<h4 id="（4）接受连接请求（由TCP服务器端发起）"><a href="#（4）接受连接请求（由TCP服务器端发起）" class="headerlink" title="（4）接受连接请求（由TCP服务器端发起）"></a>（4）接受连接请求（由TCP服务器端发起）</h4><p>服务器端通过监听套接口，为所有连接请求建立了两个队列：已完成连接队列和未完成连接队列（每个监听套接口都对应这样两个队列，当然，一般服务器只有一个监听套接口）。通过accept()调用，服务器将在监听套接口的已连接队列头中，返回用于代表当前连接的套接口描述字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr * cliaddr, socklen_t * addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数指明哪个监听套接口，一般是由listen（）系统调用指定的（由于每个监听套接口都对应已连接和未连接两个队列，因此它的内部机制实质是通过sockfd指定在哪个已连接队列头中返回一个用于当前客户的连接，如果相应的已连接队列为空，accept进入睡眠）。第二个参数指明客户的地址结构，如果对客户的身份不感兴趣，可指定其为空。</p>
<p>注：对于采用TCP传输协议进行通信的服务器和客户机来说，一定要经过客户请求建立连接，服务器接受连接请求这一过程；而对采用UDP传输协议的通信双方则不需要这一步骤。</p>
<h4 id="（5）通信"><a href="#（5）通信" class="headerlink" title="（5）通信"></a>（5）通信</h4><p>客户机可以通过套接口接收服务器传过来的数据，也可以通过套接口向服务器发送数据。前面所有的准备工作（创建套接口、绑定等操作）都是为这一步骤准备的。</p>
<p>常用的从套接口中接收数据的调用有：recv、recvfrom、recvmsg等，常用的向套接口中发送数据的调用有send、sendto、sendmsg等。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">void</span> *</span><br><span class="line">        buf, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvfrom</span>(<span class="params"><span class="keyword">int</span> s,  <span class="keyword">void</span> *</span><br><span class="line">        buf,  size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags, <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        <span class="keyword">from</span>, socklen_t *</span><br><span class="line">        fromlen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">send</span>(<span class="params"><span class="keyword">int</span> s,<span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendto</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        to, socklen_t</span><br><span class="line">        tolen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>这里不再对这些调用作具体的说明，只想强调一下，recvfrom（）以及recvmsg（）可用于面向连接的套接口，也可用于面向非连接的套接口；而recv（）一般用于面向连接的套接口。另外，在调用了connect()之后，就应给调用send()而不是sendto()了，因为调用了connect之后，目标就已经确定了。</p>
<p>前面讲到，socket（）系统调用返回套接口描述字，实际上它是一个文件描述符。所以，可以对套接口进行通常的读写操作，即使用read()及write()方法。在实际应用中，由于面向连接的通信（采用TCP传输协议）是可靠的，同时又保证字节流原有的顺序，所以更适合用read及write方法。而非面向连接的通信（采用UDP传输协议）是不可靠的，字节流也不一定保持原有的顺序，所以一般不宜用read及write方法。</p>
<h4 id="（6）通信的最后一步是关闭套接口"><a href="#（6）通信的最后一步是关闭套接口" class="headerlink" title="（6）通信的最后一步是关闭套接口"></a>（6）通信的最后一步是关闭套接口</h4><p>由close()来完成此项功能，它唯一的参数是套接口描述字，不再赘述。</p>
<h3 id="4、典型调用代码："><a href="#4、典型调用代码：" class="headerlink" title="4、典型调用代码："></a>4、典型调用代码：</h3><p>到处可以发现基于套接口的客户机及服务器程序，这里不再给出完整的范例代码，只是给出它们的典型调用代码，并给出简要说明。</p>
<h4 id="（1）典型的TCP服务器代码："><a href="#（1）典型的TCP服务器代码：" class="headerlink" title="（1）典型的TCP服务器代码："></a>（1）典型的TCP服务器代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="keyword">int</span> listen_fd, connect_fd;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in serv_addr, client_addr;</span><br><span class="line">... ...</span><br><span class="line">listen_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建网际Ipv4域的（由PF_INET指定）面向连接的（由SOCK_STREAM指定，</span><br><span class="line">如果创建非面向连接的套接口则指定为SOCK_DGRAM）</span><br><span class="line">的套接口。第三个参数0表示由内核确定缺省的传输协议，</span><br><span class="line">对于本例，由于创建的是可靠的面向连接的基于流的套接口，</span><br><span class="line">内核将选择TCP作为本套接口的传输协议） */</span></span><br><span class="line"></span><br><span class="line">bzero( &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr) );</span><br><span class="line">serv_addr.sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr.sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, &amp;serv_addr.sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">bind( listen_fd, (<span class="keyword">struct</span> sockaddr*) serv_addr, <span class="keyword">sizeof</span> ( <span class="keyword">struct</span> sockaddr_in )) ;</span><br><span class="line"><span class="comment">/* 实现绑定操作 */</span></span><br><span class="line">listen( listen_fd, max_num) ;</span><br><span class="line"><span class="comment">/* 套接口进入侦听状态，max_num规定了内核为此套接口排队的最大连接个数 */</span></span><br><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">... ...</span><br><span class="line">connect_fd = accept( listen_fd, (<span class="keyword">struct</span> sockaddr*)client_addr, &amp;len ) ; <span class="comment">/* 获得连接fd. */</span></span><br><span class="line">... ...					<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：端口号的分配是有一些惯例的，不同的端口号对应不同的服务或进程。比如一般都把端口号21分配给FTP服务器的TCP/IP实现。端口号一般分为3段，0-1023（受限的众所周知的端口，由分配数值的权威机构IANA管理），1024-49151（可以从IANA那里申请注册的端口），49152-65535（临时端口，这就是为什么代码中的端口号为49152）。</p>
<p>对于多字节整数在内存中有两种存储方式：一种是低字节在前，高字节在后，这样的存储顺序被称为低端字节序（little-endian）；高字节在前，低字节在后的存储顺序则被称为高端字节序（big-endian）。网络协议在处理多字节整数时，采用的是高端字节序，而不同的主机可能采用不同的字节序。因此在编程时一定要考虑主机字节序与网络字节序间的相互转换。这就是程序中使用htons函数的原因，它返回网络字节序的整数。</p>
<h4 id="（2）典型的TCP客户代码："><a href="#（2）典型的TCP客户代码：" class="headerlink" title="（2）典型的TCP客户代码："></a>（2）典型的TCP客户代码：</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">int socket_fd;</span><br><span class="line">struct sockaddr_in serv_addr ;</span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">socket_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">bzero( <span class="subst">&amp;</span>serv_addr, sizeof(serv_addr) );</span><br><span class="line">serv_addr<span class="built_in">.</span>sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr<span class="built_in">.</span>sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, <span class="subst">&amp;</span>serv_addr<span class="built_in">.</span>sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">connect( socket_fd, (struct sockaddr*)serv_addr, sizeof( serv_addr ) ) ; <span class="comment">/* 向服务器发起连接请求 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span>							<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<p>对比两段代码可以看出，许多调用是服务器或客户机所特有的。另外，对于非面向连接的传输协议，代码还有简单些，没有连接的发起请求和接收请求部分。</p>
<h3 id="5、网络编程中的其他重要概念"><a href="#5、网络编程中的其他重要概念" class="headerlink" title="5、网络编程中的其他重要概念"></a>5、网络编程中的其他重要概念</h3><p>下面列出了网络编程中的其他重要概念，基本上都是给出这些概念能够实现的功能，读者在编程过程中如果需要这些功能，可查阅相关概念。</p>
<h4 id="（1）、I-O复用的概念"><a href="#（1）、I-O复用的概念" class="headerlink" title="（1）、I/O复用的概念"></a>（1）、I/O复用的概念</h4><p>I/O复用提供一种能力，这种能力使得当一个I/O条件满足时，进程能够及时得到这个信息。I/O复用一般应用在进程需要处理多个描述字的场合。它的一个优势在于，进程不是阻塞在真正的I/O调用上，而是阻塞在select()调用上，select()可以同时处理多个描述字，如果它所处理的所有描述字的I/O都没有处于准备好的状态，那么将阻塞；如果有一个或多个描述字I/O处于准备好状态，则select()不阻塞，同时会根据准备好的特定描述字采取相应的I/O操作。</p>
<h4 id="（2）、Unix通信域"><a href="#（2）、Unix通信域" class="headerlink" title="（2）、Unix通信域"></a>（2）、Unix通信域</h4><p>前面主要介绍的是PF_INET通信域，实现网际间的进程间通信。基于Unix通信域（调用socket时指定通信域为PF_LOCAL即可）的套接口可以实现单机之间的进程间通信。采用Unix通信域套接口有几个好处：Unix通信域套接口通常是TCP套接口速度的两倍；另一个好处是，通过Unix通信域套接口可以实现在进程间传递描述字。所有可用描述字描述的对象，如文件、管道、有名管道及套接口等，在我们以某种方式得到该对象的描述字后，都可以通过基于Unix域的套接口来实现对描述字的传递。接收进程收到的描述字值不一定与发送进程传递的值一致（描述字是特定于进程的），但是特们指向内核文件表中相同的项。</p>
<h4 id="（3）、原始套接口"><a href="#（3）、原始套接口" class="headerlink" title="（3）、原始套接口"></a>（3）、原始套接口</h4><p>原始套接口提供一般套接口所不提供的功能：<br>原始套接口可以读写一些用于控制的控制协议分组，如ICMPv4等，进而可实现一些特殊功能。<br>原始套接口可以读写特殊的IPv4数据包。内核一般只处理几个特定协议字段的数据包，那么一些需要不同协议字段的数据包就需要通过原始套接口对其进行读写；<br>通过原始套接口可以构造自己的Ipv4头部，也是比较有意思的一点。</p>
<p>创建原始套接口需要root权限。</p>
<h4 id="（4）、对数据链路层的访问"><a href="#（4）、对数据链路层的访问" class="headerlink" title="（4）、对数据链路层的访问"></a>（4）、对数据链路层的访问</h4><p>对数据链路层的访问，使得用户可以侦听本地电缆上的所有分组，而不需要使用任何特殊的硬件设备，在linux下读取数据链路层分组需要创建SOCK_PACKET类型的套接口，并需要有root权限。</p>
<h4 id="（5）、带外数据（out-of-band-data）"><a href="#（5）、带外数据（out-of-band-data）" class="headerlink" title="（5）、带外数据（out-of-band data）"></a>（5）、带外数据（out-of-band data）</h4><p>如果有一些重要信息要立刻通过套接口发送（不经过排队），请查阅与带外数据相关的文献。</p>
<h4 id="（6）、多播"><a href="#（6）、多播" class="headerlink" title="（6）、多播"></a>（6）、多播</h4><p>linux内核支持多播，但是在默认状态下，多数linux系统都关闭了对多播的支持。因此，为了实现多播，可能需要重新配置并编译内核。具体请参考[4]及[2]。</p>
<p>结论：linux套接口编程的内容可以说是极大丰富，同时它涉及到许多的网络背景知识，有兴趣的读者可在[2]中找到比较系统而全面的介绍。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>Understanding the Linux Kernel, 2nd Edition, By Daniel P. Bovet, Marco Cesati , 对各主题阐述得重点突出，脉络清晰。网络部分分析集中在TCP/IP协议栈的数据连路层、网络层以及传输层。</li>
<li>UNIX网络编程第一卷：套接口API和X/Open传输接口API，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。不仅对套接口网络编程有极好的描述，而且极为详尽的阐述了相关的网络背景知识。不论是入门还是深入研究，都是不可多得的好资料。</li>
<li>Linux内核源代码情景分析（下），毛德操、胡希明著，浙江大学出版社，给出了unix域套接口部分的内核代码分析。</li>
<li>GNU/Linux编程指南，入门、应用、精通，第二版，Kurt Wall等著，张辉译</li>
</ol>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part6/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/套接字/" data-id="ciqbvirmc001jpsqy4ks6towc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/07/设计模式之单例模式/">设计模式之单例模式</a>
          </li>
        
          <li>
            <a href="/2016/07/06/设计模式之观察者模式/">设计模式之观察者模式</a>
          </li>
        
          <li>
            <a href="/2016/07/06/设计模式之工厂模式/">设计模式之工厂模式</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之auto和decltype/">C++11常规特性之auto和decltype</a>
          </li>
        
          <li>
            <a href="/2016/07/06/C-11常规特性之统一初始化和初始化器列表/">C++11常规特性之统一初始化和初始化器列表</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>