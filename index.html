<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ICMP-协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/ICMP-协议/" class="article-date">
  <time datetime="2016-04-26T12:05:10.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/ICMP-协议/">ICMP 协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ICMP 经常被认为是 IP 层的一个组成部分，它传递差错报文以及其他需要注意的信息。ICMP 报文通常被 IP 层或更高层协议(TCP 或 UDP)使用。ICMP 报文是在 IP 数据报内部传输的。IP 协议是不可靠协议，不能保证 IP 数据报能够成功的到达目的主机，无法进行差错控制，而 ICMP 协议能够协助 IP 协议完成这些功能。下面是 ICMP 报文的数据结构：</p>
<p>类型：一个 8 位类型字段，表示 ICMP 数据包类型;</p>
<p>代码：一个 8 位代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0;</p>
<p>检验和：数据包中 ICMP 部分上的一个 16 位检验和;</p>
<p><img src="/pictures/ICMP协议/计算机网络/ICMP报文格式.png" alt=""></p>
<p>以下针对 ICMP 差错报文的类型进行分析：</p>
<p>1、ICMP 目标不可达消息：IP 路由器无法将 IP 数据报发送给目的地址时，会给发送端主机返回一个目标不可达 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>2、ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。</p>
<p>3、ICMP 超时消息：IP 数据包中有一个字段 TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减 1，直到减到 0 时该 IP 数据包被丢弃。此时，IP 路由器将发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>4、源抑制消息：当 TCP/IP 主机发送数据到另一主机时，如果速度达到路由器或者链路的饱和状态，路由器发出一个 ICMP 源抑制消息。</p>
<h4 id="ICMP-查询报文"><a href="#ICMP-查询报文" class="headerlink" title="ICMP 查询报文"></a>ICMP 查询报文</h4><p>ICMP 回送消息：用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。</p>
<p>ICMP 地址掩码消息：主要用于主机或路由想要了解子网掩码的情况。可以向那些主机或路由器发送 ICMP 地址掩码请求消息，然后通过接收 ICMP 地址掩码应答消息获取子网掩码信息。</p>
<p>ICMP 时间戳消息：可以向那些主机或路由器发送 ICMP 时间戳请求消息，然后通过接收 ICMP 时间戳应答消息获取时间信息。</p>
<h4 id="Ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序"></a>Ping 程序</h4><p>Ping 程序利用 ICMP 回显请求报文和回显应答报文(而不用经过传输层)来测试目标主机是否可达。它是一个检查系统连接性的基本诊断工具。</p>
<p>ICMP 回显请求和 ICMP 回显应答报文是配合工作的。当源主机向目标主机发送了 ICMP 回显请求数据包后，它期待着目标主机的回答。目标主机在收到一个 ICMP 回显请求数据包后，它会交换源、目的主机的地址，然后将收到的 ICMP 回显请求数据包中的数据部分原封不动地封装在自己的 ICMP 回显应答数据包中，然后发回给发送 ICMP 回显请求的一方。如果校验正确，发送者便认为目标主机的回显服务正常，也即物理连接畅通。</p>
<h4 id="Traceroute-程序"><a href="#Traceroute-程序" class="headerlink" title="Traceroute 程序"></a>Traceroute 程序</h4><p>Traceroute 程序主要用来侦测源主机到目的主机之间所经过的路由的情况。</p>
<p>Traceroute 使用 ICMP 报文和 IP 首部中的 TTL 字段，它充分利用了 ICMP 超时消息。其原理很简单，开始时发送一个 TTL 字段为 1 的 UDP 数据报，而后每次收到 ICMP 超时萧后，按顺序再发送一个 TTL 字段加 1 的 UDP 数据报，以确定路径中的每个路由器，而每个路由器在丢弃 UDP 数据报时都会返回一个 ICMP 超时报文，而最终到达目的主机后，由于 ICM P选择了一个不可能的值作为 UDP 端口(大于30000)。这样目的主机就会发送一个端口不可达的 ICMP 差错报文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/ICMP-协议/" data-id="cinhea1ov003zp0qy0wtntwiu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DDOS攻击简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/DDOS攻击简介/" class="article-date">
  <time datetime="2016-04-26T08:34:37.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/DDOS攻击简介/">DDOS攻击简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DDOs攻击主要有两种类型：流量攻击和占用服务器资源攻击</p>
<p>针对于TCP/IP协议的不同，ddos可以利用好几个协议的漏洞进行攻击。</p>
<h2 id="基于TCP协议的攻击"><a href="#基于TCP协议的攻击" class="headerlink" title="基于TCP协议的攻击"></a>基于TCP协议的攻击</h2><h4 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h4><p>基于TCP协议的攻击主要利用的是TCP的三次握手漏洞，由于TCP建立连接的时候需要三次握手，当服务器收到一个SYN包后，服务器会处于SYN_Received状态，并且在系统中保存半连接的数据，同时发送SYN-ACK包给客户端，但是此时客户端消失了，而处于这个状态的服务器会有一个定时器，在收不到客户端的回复的时候，会重新的发送SYN-ACk数据包（3-5次，并且等待一个SYN-time，一般是30秒到2分钟），此时半连接的数据一直占着系统资源，这样的话，如果有大量这种行为就会导致服务器资源被一直占用着，而正常连接行为的客户却得不到处理。这就是所谓的SYN攻击</p>
<h4 id="ACK-Flood-攻击"><a href="#ACK-Flood-攻击" class="headerlink" title="ACK Flood 攻击"></a>ACK Flood 攻击</h4><p>ACK Flood攻击是在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应RST包告诉对方此端口不存在。<br>这里，服务器要做两个动作：查表、回应 ACK/RST。这种攻击方式显然没有SYN Flood给服务器带来的冲击大，因此攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。按照我们对TCP协议的理解，随机源IP的ACK小包应该会被Server很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。但是实际上通过测试，发现有一些TCP服务会对ACK Flood比较敏感，比如说JSP Server，在数量并不多的ACK小包的打击下，JSP Server就很难处理正常的连接请求。对于Apache或者IIS来说，10kpps的ACK Flood不构成危胁，但是更高数量的ACK Flood会造成服务器网卡中断频率过高，负载过重而停止响应。可以肯定的是，ACK Flood不但可以危害路由器等网络设备，而且对服务器上的应用有不小的影响。</p>
<p>也有另外一种攻击：connection 攻击，就是大量的肉机与服务器建立连接，占用服务器的资源不放，而一台服务器的连接数量是有限的，大量的连接都被占用了，新的正常连接得不到服务。</p>
<h2 id="基于UDP的攻击"><a href="#基于UDP的攻击" class="headerlink" title="基于UDP的攻击"></a>基于UDP的攻击</h2><p>UDP Flood是日渐猖厥的流量型DoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。 100k pps的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。</p>
<h2 id="基于ICMP的攻击"><a href="#基于ICMP的攻击" class="headerlink" title="基于ICMP的攻击"></a>基于ICMP的攻击</h2><h4 id="死亡之ping"><a href="#死亡之ping" class="headerlink" title="死亡之ping"></a>死亡之ping</h4><p>IP协议规定IP包最大尺寸为65536，大部分的处理程序在处理IP包的时候，会假定报文不会超过最大的尺寸，利用该漏洞，可以发送大于65536的数据包，使得系统在处理报文的时候发生内存溢出，从而使得系统崩溃。这就是死亡之ping的实现原理，发送大于限制长度的报文来使得服务器出现系统奔溃</p>
<h4 id="echo攻击"><a href="#echo攻击" class="headerlink" title="echo攻击"></a>echo攻击</h4><p>利用ICMP的echo机制，对服务器发送大量的ICMP包，占用服务器的带宽，也可以利用ICMP的广播机制，将源端IP伪造成服务器的IP，向网络广播ICMP echo request，从而使得大量的网络机器向服务器发送ICMP echo应答包，占用服务器的大量带宽。</p>
<h4 id="针对链接的ICMP-DoS"><a href="#针对链接的ICMP-DoS" class="headerlink" title="针对链接的ICMP DoS"></a>针对链接的ICMP DoS</h4><p>针对连接的DoS攻击，可以终止现有的网络连接。针对网络连接的DoS攻击会影响所有的IP设备，因为它使用了合法的ICMP消息。Nuke通过发送一个伪造的ICMP Destination Unreachable或Redirect消息来终止合法的网络连接。更具恶意的攻击，如puke和smack，会给某一个范围内的端口发送大量的数据包，毁掉大量的网络连接，同时还会消耗受害主机CPU的时钟周期。</p>
<h4 id="基于ICMP重定向的路由欺骗技术"><a href="#基于ICMP重定向的路由欺骗技术" class="headerlink" title="基于ICMP重定向的路由欺骗技术"></a>基于ICMP重定向的路由欺骗技术</h4><p>攻击者可利用ICMP重定向报文破坏路由，并以此增强其窃听能力。除了路由器，主机必须服从ICMP重定向。如果一台机器想网络中的另一台机器发送了一个ICMP重定向消息，这就可能引起其他机器具有一张无效的路由表。如果一台机器伪装成路由器截获所有到某些目标网络或全部目标网络的IP数据包，这样就形成了窃听。通过ICMP技术还可以抵达防火墙后的机器进行攻击和窃听。</p>
<p>注：重定向路由欺骗技术尚无实际应用。</p>
<h2 id="HTTP-Get-攻击"><a href="#HTTP-Get-攻击" class="headerlink" title="HTTP Get 攻击"></a>HTTP Get 攻击</h2><p>这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQLServer、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。一般来说，提交一个GET或POST指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是很大的，常见的数据库服务器很少能支持数百个查询指令同时执行，而这对于客户端来说却是轻而易举的，因此攻击者只需通过Proxy代理向主机服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务，常见的现象就是网站慢如蜗牛、ASP程序失效、PHP连接数据库失败、数据库主程序占用CPU偏高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/DDOS攻击简介/" data-id="cinhea1ox0042p0qyz973n9vk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内网穿透简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/内网穿透简介/" class="article-date">
  <time datetime="2016-04-26T06:13:50.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/内网穿透简介/">内网穿透简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NAT的类型"><a href="#NAT的类型" class="headerlink" title="NAT的类型"></a>NAT的类型</h2><p>NAT一般有两种大的类型：cone（漏斗）类型和symmetric（对称）类型</p>
<h3 id="cone"><a href="#cone" class="headerlink" title="cone"></a>cone</h3><p>cone类型又分为三种小的类型，分别为：full cone、restricted cone和port restricted cone</p>
<p>在cone类型中，内网ip-port对在NAT中的映射是不变的，即使所访问的外网ip-port端口不一样，这也是其命名为cone的原因。</p>
<h4 id="full-cone"><a href="#full-cone" class="headerlink" title="full cone"></a>full cone</h4><p>full cone是限制最少的类型，在NAT服务器上，一个内网的ip-port对只映射到一个公网的ip-port对，而不管内网主机访问的外网ip-port对的不同。</p>
<h4 id="restricted-cone"><a href="#restricted-cone" class="headerlink" title="restricted cone"></a>restricted cone</h4><p>restricted cone相对于full cone类型增加了外网ip的限制，只有内网的机器访问了某个外网的机器，该外网机器的数据包才可以通过NAT的限制。在NAT的映射中，NAT维持一个映射关系：<br>{对端外网ip：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个外网ip的机器不同的port都可以通过该映射，从而实现与内网的通讯。</p>
<h4 id="port-restricted-cone"><a href="#port-restricted-cone" class="headerlink" title="port restricted cone"></a>port restricted cone</h4><p> port restricted cone类型在restricted cone类型的基础上增加了port的限制，必须又内网的机器访问外网机器的某个端口，该外网机器的对应端口发出的数据包才可以通过NAT。NAT维持的映射关系如下：<br> {对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个机器的特定端口才可以通过该映射。</p>
 <font color="red">注意，在以上的三种类型中，只要内网ip-port对不变，其在NAT的映射所对应的公网ip-port对就不会改变，也就是说，同一个内网ip-port在通讯过程中，其所对外的公网ip-port是不变的</font>

<h3 id="symmetric"><a href="#symmetric" class="headerlink" title="symmetric"></a>symmetric</h3><p>该类型的限制最严格，端口对端口的通讯都会有一个特定的映射，就拿port restricted cone来说，对于映射：{对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}， 只要是四元组中的内网ip：内网port不变，那么所有的四元组都会被映射到同一个{公网ip：公网port}，而在symmetric类型下，只要四元组中有一个是变化的，都会被映射到不同的而且唯一的{公网ip：公网port}。</p>
<p>cone 的映射是多对一的映射，类似于一个漏斗，而symmetric的映射是一个一对一的映射，也就是对称的映射。</p>
<h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p>根据NAT的类型不同，具体的实现细节也是不同的。但是不管是NAT类型不同，还是所采用的打洞技术不同，都需要使用到第三方服务器作为彼此信息的转发者。采用UDP来实现打洞，成功率会比较高，实现起来也比较容易。而采用TCP来打洞的话，成功率较低，而且实现起来会比较的麻烦，主要的原因就是对于TCP来说，既要打洞又要建立监听，而两者所使用的端口都是一样的，而且如果两端同时收到对端的SYN，那么两端都会处于SYN-Received状态，具体进一步的处理就要看不同的系统的TCP栈处理程序了，这个也就会导致TCP在打洞方面的成功率低于UDP。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/内网穿透简介/" data-id="cinhea1nd001qp0qys6hodva1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-typedef与define的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/typedef与define的区别/" class="article-date">
  <time datetime="2016-04-12T02:50:47.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/typedef与define的区别/">typedef与define的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef故名思意就是类型定义的意思，但是它并不是定义一个新的类型而是给已有的类型起一个别名，在这一点上与引用的含义类似，引用是变量或对象的别名，而typedef定义的是类型的别名。typedef的作用主要有两点：</p>
<h4 id="1-1-简化复杂的类型声明"><a href="#1-1-简化复杂的类型声明" class="headerlink" title="1.1  简化复杂的类型声明"></a>1.1  简化复杂的类型声明</h4><p>简化复杂的类型声明，或给已有类型起一含义明确的别名；如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个返回 bool 类型并带有两个(int和double)形参的函数的指针类型FuncPointer</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncPointer)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了一个FuncPointer类型的函数指针对象pFunc</span></span><br><span class="line">FuncPointer pFunc;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-定义与平台无关的类型"><a href="#1-2-定义与平台无关的类型" class="headerlink" title="1.2  定义与平台无关的类型"></a>1.2  定义与平台无关的类型</h4><p>定义与平台无关的类型，屏蔽不同平台的类型差异化；如：<br>用typedef来定义与平台无关的类型。<br>比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：<br>typedef long double REAL;<br>在不支持 long double 的平台二上，改为：<br>typedef double REAL;<br>在连 double 都不支持的平台三上，改为：<br>typedef float REAL;<br>也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。<br>标准库就广泛使用了这个技巧，比如size_t。另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健。</p>
<h4 id="1-3-与struct的结合使用"><a href="#1-3-与struct的结合使用" class="headerlink" title="1.3  与struct的结合使用"></a>1.3  与struct的结合使用</h4><p>在C++中，struct与class的作用相同，就是默认的访问权限不同，struct默认为public，而class默认为private的。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Person  </span><br><span class="line">&#123;  </span><br><span class="line">    string name<span class="comment">;  </span></span><br><span class="line">    int age<span class="comment">;  </span></span><br><span class="line">    float height<span class="comment">;  </span></span><br><span class="line">&#125;<span class="comment">;  </span></span><br><span class="line">Person person<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，定义一个Person的对象person。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，在定义的同时还声明了一个Person的对象person。</p>
<p>但是在C语言中，struct的定义和声明要用typedef。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;Person;    <span class="comment">//这是Person是结构体的一个别名  </span></span><br><span class="line">Person person;</span><br></pre></td></tr></table></figure></p>
<p>如果没有typedef就必须用struct Person person;来声明，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">struct</span> Person person;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;    <span class="comment">//person是Person的对象</span></span><br></pre></td></tr></table></figure></p>
<h2 id="typedef与-define的区别"><a href="#typedef与-define的区别" class="headerlink" title="typedef与#define的区别"></a>typedef与#define的区别</h2><h4 id="2-1-执行时间不同"><a href="#2-1-执行时间不同" class="headerlink" title="2.1.  执行时间不同"></a>2.1.  执行时间不同</h4><p>关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。</p>
<p>#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。<br>typedef会做相应的类型检查：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT value = <span class="string">"abc"</span>; <span class="comment">// error C2440: 'initializing' : cannot convert from 'const char [4]' to 'UINT'  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#define不做类型检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define用法例子：  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> f(x) x*x  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">6</span>, b=<span class="number">2</span>, c;  </span><br><span class="line">    c=f(a) / f(b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是: 36，根本原因就在于#define只是简单的字符串替换。</p>
<h4 id="2-2-功能有差异"><a href="#2-2-功能有差异" class="headerlink" title="2.2. 功能有差异"></a>2.2. 功能有差异</h4><p>typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。</p>
<p>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<h4 id="2-3．作用域不同"><a href="#2-3．作用域不同" class="headerlink" title="2.3．作用域不同"></a>2.3．作用域不同</h4><p>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。<br>而typedef有自己的作用域。</p>
<p>【例2.3.1】没有作用域的限制，只要是之前预定义过就可以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="preprocessor">#<span class="keyword">define</span> HW <span class="string">"HelloWorld"</span>;  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> str = HW;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【例<span class="number">2.3</span><span class="number">.2</span>】而<span class="keyword">typedef</span>有自己的作用域</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT uValue = <span class="number">5</span>;<span class="comment">//error C2065: 'UINT' : undeclared identifier  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例2.3.3】<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    typedef unsigned <span class="keyword">int</span> <span class="keyword">UINT</span>;  </span><br><span class="line">    <span class="keyword">UINT</span> valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">UINT</span> valueB;  </span><br><span class="line">    <span class="comment">//error C2146: syntax error : missing ';' before identifier 'valueB'  </span></span><br><span class="line">    <span class="comment">//error C4430: missing type specifier - int assumed. Note: C++ does not support default-int  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面例子在B类中使用UINT会出错，因为UINT只在类A的作用域中。此外，在类中用typedef定义的类型别名还具有相应的访问权限<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// error C2248: 'A::UINT' : cannot access private typedef declared in class 'A'  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而给UINT加上public访问权限后，则可编译通过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4．-对指针的操作"><a href="#2-4．-对指针的操作" class="headerlink" title="2.4． 对指针的操作"></a>2.4． 对指针的操作</h4><p>二者修饰指针类型时，作用不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * pint;  </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PINT int *  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;    <span class="comment">//p不可更改，p指向的内容可以更改，相当于 int * const p;  </span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;    <span class="comment">//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；  </span></span><br><span class="line"></span><br><span class="line">pint s1, s2;    <span class="comment">//s1和s2都是int型指针  </span></span><br><span class="line">PINT s3, s4;    <span class="comment">//相当于int * s3，s4；只有一个是指针。  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//p1 = &amp;i2; //error C3892: 'p1' : you cannot assign to a variable that is const  </span></span><br><span class="line">    *p1 = <span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//*p2 = 10; //error C3892: 'p2' : you cannot assign to a variable that is const  </span></span><br><span class="line">    p2 = &amp;i1;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">1</span></span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">5</span></span><br><span class="line">p2:<span class="number">00</span>EFD098  *p2:<span class="number">2</span></span><br><span class="line">p2:<span class="number">00</span>EFD094  *p2:<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.csdn.net/luoweifu/article/details/41630195" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/12/typedef与define的区别/" data-id="cinhea1ni001xp0qyaq0oxfr7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-epoll之ET和LT编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/epoll之ET和LT编程/" class="article-date">
  <time datetime="2016-04-07T07:45:11.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/epoll之ET和LT编程/">epoll之ET和LT编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK(注: EAGAIN就是EWOULDBLOCK)<br>从字面上看, 意思是:EAGAIN: 再试一次，EWOULDBLOCK: 如果这是一个阻塞socket, 操作将被block，perror输出: Resource temporarily unavailable</p>
<p>总结:<br>这个错误表示资源暂时不够，能read时，读缓冲区没有数据，或者write时，写缓冲区满了。遇到这种情况，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。<br>所以，对于阻塞socket，read/write返回-1代表网络出错了。但对于非阻塞socket，read/write返回-1不一定网络真的出错了。可能是Resource temporarily unavailable。这时你应该再试，直到Resource available。</p>
<p>综上，对于non-blocking的socket，正确的读写操作为:<br>读：忽略掉errno = EAGAIN的错误，下次继续读<br>写：忽略掉errno = EAGAIN的错误，下次继续写</p>
<p>对于select和epoll的LT模式，这种读写方式是没有问题的。但对于epoll的ET模式，这种方式还有漏洞。</p>
<p>epoll的两种模式LT和ET<br>二者的差异在于level-trigger模式下只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket；而edge-trigger模式下只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</p>
<p>所以，在epoll的ET模式下，正确的读写方式为:<br>读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN<br>写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</p>
<p>正确的读<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">    perror(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正确的写</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int nwrite, data_size = <span class="literal">strlen</span>(buf);</span><br><span class="line"><span class="keyword">n</span> = data_size;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">n</span> &gt; 0) &#123;</span><br><span class="line">    nwrite = write(fd, buf + data_size - <span class="keyword">n</span>, <span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">if</span> (nwrite &lt; <span class="keyword">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nwrite == -1 &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">            perror(<span class="string">"write error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">n</span> -= nwrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确的accept，accept-要考虑-2-个问题"><a href="#正确的accept，accept-要考虑-2-个问题" class="headerlink" title="正确的accept，accept 要考虑 2 个问题"></a>正确的accept，accept 要考虑 2 个问题</h3><h4 id="1-阻塞模式-accept-存在的问题"><a href="#1-阻塞模式-accept-存在的问题" class="headerlink" title="(1) 阻塞模式 accept 存在的问题"></a>(1) 阻塞模式 accept 存在的问题</h4><p>考虑这种情况：TCP连接被客户端夭折，即在服务器调用accept之前，客户端主动发送RST终止连接，导致刚刚建立的连接从就绪队列中移出，如果套接口被设置成阻塞模式，服务器就会一直阻塞在accept调用上，直到其他某个客户建立一个新的连接为止。但是在此期间，服务器单纯地阻塞在accept调用上，就绪队列中的其他描述符都得不到处理。</p>
<p>解决办法是把监听套接口设置为非阻塞，当客户在服务器调用accept之前中止某个连接时，accept调用可以立即返回-1，这时源自Berkeley的实现会在内核中处理该事件，并不会将该事件通知给epool，而其他实现把errno设置为ECONNABORTED或者EPROTO错误，我们应该忽略这两个错误。</p>
<h4 id="2-ET模式下accept存在的问题"><a href="#2-ET模式下accept存在的问题" class="headerlink" title="(2)ET模式下accept存在的问题"></a>(2)ET模式下accept存在的问题</h4><p>考虑这种情况：多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。</p>
<p>解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。</p>
<p>综合以上两种情况，服务器应该使用非阻塞地accept，accept在ET模式下的正确使用方式为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote, (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handle_client(conn_sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">    perror(<span class="string">"accept"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll ET 模式简单HTTP服务器代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_EVENTS <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT <span class="number">8080</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置socket连接为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts;</span><br><span class="line"></span><br><span class="line">    opts = fcntl(sockfd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_GETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = (opts | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(sockfd, F_SETFL, opts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_SETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line">    <span class="keyword">int</span> addrlen, listenfd, conn_sock, nfds, epfd, fd, i, nread, n;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in local, remote;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建listen socket</span></span><br><span class="line">    <span class="keyword">if</span>( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sockfd\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setnonblocking(listenfd);</span><br><span class="line">    bzero(&amp;local, <span class="keyword">sizeof</span>(local));</span><br><span class="line">    local.sin_family = AF_INET;</span><br><span class="line">    local.sin_addr.s_addr = htonl(INADDR_ANY);;</span><br><span class="line">    local.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>( bind(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;local, <span class="keyword">sizeof</span>(local)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(MAX_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epfd == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_ctl: listen_sock"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == -<span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_pwait"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == listenfd) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote,</span><br><span class="line">                                (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    setnonblocking(conn_sock);</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = conn_sock;</span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                                &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"epoll_ctl: add"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED</span><br><span class="line">                            &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">                        perror(<span class="string">"accept"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    n += nread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                    perror(<span class="string">"read error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ev.data.fd = fd;</span><br><span class="line">                ev.events = events[i].events | EPOLLOUT;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">"epoll_ctl: mod"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\nHello World"</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">int</span> nwrite, data_size = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                n = data_size;</span><br><span class="line">                <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nwrite = write(fd, buf + data_size - n, n);</span><br><span class="line">                    <span class="keyword">if</span> (nwrite &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwrite == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                            perror(<span class="string">"write error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    n -= nwrite;</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://www.ccvita.com/515.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/epoll之ET和LT编程/" data-id="cinhea1nr002bp0qyf1x8cvip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket非阻塞读写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/socket非阻塞读写/" class="article-date">
  <time datetime="2016-04-07T07:39:46.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/socket非阻塞读写/">socket非阻塞读写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>对于阻塞的socket,当socket的接收缓冲区中没有数据时，read调用会一直阻塞住，直到有数据到来才返回。当socket缓冲区中的数据量小于期望读取的数据量时，返回实际读取的字节数。当sockt的接收缓冲区中的数据大于期望读取的字节数时，读取期望读取的字节数，返回实际读取的长度。对于非阻塞socket而言，socket的接收缓冲区中有没有数据，read调用都会立刻返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的，如果接收缓冲区中没有数据，则返回-1，错误号为EWOULDBLOCK或EAGAIN,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。如果返回值是其它负值，则表明读取错误。因此，非阻塞的read调用一般这样写:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(sock_fd, buffer, <span class="built_in">len</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//没有读到数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读取失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读到数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>对于写操作write,原理是类似的，非阻塞socket在发送缓冲区没有空间时会直接返回-1，错误号EWOULDBLOCK或EAGA,表示没有空间可写数据，如果错误号是别的值，则表明发送失败。如果发送缓冲区中有足够空间或者是不足以拷贝所有待发送数据的空间的话，则拷贝前面N个能够容纳的数据，返回实际拷贝的字节数。而对于阻塞Socket而言，如果发送缓冲区没有空间或者空间不足的话，write操作会直接阻塞住，如果有足够空间，则拷贝所有数据到发送缓冲区，然后返回.非阻塞的write操作一般写法是:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> write_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nLeft = nLen;</span><br><span class="line"><span class="keyword">while</span>(nLeft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nWrite = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( (nWrite = write(sock_fd, data+write_pos, nLeft)) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;</span><br><span class="line">nWrite = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//写失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nLeft -= nWrite;</span><br><span class="line">wirte_pos += nWrite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.163.com/hbu_lijian/blog/static/126129153201311742750909/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/socket非阻塞读写/" data-id="cinhea1nm0023p0qyagm4wzgf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-之auto、static、extern、register" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/C-之auto、static、extern、register/" class="article-date">
  <time datetime="2016-04-07T02:56:21.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/C-之auto、static、extern、register/">C++之auto、static、extern、register</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern 用来声明一个外部变量或是函数，表示该变量已经在其他的地方定义了，这里只是做一个引用而已，不会产生新的变量。对于extern修饰的变量，编译器会在所在的文件先看看有没有对该变量的定义，有的话，直接应用，没有的话再到其他的文件里面进行查找。由于变量已经在其他的地方定义了，所以<code>extern int a = 10;</code>这种写法是不对的，会造成重定义错误！</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static可以用来修饰变量和函数。</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><p>static修饰的变量都存在静态数据区里面，由于静态数据区内存都是被系统初始化为0的，所以static修饰的变量默认初始值为0。<br>static修饰的变量的作用域只限制于该变量所在的文件，外面的文件不可以使用该变量，所以多个文件可以有相同的变量名（需要使用static修饰），只要在编译的最后链接阶段，在全局情况下，不出现相同的变量名就好。</p>
<h4 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h4><p>static修饰的函数主要有两个作用：限定该函数的作用域为本文件可见以及static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝，因此对于static函数的调用会比普通函数快很多。</p>
<h4 id="类中的static"><a href="#类中的static" class="headerlink" title="类中的static"></a>类中的static</h4><p>在类中，static修饰的成员变量或是函数表明该变量或是函数是属于类的，所以没有对应的this指针。static修饰的函数只能访问类的static修饰的成员变量，并且static修饰的函数不能是虚函数。</p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序都变量大多是自动变量。auto不能修饰全局变量，因为该变量的内存是放在栈上面的，有系统自动创建和销毁，所以不能用来修饰全局变量。在函数里面，一般所声明的变量都是直接的默认为auto的。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行。系统的寄存器是有限制的,声明变量时如:<code>register int i</code>.这种存储类型可以用于频繁使用的变量。实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。</p>
<p>使用register修饰符有几点限制</p>
<p>（1）register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。最好不要这样去用</p>
<p>（2）因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。</p>
<p>（3）只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。所以说不要用register修饰全局变量等，因为他长时间的占用寄存器不允许再被使用了。</p>
<p>（4）局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c，同样的道理，因为static变量函数结束不会被销毁，下面进入还会使用之前的数据，生命周期直到程序退出才结束，数据存放在静态区。</p>
<p>（5）由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。</p>
<p>auto register 是用来修饰变量的,static extern 变量函数都可以</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/C-之auto、static、extern、register/" data-id="cinhea1p00047p0qyrbj0uj7k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxIO读取函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/LinuxIO读取函数/" class="article-date">
  <time datetime="2016-04-06T08:43:03.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/LinuxIO读取函数/">Linux IO 读写函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux IO 读取分两种类型，一种是本地文件的读取，一种是网络通信的读取</p>
<h2 id="本地文件的读取函数"><a href="#本地文件的读取函数" class="headerlink" title="本地文件的读取函数"></a>本地文件的读取函数</h2><p>对于本地文件的读取，Linux有两种方式，一种是有缓存的，另一种是没有缓存的。</p>
<h3 id="带缓存的文件读取"><a href="#带缓存的文件读取" class="headerlink" title="带缓存的文件读取"></a>带缓存的文件读取</h3><p>该类型会在内存开辟一个“缓冲区”，为程序中的每一个文件使用；当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读出需要的数据。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p>
<p>主要的函数有：<code>fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind</code>等。</p>
<h3 id="不带缓存的文件读取"><a href="#不带缓存的文件读取" class="headerlink" title="不带缓存的文件读取"></a>不带缓存的文件读取</h3><p>依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度快。主要的函数有：<code>open, close, read, write, getc, getchar, putc, putchar, feof, ferror</code>等</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ol>
<li>open是UNIX系统调用函数（包括LINUX等），返回的是文件描述符（File Descriptor），它是文件在文件描述符表里的索引。</li>
<li>fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api。返回的是一个指向文件结构的指针。</li>
</ol>
<h4 id="移植性"><a href="#移植性" class="headerlink" title="移植性"></a>移植性</h4><p>这一点从上面的来源就可以推断出来，<code>fopen</code>是C标准函数，因此拥有良好的移植性；而<code>open</code>是UNIX系统调用，移植性有限。如windows下相似的功能使用API函数<code>CreateFile</code>。</p>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ol>
<li>open返回文件描述符，而文件描述符是UNIX系统下的一个重要概念，UNIX下的一切设备都是以文件的形式操作。如网络套接字、硬件设备等。当然包括操作普通正规文件（Regular File）。</li>
<li>fopen是用来操纵普通正规文件（Regular File）的。</li>
</ol>
<h4 id="文件IO层次"><a href="#文件IO层次" class="headerlink" title="文件IO层次"></a>文件IO层次</h4><p>如果从文件IO的角度来看，前者属于低级IO函数，后者属于高级IO函数。低级和高级的简单区分标准是：谁离系统内核更近。低级文件IO运行在内核态，高级文件IO运行在用户态。</p>
<p>使用fopen函数，由于在用户态下就有了缓冲，因此进行文件读写操作的时候就减少了用户态和内核态的切换（切换到内核态调用还是需要调用系统调用API:read，write）；而使用open函数，在文件读写时则每次都需要进行内核态和用户态的切换；表现为，如果顺序访问文件，fopen系列的函数要比直接调用open系列的函数快；如果随机访问文件则相反。</p>
<h2 id="网络IO的读取"><a href="#网络IO的读取" class="headerlink" title="网络IO的读取"></a>网络IO的读取</h2><p>网络IO的读取主要针对的是socket，主要有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>*buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbyte)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span>  </span><br><span class="line"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure></p>
<p>recv和send与read和write的不同就是函数参数多了一个标志，该标志如果为0的话，那么其作用就相当于read和write函数了。<br>flag的取值可以为0或是下面的组合：</p>
<p>MSG_DONTROUTE:是send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面.<br>MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.</p>
<p>MSG_PEEK:是recv函数的使用标志,表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.</p>
<p>MSG_WAITALL是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)</p>
<p>以上四个函数只适合与面向连接的套接字。对于UDP这样的非连接，需要使用下面的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/socket.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd,  <span class="keyword">struct</span> msghdr * msg, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd,  <span class="keyword">struct</span> msghdr * msg, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>成功时候返回读写字节数，出错时候返回-1.</p>
<p>这2个函数只用于套接口，不能用于普通的I/O读写，参数sockfd则是指明要读写的套接口。<br>flags用于传入控制信息，一般包括以下几个<br>MSG_DONTROUTE             send可用<br>MSG_DONWAIT                 send与recv都可用<br>MSG_PEEK                        recv可用<br>MSG_WAITALL                   recv可用<br>MSG_OOB                         send可用<br>MSG_EOR                          send recv可用</p>
<p>返回信息都记录在struct msghdr * msg中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msghdr &#123;</span><br><span class="line">        <span class="comment">//协议地址和套接口信息，在非连接的UDP中，发送者要指定对方地址端口，接受方用于的到数据来源，如果不需要的话</span></span><br><span class="line">        <span class="comment">//可以设置为NULL（在TCP或者连接的UDP中，一般设置为NULL）。</span></span><br><span class="line">        <span class="keyword">void</span> * msg_name;</span><br><span class="line">        <span class="keyword">socklen_t</span> msg_namelen;<span class="comment">//上面的长度</span></span><br><span class="line">        <span class="keyword">struct</span> lovec * msg_lov;</span><br><span class="line">        <span class="keyword">ssize_t</span> msg_lovlen;<span class="comment">//和readv和writev一样</span></span><br><span class="line">        <span class="keyword">void</span> * msg_control;</span><br><span class="line">        <span class="keyword">socklen_t</span> msg_controllen;</span><br><span class="line">        <span class="keyword">int</span> msg_flags; <span class="comment">//用于返回之前flags的控制信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是该函数使用的例子：</p>
<p>下面的源码来自<a href="http://memorymyann.iteye.com/blog/648513" target="_blank" rel="external">这里</a></p>
<p>服务器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argu)</span> </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;<span class="comment">//初始化struct msghdr</span></span><br><span class="line">        msg.msg_name = <span class="literal">NULL</span>; <span class="comment">//在tcp中，可以设置为NULL</span></span><br><span class="line">        <span class="keyword">struct</span> iovec io;<span class="comment">//初始化返回数据</span></span><br><span class="line">        io.iov_base = buf; <span class="comment">//只用了一个缓冲区</span></span><br><span class="line">        io.iov_len = MAXSIZE; <span class="comment">//定义返回数据长度</span></span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;<span class="comment">//只用了一个缓冲区，所以长度为1</span></span><br><span class="line"></span><br><span class="line">        ...................</span><br><span class="line">        <span class="keyword">ssize_t</span> recv_size = recvmsg(connfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> * temp = msg.msg_iov[<span class="number">0</span>].iov_base;<span class="comment">//获取得到的数据</span></span><br><span class="line">        temp[recv_size] = <span class="string">'\0'</span>;<span class="comment">//为数据末尾添加结束符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get message:%s"</span>, temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        .................</span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;<span class="comment">//初始化发送信息</span></span><br><span class="line">        msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = send_buff;</span><br><span class="line">        io.iov_len = <span class="keyword">sizeof</span>(send_buff);</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"please input port"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> size = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里控制信息都设置成0，主要是初始化返回信息struct msghdr结构。</p>
<p>未连接的UDP套接口<br>服务器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"/programe/net/head.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdlib.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unistd.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/wait.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/select.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/poll.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in serv_socket;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in *client_socket = (<span class="keyword">struct</span> sockaddr_in *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">        <span class="keyword">char</span> buf[MAXSIZE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line">        serv_socket.sin_family = AF_INET;</span><br><span class="line">        serv_socket.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_socket.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;</span><br><span class="line">        msg.msg_name = client_socket;</span><br><span class="line">        <span class="comment">//如果想得到对方的地址和端口，一定要把初始化完毕的内存头指针放入msg之中</span></span><br><span class="line">        msg.msg_namelen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);<span class="comment">//长度也要指定</span></span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = buf;</span><br><span class="line">        io.iov_len = MAXSIZE;</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> len = recvmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        client_socket = (<span class="keyword">struct</span> sockaddr_in *)msg.msg_name;</span><br><span class="line">        <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">        inet_ntop(AF_INET, &amp;(client_socket-&gt;sin_addr), ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">        <span class="keyword">int</span> port = ntohs(client_socket-&gt;sin_port);</span><br><span class="line">        <span class="keyword">char</span> * temp = msg.msg_iov[<span class="number">0</span>].iov_base;</span><br><span class="line">        temp[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get message from %s[%d]: %s\n"</span>, ip, port, temp);</span><br><span class="line">        close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"/programe/net/head.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdlib.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/select.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in serv_socket;</span><br><span class="line">        <span class="keyword">int</span> maxfdpl;</span><br><span class="line">        <span class="keyword">char</span> send[] = <span class="string">"hello yuna"</span>;</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"please input port"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line">        serv_socket.sin_family = AF_INET;</span><br><span class="line">        serv_socket.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"192.168.1.235"</span>, &amp;serv_socket.sin_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;</span><br><span class="line">        msg.msg_name = &amp;serv_socket;</span><br><span class="line">        msg.msg_namelen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = send;</span><br><span class="line">        io.iov_len = <span class="keyword">sizeof</span>(send);</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> send_size = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendto和recvfrom<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="keyword">int</span> tolen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="keyword">int</span> *fromlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于sendto()函数，成功则返回实际传送出去的字符数，失败返回-1，错误原因存于errno 中。</p>
<p>对于recvfrom()函数，成功则返回接收到的字符数，失败则返回-1，错误原因存于errno中。</p>
<p>如果需要在TCP的socket中使用该函数，那么可以直接的对函数最后的两个参数设为NULL。</p>
<p>UDP Server和Client源码实例:</p>
<p>一下源码来自<a href="http://velep.com/archives/934.html" target="_blank" rel="external">这里</a><br>服务端：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	UDP_TEST_PORT		<span class="number">50001</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> sockfd, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 建立socket，注意必须是SOCK_DGRAM */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror (<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 填写sockaddr_in 结构 */</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(UDP_TEST_PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY) ;<span class="comment">// 接收任意IP发来的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定socket */</span></span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"connect"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>,</span><br><span class="line">					   (<span class="keyword">struct</span> sockaddr *)&amp;addr ,&amp;addr_len);</span><br><span class="line">		<span class="comment">/* 显示client端的网络地址和收到的字符串消息 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Received a string from client %s, string is: %s\n"</span>,</span><br><span class="line">				inet_ntoa(addr.sin_addr), buffer);</span><br><span class="line">		<span class="comment">/* 将收到的字符串消息返回给client端 */</span></span><br><span class="line">		sendto(sockfd,buffer, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, addr_len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// End of udp_server.c</span></span><br></pre></td></tr></table></figure></p>
<p>UDP 客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	UDP_TEST_PORT		<span class="number">50001</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> UDP_SERVER_IP 		<span class="string">"127.0.0.1"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> sockfd, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);		</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 建立socket，注意必须是SOCK_DGRAM */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 填写sockaddr_in*/</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(UDP_TEST_PORT);</span><br><span class="line">	addr.sin_addr.s_addr = inet_addr(UDP_SERVER_IP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please enter a string to send to server: \n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从标准输入设备取得字符串*/</span></span><br><span class="line">		len = read(STDIN_FILENO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将字符串传送给server端*/</span></span><br><span class="line">		sendto(sockfd, buffer, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, addr_len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 接收server端返回的字符串*/</span></span><br><span class="line">		len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>,</span><br><span class="line">				       (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addr_len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Receive from server: %s\n"</span>, buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// End of udp_client.c</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/06/LinuxIO读取函数/" data-id="cinhea1of0039p0qygpn15gf8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Boost智能指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/23/Boost智能指针/" class="article-date">
  <time datetime="2016-03-23T14:28:35.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/Boost智能指针/">Boost智能指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Boost 只能指针常用的有四种，分别为：shared_ptr、weak_ptr、auto_ptr以及scoped_ptr指针。</p>
<h2 id="shared-ptr指针"><a href="#shared-ptr指针" class="headerlink" title="shared_ptr指针"></a>shared_ptr指针</h2><p>shared_ptr指针就是所谓的只能计数指针，用来管理非栈上的内存指针。它可以从一个裸指针、另一个shared_ptr、一个auto_ptr、或者一个weak_ptr构造。还可以传递第二个参数给shared_ptr的构造函数，它被称为删除器（deleter）。删除器用于处理共享资源的释放，这对于管理那些不是用new分配也不是用delete释放的资源时非常有用。shared_ptr被创建后，就可以像普通指针一样使用了，除了一点，它不能被显式地删除。</p>
<p>shared_ptr指针的使用如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt1;</span><br><span class="line">assert(pInt1.use_count() == <span class="number">0</span>);         <span class="comment">// 还没有引用指针</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>));</span><br><span class="line">      assert(pInt2.use_count() == <span class="number">1</span>);        <span class="comment">// new int(5)这个指针被引用1次</span></span><br><span class="line"></span><br><span class="line">    pInt1 = pInt2;</span><br><span class="line">      assert(pInt2.use_count() == <span class="number">2</span>);       <span class="comment">// new int(5)这个指针被引用2次</span></span><br><span class="line">    assert(pInt1.use_count() == <span class="number">2</span>);</span><br><span class="line">&#125;                                                   <span class="comment">//pInt2离开作用域, 所以new int(5)被引用次数-1</span></span><br><span class="line"></span><br><span class="line">assert(pInt1.use_count() == <span class="number">1</span>);</span><br><span class="line">&#125;         <span class="comment">// pInt1离开作用域，引用次数-1,现在new int(5)被引用0次，所以销毁它</span></span><br></pre></td></tr></table></figure></p>
<p>如果资源的创建销毁不是以new和delete的方式进行的，该怎么办呢？通过前面的接口可以看到，shared_ptr的构造函数中可以指定删除器。示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FileCloser</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE \*pf)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (pf != <span class="literal">NULL</span>)</span><br><span class="line">         &#123;</span><br><span class="line">               fclose(pf);</span><br><span class="line">               pf = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;FILE&gt; fp(fopen(pszConfigFile, <span class="string">"r"</span>), FileCloser());</span><br></pre></td></tr></table></figure></p>
<p>在使用shared_ptr时，需要避免同一个对象指针被两次当成shard_ptr构造函数里的参数的情况。考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> *pInt = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp1(pInt);</span><br><span class="line">     assert(temp1.use_count() == <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp2(pInt);</span><br><span class="line">     assert(temp2.use_count() == <span class="number">1</span>);</span><br><span class="line">&#125;      <span class="comment">// temp1和temp2都离开作用域，它们都销毁pInt，会导致两次释放同一块内存</span></span><br></pre></td></tr></table></figure>
<p>正确的做法是将原始指针赋给智能指针后，以后的操作都要针对智能指针了。参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>));</span><br><span class="line">  assert(temp1.use_count() == <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp2(temp1);</span><br><span class="line">  assert(temp2.use_count() == <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="comment">// temp1和temp2都离开作用域，引用次数变为0，指针被销毁。</span></span><br></pre></td></tr></table></figure></p>
<p>另外，使用shared_ptr来包装this时，也会产生与上面类似的问题。考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;A&gt; Get()</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pA(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pB = pA-&gt;Get();</span><br></pre></td></tr></table></figure></p>
<p>当pA和pB离开作用域时，会将堆上的对象释放两次。如何解决上述问题呢？C++ 11提供了如下机制：将类从enable_shared_from_this类派生，获取shared_ptr时使用shared_from_this接口。参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A ：<span class="keyword">public</span> enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;A&gt; Get()</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> shared_from_this();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在多线程中使用shared_ptr时，如果存在拷贝或赋值操作，可能会由于同时访问引用计数而导致计数无效。解决方法是向每个线程中传递公共的week_ptr，线程中需要使用shared_ptr时，将week_ptr转换成shared_ptr即可。<br>以上例子来自<a href="http://www.cnblogs.com/hujian/archive/2012/12/10/2810754.html" target="_blank" rel="external">这里</a></p>
<h2 id="weak-ptr指针"><a href="#weak-ptr指针" class="headerlink" title="weak_ptr指针"></a>weak_ptr指针</h2><p>weak_ptr是为配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手，而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和operator-&gt;，它的最大作用在于协助shared_ptr，像旁观者那样观测资源的使用情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> weak_ptr&#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     weak_ptr();  </span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(<span class="built_in">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span> &amp; r);  </span><br><span class="line">     weak_ptr(weak_ptr <span class="keyword">const</span> &amp; r);  </span><br><span class="line"></span><br><span class="line">     ~weak_ptr();  </span><br><span class="line">     weak_ptr &amp; <span class="keyword">operator</span>=(weak_ptr <span class="keyword">const</span> &amp;r);  </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;T&gt; lock() <span class="keyword">const</span>;  </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;  </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(weak_ptr&lt;T&gt; &amp;b)</span></span>;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_ptr是一个“弱”指针，但它能够完成一些特殊的工作，足以证明它的存在价值。</p>
<p>weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。同样，在weak_ptr析构时也不会导致引用计数的减少，它只是一个静静地观察者。</p>
<p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count() == 0，但更快，表示观测的资源（也就是shared_ptr管理的资源）已经不复存在了。</p>
<p>weak_ptr 没有重载operator*和-&gt;，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。但它可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。当expired() == true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">   <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  </span><br><span class="line">   assert(sp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   <span class="comment">//create a weak_ptr from shared_ptr  </span></span><br><span class="line">   weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sp);  </span><br><span class="line">   <span class="comment">//not increase the use count  </span></span><br><span class="line">   assert(sp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   <span class="comment">//judge wp is invalid  </span></span><br><span class="line">   <span class="comment">//expired() is equivalent with use_count() == 0  </span></span><br><span class="line">   <span class="keyword">if</span>(!wp.expired())&#123;  </span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = wp.lock();<span class="comment">//get a shared_ptr  </span></span><br><span class="line">      \*sp2 = <span class="number">100</span>;  </span><br><span class="line">      assert(wp.use_count() == <span class="number">2</span>);  </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; \*sp2 &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="comment">//out of scope,sp2 destruct automatically,use_count()--;  </span></span><br><span class="line">   assert(wp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   sp.reset();<span class="comment">//shared_ptr is invalid  </span></span><br><span class="line">   assert(wp.expired());  </span><br><span class="line">   assert(!wp.lock());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得this的shared_ptr</p>
<p>weak_ptr的一个重要用途是获得this指针的shared_ptr,使对象自己能够生产shared_ptr管理自己：对象使用weak_ptr观测this指，这并不影响引用计数，在需要的时候就调用lock()函数，返回一个符合要求的shared_ptr使外界使用。</p>
<p>这个解决方案被实现为一个惯用法，在头文件<booost enable_shared_from_this.hpp="">定义了一个助手类enable_shared_from_this<t>，其声明如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> enable<span class="number">_</span><span class="annotation">shared</span><span class="number">_f</span>rom<span class="number">_</span><span class="keyword">this</span>  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">   <span class="annotation">shared</span><span class="number">_p</span>tr&lt;T&gt; <span class="annotation">shared</span><span class="number">_f</span>rom<span class="number">_</span><span class="keyword">this</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></booost></p>
<p>使用的时候只需要让想被shared_ptr管理的类从它继承即可，成员函数shared_from_this()会返回this的shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/smart_ptr.hpp&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/enable_shared_from_this.hpp&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/make_shared.hpp&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">class</span> self_shared:  </span><br><span class="line"><span class="keyword">public</span> enable_shared_from_this&lt;self_shared&gt;&#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">    self_shared(<span class="keyword">int</span> n):x(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"self_shared:"</span> &lt;&lt; x &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;self_shared&gt; sp =   </span><br><span class="line">                           make_shared&lt;self_shared&gt;(<span class="number">315</span>);  </span><br><span class="line">    sp-&gt;print();  </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;self_shared&gt; p = sp-&gt;shared_from_this();  </span><br><span class="line">    p-&gt;x = <span class="number">100</span>;  </span><br><span class="line">    p-&gt;print();    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">self_shared:</span><span class="number">315</span></span><br><span class="line"><span class="label">self_shared:</span><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是千万不能从一个普通对象（非shared_ptr）使用shared_from_this ()获取shared_ptr，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self_shared ss;</span><br><span class="line"></span><br><span class="line">shaerd_ptr&lt;self_shared&gt; p = ss.shared_from_this();<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>这样虽然语法上能通过，编译也无问题，但在运行时会导致shared_ptr析构时企图删除一个栈上分配的对象，发生未定义行为。</p>
<p>以上内容来自<a href="http://blog.csdn.net/ajioy/article/details/7377099" target="_blank" rel="external">这里</a></p>
<h2 id="auto-ptr指针"><a href="#auto-ptr指针" class="headerlink" title="auto_ptr指针"></a>auto_ptr指针</h2><p>auto_ptr通过在栈上构建一个对象a，对象a中wrap了动态分配内存的指针p，所有对指针p的操作都转为对对象a的操作。而在a的析构函数中会自动释放p的空间，而该析构函数是编译器自动调用的，无需程序员操心。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法一：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example(<span class="keyword">new</span> MyClass());  </span><br><span class="line"></span><br><span class="line">用法二：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example;  </span><br><span class="line">m_example.reset(<span class="keyword">new</span> MyClass());  </span><br><span class="line"></span><br><span class="line">用法三（指针的赋值操作）：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example1(<span class="keyword">new</span> MyClass());  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example2(<span class="keyword">new</span> MyClass());  </span><br><span class="line">m_example2=m_example1;  </span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>对于上面的代码：m_example2=m_example1;  则C++会把m_example所指向的内存回收，使m_example1 的值为NULL，所以在C++中，应绝对避免把auto_ptr放到容器中。即应避免下列代码：<br>vector<auto_ptr<myclass>&gt;m_example;<br>当用算法对容器操作的时候，你很难避免STL内部对容器中的元素实现赋值传递，这样便会使容器中多个元素被置位NULL，而这不是我们想看到的。</auto_ptr<myclass></p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1(a)：原始代码    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="function">T* <span class="title">pt</span><span class="params">( new T )</span></span>;  </span><br><span class="line">      <span class="comment">/*...更多的代码...*/</span>  </span><br><span class="line">      <span class="keyword">delete</span> pt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码需要手动的delete掉堆上的内存，如果使用auto_ptr指针的话，就不需要：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1(b)：安全代码，使用了auto_ptr  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt( <span class="keyword">new</span> T );  </span><br><span class="line">      <span class="comment">/*...更多的代码...*/</span>  </span><br><span class="line">&#125; <span class="comment">// 酷：当pt出了作用域时析构函数被调用，从而对象被自动删除</span></span><br></pre></td></tr></table></figure></p>
<p>使用一个auto_ptr就像使用一个内建的指针一样容易，而且如果想要“撤销”资源，重新采用手动的所有权，我们只要调用release()。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例2：使用一个auto_ptr  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="comment">// 现在，我们有了一个分配好的对象  </span></span><br><span class="line">T* pt1 = <span class="keyword">new</span> T;  </span><br><span class="line">      <span class="comment">// 将所有权传给了一个auto_ptr对象  </span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt2(pt1);  </span><br><span class="line">      <span class="comment">// 使用auto_ptr就像我们以前使用简单指针一样，  </span></span><br><span class="line">*pt2 = <span class="number">12</span>;          <span class="comment">// 就像*pt1 = 12  </span></span><br><span class="line">pt2-&gt;SomeFunc(); <span class="comment">// 就像pt1-&gt;SomeFunc();  </span></span><br><span class="line">      <span class="comment">// 用get()来获得指针的值  </span></span><br><span class="line">assert( pt1 == pt2.get() );  </span><br><span class="line">      <span class="comment">// 用release()来撤销所有权  </span></span><br><span class="line">T* pt3 = pt2.release();  </span><br><span class="line">      <span class="comment">// 自己删除这个对象，因为现在没有任何auto_ptr拥有这个对象  </span></span><br><span class="line"><span class="keyword">delete</span> pt3;  </span><br><span class="line">&#125; <span class="comment">// pt2不再拥有任何指针，所以不要试图删除它...OK，不要重复删除  </span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用auto_ptr的reset()函数来重置auto_ptr使之拥有另一个对象。如果这个auto_ptr已经拥有了一个对象，那么，它会先删除已经拥有的对象，因此调用reset()就如同销毁这个auto_ptr，然后新建一个并拥有一个新对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 3：使用reset()  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt( <span class="keyword">new</span> T(<span class="number">1</span>) );  </span><br><span class="line">pt.reset( <span class="keyword">new</span> T(<span class="number">2</span>) );         <span class="comment">// 删除由"new T(1)"分配出来的第一个T  </span></span><br><span class="line">&#125; <span class="comment">// 最后pt出了作用域，第二个T也被删除了</span></span><br></pre></td></tr></table></figure></p>
<p>以上原文来自<a href="http://blog.csdn.net/monkey_d_meng/article/details/5901392" target="_blank" rel="external">这里</a></p>
<h2 id="scoped-ptr指针"><a href="#scoped-ptr指针" class="headerlink" title="scoped_ptr指针"></a>scoped_ptr指针</h2><p>scoped_ptr和std::auto_ptr非常类似，是一个简单的智能指针，它能够保证在离开作用域后对象被自动释放。下列代码演示了该指针的基本应用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> implementation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~implementation() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"destroying implementation\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"did something\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    boost::scoped_ptr&lt;implementation&gt; impl(<span class="keyword">new</span> implementation());</span><br><span class="line">    impl-&gt;do_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Test Begin ... \n"</span>;</span><br><span class="line">    test();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Test End.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码的输出结果是：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="keyword">Begin</span> ...</span><br><span class="line">did something</span><br><span class="line">destroying <span class="keyword">implementation</span></span><br><span class="line">Test <span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>
<p>可以看到：当implementation类离其开impl作用域的时候，会被自动删除，这样就会避免由于忘记手动调用delete而造成内存泄漏了。</p>
<p>scoped_ptr的实现和std::auto_ptr非常类似，都是利用了一个栈上的对象去管理一个堆上的对象，从而使得堆上的对象随着栈上的对象销毁时自动删除。不同的是，boost::scoped_ptr有着更严格的使用限制——不能拷贝。这就意味着：boost::scoped_ptr指针是不能转换其所有权的。</p>
<ol>
<li><p>不能转换所有权<br>boost::scoped_ptr所管理的对象生命周期仅仅局限于一个区间（该指针所在的”{}”之间），无法传到区间之外，这就意味着boost::scoped_ptr对象是不能作为函数的返回值的（std::auto_ptr可以）。</p>
</li>
<li><p>不能共享所有权<br>这点和std::auto_ptr类似。这个特点一方面使得该指针简单易用。另一方面也造成了功能的薄弱——不能用于stl的容器中。</p>
</li>
<li><p>不能用于管理数组对象<br>由于boost::scoped_ptr是通过delete来删除所管理对象的，而数组对象必须通过deletep[]来删除，因此boost::scoped_ptr是不能管理数组对象的，如果要管理数组对象需要使用boost::scoped_array类。</p>
</li>
</ol>
<p>scoped_ptr的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> scoped_ptr : noncopyable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">(T* p = <span class="number">0</span>)</span></span>;</span><br><span class="line">        ~scoped_ptr();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&amp; b)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&lt;T&gt; &amp; a, scoped_ptr&lt;T&gt; &amp; b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_array.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/config.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/detail/lightweight_test.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// test scoped_ptr with a built-in type</span></span><br><span class="line">    <span class="keyword">long</span> * lp = <span class="keyword">new</span> <span class="keyword">long</span>;</span><br><span class="line">    boost::scoped_ptr&lt;<span class="keyword">long</span>&gt; sp ( lp );</span><br><span class="line">    BOOST_TEST( sp.get() == lp );</span><br><span class="line">    BOOST_TEST( lp == sp.get() );</span><br><span class="line">    BOOST_TEST( &amp;\*sp == lp );</span><br><span class="line"></span><br><span class="line">    \*sp = <span class="number">1234568901L</span>;</span><br><span class="line">    BOOST_TEST( \*sp == <span class="number">1234568901L</span> );</span><br><span class="line">    BOOST_TEST( \*lp == <span class="number">1234568901L</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> * lp2 = <span class="keyword">new</span> <span class="keyword">long</span>;</span><br><span class="line">    boost::scoped_ptr&lt;<span class="keyword">long</span>&gt; sp2 ( lp2 );</span><br><span class="line"></span><br><span class="line">    sp.swap(sp2);</span><br><span class="line">    BOOST_TEST( sp.get() == lp2 );</span><br><span class="line">    BOOST_TEST( sp2.get() == lp );</span><br><span class="line"></span><br><span class="line">    sp.reset(<span class="literal">NULL</span>);</span><br><span class="line">    BOOST_TEST( sp.get() == <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="boost-scoped-ptr和std-auto-ptr的选取："><a href="#boost-scoped-ptr和std-auto-ptr的选取：" class="headerlink" title="boost::scoped_ptr和std::auto_ptr的选取："></a>boost::scoped_ptr和std::auto_ptr的选取：</h4><p>boost::scoped_ptr和std::auto_ptr的功能和操作都非常类似，如何在他们之间选取取决于是否需要转移所管理的对象的所有权（如是否需要作为函数的返回值）。如果没有这个需要的话，大可以使用boost::scoped_ptr，让编译器来进行更严格的检查，来发现一些不正确的赋值操作。</p>
<p>以上原文来自<a href="http://www.cnblogs.com/TianFang/archive/2008/09/15/1291050.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/23/Boost智能指针/" data-id="cinhea1m20000p0qyvi8yny6j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux任务调度机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/Linux任务调度机制/" class="article-date">
  <time datetime="2016-03-21T14:16:33.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/Linux任务调度机制/">Linux任务调度机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux中，每一个CPU都会有一个队列来存储处于TASK_RUNNING状态的任务，任务调度就是从这些队列中取出优先级最高的任务作为下一个放入CPU执行的任务。</p>
<p>任务的调度需要进过两个过程：上下文切换和选择算法</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>从一个进程的上下文切换到另一个进程的上下文，因为其发生频率很高，所以通常都是调度器效率高低的关键。schedule()函数中调用了switch_to宏，这个宏实现了进程之间的真正切换，其代码存放于include/i386/system.h。switch_to宏是用嵌入式汇编写成的，较难理解。由switch_to()实现，而它的代码段在schedule()过程中调用，以一个宏实现。switch_to()函数正常返回，栈上的返回地址是新进程的task_struct::thread::eip，即新进程上一次被挂起时设置的继续运行的位置（上一次执行switch_to()时的标号”1:”位置）。至此转入新进程的上下文中运行。这其中涉及到wakeup，sleepon等函数来对进程进行睡眠与唤醒操作。</p>
<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>Linux schedule()函数将遍历就绪队列中的所有进程，调用goodness()函数计算每一个进程的权值weight，从中选择权值最大的进程投入运行。Linux的调度器主要实现在schedule()函数中。</p>
<p>调度步骤：</p>
<p>Schedule函数工作流程如下：</p>
<p>（1）清理当前运行中的进程<br>（2）选择下一个要运行的进程（pick_next_task）<br>（3）设置新进程的运行环境<br>（4） 进程上下文切换</p>
<h3 id="Linux-调度器将进程分为三类"><a href="#Linux-调度器将进程分为三类" class="headerlink" title="Linux 调度器将进程分为三类"></a>Linux 调度器将进程分为三类</h3><p>进程调度是操作系统的核心功能。调度器只是调度过程中的一部分，进程调度是非常复杂的过程，需要多个系统协同工作完成。本文所关注的仅为调度器，它的主要工作是在所有RUNNING 进程中选择最合适的一个。作为一个通用操作系统，Linux 调度器将进程分为三类：</p>
<ol>
<li><p>交互式进程<br>此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。</p>
</li>
<li><p>批处理进程<br>此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。</p>
</li>
<li><p>实时进程<br>实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟，轻则影响电影放映效果，重则机毁人亡。</p>
</li>
</ol>
<h3 id="调度时机：调度什么时候发生？即：schedule-函数什么时候被调用？"><a href="#调度时机：调度什么时候发生？即：schedule-函数什么时候被调用？" class="headerlink" title="调度时机：调度什么时候发生？即：schedule()函数什么时候被调用？"></a>调度时机：调度什么时候发生？即：schedule()函数什么时候被调用？</h3><p>调度的发生主要有两种方式：</p>
<p>1：主动式调度(自愿调度)</p>
<p>在内核中主动直接调用进程调度函数schedule()，当进程需要等待资源而暂时停止运行时，会把状态置于挂起（睡眠），并主动请求调度，让出cpu。</p>
<p>2：被动式调度（抢占式调度、强制调度）</p>
<p>用户抢占（2.4  2.6）<br>内核抢占（2.6）</p>
<h4 id="1-用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。"><a href="#1-用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。" class="headerlink" title="(1)用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。"></a>(1)用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。</h4><p>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。主动式调度是用户程序自己调度schedule，也许有人会觉得自己的代码中能引用schedule吗？也许不行吧，但大家知道wait4我们是可以调用的，前面我们没有给出wait4的代码，但我们知道在执行了wait4效果是父进程被挂起，所谓的挂起就是不运行了，放弃了CPU，这里发生了进程调度是显而易见的，其实在代码中有如下几行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current­&gt;state = TASK_INTERRUPIBLE;<span class="function"><span class="title">schedule</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还有exit也有<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current­&gt;state = TASK_ZOMBIE; <span class="function"><span class="title">schedule</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这2种发生了进程调度，从代码上也可以看出（状态被改成了睡眠和僵死，然后去调度可运行进程，当前进程自然不会再占有CPU运行了），从效果中也能看出。这说明用户程序自己可以执行进程调度。</p>
<h4 id="2-内核抢占"><a href="#2-内核抢占" class="headerlink" title="(2)内核抢占"></a>(2)内核抢占</h4><p>在不支持内核抢占的系统中，进程/线程一旦运行于内核空间，就可以一直执行，直到它主动放弃或时间片耗尽为止。这样一些非常紧急的进程或线程将长时间得不到运行。在支持内核抢占的系统中，更高优先级的进程/线程可以抢占正在内核空间运行的低优先级的进程/线程。关于抢占式调度(强制调度），需要知道的是，CPU在执行了当前指令之后，在执行下一条指令之前，CPU要判断在当前指令执行之后是否发生了中断或异常，如果发生了，CPU将比较到来的中断优先级和当前进程的优先级（有硬件参与实现，如中断控制器8259A芯片；通过比较寄存器的值来判断优先级；中断服务程序的入口地址形成有硬件参与实现，等等，具体实现请见相关资料和书籍），如果新来任务的优先级更高，则执行中断服务程序，在返回中断时，将执行进程调度函数schedule。</p>
<p>在支持内核抢占的系统中,某些特例下是不允许内核被抢占的：<br>（a）内核正在运行中断处理程序，进程调度函数schedule（）会对此作出判断，如果是在中断中调用，会打印出错误信息。</p>
<p>（b） 内核正在进行中断上下文的bottom half（中断的底半部）处理，硬件中断返回前会执行软中断，此时仍然处于中断上下文。</p>
<p>（c） 进程正持有spinlock自旋锁，writelock/readlock读写锁等，当持有这些锁时，不应该被抢占，否则由于抢占将导致其他cpu长时间不能获得锁而死锁。</p>
<p>（d） 内核正在执行调度程序scheduler</p>
<p>为了保证linux内核在以上情况下不会被抢占，抢占式内核使用了一个变量preempt_count,称为内核抢占计数。这一变量被设置在进程的thread_info结构体中，每当内核要进入以上几种状态时，变量preempt_count就加1，指示内核不允许抢占，反之减1。</p>
<h3 id="Linux任务调度策略"><a href="#Linux任务调度策略" class="headerlink" title="Linux任务调度策略"></a>Linux任务调度策略</h3><h4 id="Linux支持SCHED-FIFO、SCHED-RR和SCHED-OTHER的调度策略。"><a href="#Linux支持SCHED-FIFO、SCHED-RR和SCHED-OTHER的调度策略。" class="headerlink" title="Linux支持SCHED_FIFO、SCHED_RR和SCHED_OTHER的调度策略。"></a>Linux支持SCHED_FIFO、SCHED_RR和SCHED_OTHER的调度策略。</h4><p>linux用函数goodness（）统一计算进程（包括普通进程和实时进程）的优先级权值，该权值衡量一个处于可运行状态的进程值得运行的程度，权值越大，进程优先级越高。 每个进程的task_struct结构中，与goodness（）计算权值相关的域有以下四项：policy、nice(2.2版内核该项为priority)、counter、rt_priority。其中，policy是进程的调度策略，其可用来区分实时进程和普通进程，实时进程优先于普通进程运行。nice从最初的UNIX沿用而来，表示进程的静态负向优先级，其取值范围为19~-20，以-20优先级最高。counter表示进程剩余的时间片计数值，由于counter在计算goodness（）时起重要作用，因此，counter也可以看作是进程的动态优先级。rt_priority是实时进程特有的，表示实时优先级。</p>
<p>首先，linux根据调度策略policy从整体上区分实时进程和普通进程。对于policy为SCHED_OTHER的普通进程，linux采用动态优先级调，其优先级权值取决于(20-nice)和进程当前的剩余时间片计数counter之和。进程创建时，子进程继承父进程的nice值，而父进程的counter值则被分为二半，子进程和父进程各得一半。时间片计数器每次清零后由(20-nice)经过换算重新赋值。字面上看，nice是“优先级”、counter是“计数器”的意思，然而实际上，它们表达的是同个意思：nice决定了分配给该进程的时间片计数，nice优先级越高的进程分到的时间片越长，用户通过系统调用nice（）或setpriority（）改变进程静态优先级nice值的同时，也改变了该进程的时间片长度；counter表示该进程剩余的时间片计数值，而nice和counter综合起来又决定进程可运行的优先级权值。在进程运行过程中，counter不断减少，而nice保持相对不变；当一个普通进程的时间片用完以后，并不马上根据nice对counter进行重新赋值，只有所有处于可运行状态的普通进程的时间片都用完了以后（counter等于0），才根据nice对counter重新赋值，这个普通进程才有了再次被调度的机会。这说明，普通进程运行过程中，counter的减小给了其它进程得以运行的机会，直至counter减为0时才完全放弃对CPU的使用，这就相当于优先级在动态变化，所以称之为动态优先调度。</p>
<p>对于实时进程，linux采用了两种调度策略，即SCHED_FIFO(先来先服务调度)和SCHED_RR（时间片轮转调度）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，采用了一个比较固定的标准，即参考rt_priority的值。用函数goodness（）计算进程的优先级权值时，对实时进程是在1000的基础上加上rt_priority的值，而非实时进程的动态优先级综合起来的调度权值始终在以下，所以goodness（）的优先级权值计算方法确保实时进程的调度权值始终比所有的非实时进程都要大，这就保证了实时进程的优先运行。实时进程的counter与nice都与其优先级权值无关，这和普通进程是有区别的，实时进程task_struct中的counter和nice只与SCHED_RR调度策略进程的时间片计数相关；而对于SCHED_FIFO调度策略的实时进程没有调度的参考意义。</p>
<h2 id="进程状态说明"><a href="#进程状态说明" class="headerlink" title="进程状态说明"></a>进程状态说明</h2><h4 id="R-task-running-可执行状态"><a href="#R-task-running-可执行状态" class="headerlink" title="R (task_running) : 可执行状态"></a>R (task_running) : 可执行状态</h4><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。</p>
<p>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p>
<h4 id="S-task-interruptible-可中断的睡眠状态"><a href="#S-task-interruptible-可中断的睡眠状态" class="headerlink" title="S (task_interruptible): 可中断的睡眠状态"></a>S (task_interruptible): 可中断的睡眠状态</h4><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p>
<p>通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p>
<h4 id="D-task-uninterruptible-不可中断的睡眠状态"><a href="#D-task-uninterruptible-不可中断的睡眠状态" class="headerlink" title="D (task_uninterruptible): 不可中断的睡眠状态"></a>D (task_uninterruptible): 不可中断的睡眠状态</h4><p>与task_interruptible状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</p>
<p>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep 状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill -15″，这种情况下，一个可选的方法就是reboot。</p>
<p>处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了.</p>
<p>而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。</p>
<p>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p>
<p>我们通过vmstat 命令中procs下的b 可以来查看是否有处于uninterruptible 状态的进程。 该命令只能显示数量。</p>
<p>In computer operating systems terminology, a sleeping process can either be interruptible (woken via signals) or uninterruptible (woken explicitly). An uninterruptible sleep state is a sleep state that cannot handle a signal (such as waiting for disk or network IO (input/output)).</p>
<p>When the process is sleeping uninterruptibly, the signal will be noticed when the process returns from the system call or trap.<br> – 这句是关键。 当处于uninterruptibly sleep 状态时，只有当进程从system 调用返回时，才通知signal。</p>
<p>A process which ends up in “D” state for any measurable length of time is trapped in the midst of a system call (usually an I/O operation on a device — thus the initial in the ps output).</p>
<p>Such a process cannot be killed — it would risk leaving the kernel in an inconsistent state, leading to a panic. In general you can consider this to be a bug in the device driver that the process is accessing.</p>
<h4 id="T-task-stopped-or-task-traced-：暂停状态或跟踪状态"><a href="#T-task-stopped-or-task-traced-：暂停状态或跟踪状态" class="headerlink" title="T(task_stopped or task_traced)：暂停状态或跟踪状态"></a>T(task_stopped or task_traced)：暂停状态或跟踪状态</h4><p>向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）</p>
<p>向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。</p>
<p>当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>
<p>对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。</p>
<p>而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。</p>
<h4 id="Z-task-dead-exit-zombie-：退出状态，进程成为僵尸进程"><a href="#Z-task-dead-exit-zombie-：退出状态，进程成为僵尸进程" class="headerlink" title="Z (task_dead - exit_zombie)：退出状态，进程成为僵尸进程"></a>Z (task_dead - exit_zombie)：退出状态，进程成为僵尸进程</h4><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。    </p>
<p>它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
<p>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。</p>
<p>之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。</p>
<p>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
<p>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</p>
<p>这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p>
<p>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。</p>
<p>如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
<p>当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管的进程可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。</p>
<p>linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：</p>
<p>1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；<br>2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；</p>
<p>init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于task_interruptible状态，“收尸”过程中则处于task_running状态。</p>
<h4 id="X-task-dead-exit-dead-：退出状态，进程即将被销毁"><a href="#X-task-dead-exit-dead-：退出状态，进程即将被销毁" class="headerlink" title="X (task_dead - exit_dead)：退出状态，进程即将被销毁"></a>X (task_dead - exit_dead)：退出状态，进程即将被销毁</h4><p>进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程。或者父进程通过设置sigchld信号的handler为sig_ign，显式的忽略了sigchld信号。（这是posix的规定，尽管子进程的退出信号可以被设置为sigchld以外的其他信号。）</p>
<p>此时，进程将被置于exit_dead退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以exit_dead状态是非常短暂的，几乎不可能通过ps命令捕捉到。</p>
<h2 id="进程状态变化说明"><a href="#进程状态变化说明" class="headerlink" title="进程状态变化说明"></a>进程状态变化说明</h2><h4 id="进程的初始状态"><a href="#进程的初始状态" class="headerlink" title="进程的初始状态"></a>进程的初始状态</h4><p>进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）</p>
<p>那么既然调用进程处于task_running状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于task_running状态。<br>另外，在系统调用调用clone和内核函数kernel_thread也接受clone_stopped选项，从而将子进程的初始状态置为 task_stopped。</p>
<h4 id="进程状态变迁"><a href="#进程状态变迁" class="headerlink" title="进程状态变迁"></a>进程状态变迁</h4><p>进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从task_running状态变为非task_running状态、或者从非task_running状态变为task_running状态。</p>
<p>也就是说，如果给一个task_interruptible状态的进程发送sigkill信号，这个进程将先被唤醒（进入task_running状态），然后再响应sigkill信号而退出（变为task_dead状态）。并不会从task_interruptible状态直接退出。</p>
<p>进程从非task_running状态变为task_running状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为task_running，然后将其task_struct结构加入到某个cpu的可执行队列中。于是被唤醒的进程将有机会被调度执行。</p>
<p>而进程从task_running状态变为非task_running状态，则有两种途径：</p>
<p>1、响应信号而进入task_stoped状态、或task_dead状态；</p>
<p>2、执行系统调用主动进入task_interruptible状态（如nanosleep系统调用）、或task_dead状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入task_interruptible状态或task_uninterruptible状态（如select系统调用）。</p>
<p>显然，这两种情况都只能发生在进程正在cpu上执行的情况下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/21/Linux任务调度机制/" data-id="cinhea1oe0037p0qyn16ehgfi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux-网络编程/" style="font-size: 18px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 18px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 16px;">Linux用户管理</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 14px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 14px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 12px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 12px;">爬虫</a> <a href="/tags/随记/" style="font-size: 12px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/26/ICMP-协议/">ICMP 协议</a>
          </li>
        
          <li>
            <a href="/2016/04/26/DDOS攻击简介/">DDOS攻击简介</a>
          </li>
        
          <li>
            <a href="/2016/04/26/内网穿透简介/">内网穿透简介</a>
          </li>
        
          <li>
            <a href="/2016/04/12/typedef与define的区别/">typedef与define的区别</a>
          </li>
        
          <li>
            <a href="/2016/04/07/epoll之ET和LT编程/">epoll之ET和LT编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>