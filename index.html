<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-UDP之connect" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/11/UDP之connect/" class="article-date">
  <time datetime="2016-07-11T13:25:10.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/UDP之connect/">UDP之connect</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在UDP中，也是可以调用connect系统调用的。但是其作用并不是TCP中的与服务器发起三次握手，他只是在系统中注册对端的地址，以供后面使用。<br>因为在udp编程中，如果需要发送数据给对端，那么需要使用sendTo函数，在参数中指明对端的地址，此时系统所做的事情是，先调用connect函数（注册对端），接着再发送数据，然后再调用connect函数（取消注册）。如果先调用connect函数的话，那么在以后的发送数据时，就不需要使用sendTo函数了（也不能使用），直接使用send和receive函数就可以进行数据的发送和接受了。因为调用connect注册后，此时系统默认该UDP只能与注册的对端发生数据交互，不能与其他的对端进行通信，所以在发送数据的时候就不需要使用sendto了。而至于receive，在调用connect后，如果不是所注册的对端发来的数据，系统会默认将其丢掉，只接受所注册的对端发来的数据。UDP编程使用connect系统调用，具体有以下几个特点：</p>
<ol>
<li><p>TCP中调用connect会引起三次握手,client与server建立连结.UDP中调用connect内核仅仅把对端ip&amp;port记录下来.</p>
</li>
<li><p>UDP中可以多次调用connect,TCP只能调用一次connect.（UDP多次调用connect有两种用途:1,指定一个新的ip&amp;port连结. 2,断开和之前的ip&amp;port的连结）</p>
</li>
<li>对于连续向相同的对端发送数据时，调用connect可以提高效率，因为每一次的sendto都需要经过三个阶段：建立连接-》发送数据-》断开连接</li>
<li>采用connect的UDP发送接受报文可以调用send,write和recv,read操作.当然也可以调用sendto,recvfrom. 调用sendto的时候第五个参数必须是NULL,第六个参数是0.调用recvfrom,recv,read系统调用只能获取到先前connect的ip&amp;port发送的报文.</li>
<li>由已连接的UDP套接口引发的异步错误，返回给他们所在的进程。相反未连接UDP套接口不接收任何异步错误给一个UDP套接口。如果对端没启动，默认情况下发送的包对应的ICMP回射包不会给调用进程，调用了connect之后就可以收到该错误。</li>
</ol>
<p>第6点主要是因为在UDP规则中，如果收到UDP数据报而且目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。所有的ICMP差错报告报文中的数据字段都具有同样的格式。将收到的需要进行差错报告IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上响应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号（对于TCP和UDP）以及运输层报文的发送序号（对于TCP）。<br><img src="/pictures/计算机网络/UDP之connect/ICMP报文.gif" alt=""></p>
<p>从发送到收到icmp是有一定的时延的， 如果是Sendto往二个目的地址写数据报,此时1成功1失败，这种情况下如果这时候内核收到icmp报文，就不知道是哪个sendto。虽然icmp可以获得传输层的端口，但是在sendTo的目的ip和端口一样的情况下，也不能辨别出是哪一个sendto造成的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/11/UDP之connect/" data-id="ciqi40s4m003dvkqyz8byvoge" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java之JVM调优" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/08/Java之JVM调优/" class="article-date">
  <time datetime="2016-07-08T07:43:34.000Z" itemprop="datePublished">2016-07-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/08/Java之JVM调优/">JVM调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JVM的调优主要在垃圾回收上，于是调优的主要工作主要集中在两个部分：堆空间的设置和垃圾回收器的选择</p>
<h3 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h3><p>JVM中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限 制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。在 Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。<br>典型设置：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g –Xss128k</span><br><span class="line">-<span class="ruby"><span class="constant">Xmx3550m</span>：设置<span class="constant">JVM</span>最大可用内存为<span class="number">3550</span>M。</span><br><span class="line"></span>-<span class="ruby"><span class="constant">Xms3550m</span>：设置<span class="constant">JVM</span>促使内存为<span class="number">3550</span>m。此值可以设置与-<span class="constant">Xmx</span>相同，以避免每次垃圾回收完成 后<span class="constant">JVM</span>重新分配内存。</span><br><span class="line"></span>-<span class="ruby"><span class="constant">Xmn2g</span>：设置年轻代大小为<span class="number">2</span>G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。</span></span><br></pre></td></tr></table></figure></p>
<p>持久代一般 固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小 为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线 程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=<span class="number">4</span> -XX:SurvivorRatio=<span class="number">4</span></span><br><span class="line">     -XX:MaxPermSize=<span class="number">16</span>m -XX:MaxTenuringThreshold=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p><code>-XX:NewRatio=4</code>:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设 置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
<p><code>-XX:SurvivorRatio=4</code>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor 区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p><code>-XX:MaxPermSize=16m</code>:设置持久代大小为16m。</p>
<p><code>-XX:MaxTenuringThreshold=0</code>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过 Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大 值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>
<h3 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h3><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以 这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其 他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p>
<h4 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h4><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p>
<p>典型配置：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParallelGC</span>：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，</span><br><span class="line"></span>                    年轻代使用并发收集，而年老代仍旧使用串行收集。</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:ParallelGCThreads=</span><span class="number">20</span>：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。</span><br><span class="line"></span>                          此值最好配置与处理器数目相等。</span><br><span class="line"></span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class="line">     -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParallelOldGC</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParallelOldGC</span>：配置年老代垃圾收集方式为并行收集。<span class="constant">JDK6</span>.<span class="number">0</span>支持对年老代并行收集。</span><br><span class="line"></span></span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxGCPauseMillis=</span><span class="number">100</span><span class="symbol">:</span>设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，</span><br><span class="line"></span>                         JVM会自动调整年轻代大小，以满足此值</span><br><span class="line"></span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC XX:MaxGCPauseMillis=100</span><br><span class="line">     -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseAdaptiveSizePolicy</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseAdaptiveSizePolicy</span>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的<span class="constant">Survivor</span>区比例，</span><br><span class="line"></span>                            以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，</span><br><span class="line">                            一直打开。</span><br></pre></td></tr></table></figure></p>
<h4 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h4><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信 领域等。</p>
<p>典型配置：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20</span><br><span class="line">     -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span> -<span class="constant">XX</span><span class="symbol">:+UseParNewGC</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span>：设置年老代为并发收集。测试中配置这个以后，-<span class="constant">XX</span><span class="symbol">:NewRatio=</span><span class="number">4</span>                          </span><br><span class="line"></span>                         的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParNewGC</span><span class="symbol">:</span> 设置年轻代为并行收集。可与<span class="constant">CMS</span>收集同时使用。<span class="constant">JDK5</span>.<span class="number">0</span>以上，</span><br><span class="line"></span>                  JVM会根据系统配置自行设置，所以无需再设置此值。</span><br><span class="line"></span><br><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5</span><br><span class="line">     -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseCMSCompactAtFullCollection</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSFullGCsBeforeCompaction</span>：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，</span><br><span class="line"></span>                                使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseCMSCompactAtFullCollection</span>：打开对年老代的压缩。可能会影响性能，但是可以消除 碎片</span></span><br></pre></td></tr></table></figure></p>
<h3 id="常见配置汇总"><a href="#常见配置汇总" class="headerlink" title="常见配置汇总"></a>常见配置汇总</h3><h4 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">Xms</span><span class="symbol">:</span>初始堆大小</span><br><span class="line"></span>-<span class="ruby"><span class="constant">Xmx</span><span class="symbol">:</span>最大堆大小</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:NewSize=n</span><span class="symbol">:</span>设置年轻代大小</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:NewRatio=n</span><span class="symbol">:</span>设置年轻代和年老代的比值。如<span class="symbol">:</span>为<span class="number">3</span>，表示年轻代与年老代比值为<span class="number">1</span>：<span class="number">3</span>，年轻代占整个年 轻代年老代和的<span class="number">1</span>/<span class="number">4</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:SurvivorRatio=n</span><span class="symbol">:</span>年轻代中<span class="constant">Eden</span>区与两个<span class="constant">Survivor</span>区的比值。注意<span class="constant">Survivor</span>区有两个。如：<span class="number">3</span>，表示</span><br><span class="line"></span>                    Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</span><br><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxPermSize=n</span><span class="symbol">:</span>设置持久代大小</span></span><br></pre></td></tr></table></figure>
<h4 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseSerialGC</span><span class="symbol">:</span>设置串行收集器</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParallelGC</span><span class="symbol">:</span>设置并行收集器</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParalledlOldGC</span><span class="symbol">:</span>设置并行年老代收集器</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span><span class="symbol">:</span>设置并发收集器</span></span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGC</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDetails</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCTimeStamps</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">Xloggc</span><span class="symbol">:filename</span></span></span><br></pre></td></tr></table></figure>
<h4 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:ParallelGCThreads=n</span><span class="symbol">:</span>设置并行收集器收集时使用的<span class="constant">CPU</span>数。并行收集线程数。</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxGCPauseMillis=n</span><span class="symbol">:</span>设置并行收集最大暂停时间</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:GCTimeRatio=n</span><span class="symbol">:</span>设置垃圾回收时间占程序运行时间的百分比。公式为<span class="number">1</span>/(<span class="number">1</span>+n)</span></span><br></pre></td></tr></table></figure>
<h4 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+CMSIncrementalMode</span><span class="symbol">:</span>设置为增量模式。适用于单<span class="constant">CPU</span>情况。</span><br><span class="line"></span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:ParallelGCThreads=n</span><span class="symbol">:</span>设置并发收集器年轻代收集方式为并行收集时，使用的<span class="constant">CPU</span>数。并行收集线程数。</span></span><br></pre></td></tr></table></figure>
<h3 id="异常分析"><a href="#异常分析" class="headerlink" title="异常分析"></a>异常分析</h3><h4 id="持久代被占满"><a href="#持久代被占满" class="headerlink" title="持久代被占满"></a>持久代被占满</h4><h5 id="异常：java-lang-OutOfMemoryError-PermGen-space"><a href="#异常：java-lang-OutOfMemoryError-PermGen-space" class="headerlink" title="异常：java.lang.OutOfMemoryError: PermGen space"></a>异常：java.lang.OutOfMemoryError: PermGen space</h5><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><p>Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射 大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占 满。<br>更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，如果有 N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量 classLoader和大量反射类的情况其实也不多。</p>
<h5 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h5><ol>
<li>-XX:MaxPermSize=16m</li>
<li>换用JDK。比如JRocket。</li>
</ol>
<h4 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h4><h5 id="异常：java-lang-StackOverflowError"><a href="#异常：java-lang-StackOverflowError" class="headerlink" title="异常：java.lang.StackOverflowError"></a>异常：java.lang.StackOverflowError</h5><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>这个就不多说了，一般就是递归没返回，或者循环调用造成线程堆栈满</p>
<h4 id="异常：Fatal-Stack-size-too-small"><a href="#异常：Fatal-Stack-size-too-small" class="headerlink" title="异常：Fatal: Stack size too small"></a>异常：Fatal: Stack size too small</h4><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5><p>java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其 中。但是当线程空间满了以后，将会出现上面异常。</p>
<h5 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h5><p>增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。</p>
<h4 id="系统内存被占满"><a href="#系统内存被占满" class="headerlink" title="系统内存被占满"></a>系统内存被占满</h4><h5 id="异常：java-lang-OutOfMemoryError-unable-to-create-new-native-thread"><a href="#异常：java-lang-OutOfMemoryError-unable-to-create-new-native-thread" class="headerlink" title="异常：java.lang.OutOfMemoryError: unable to create new native thread"></a>异常：java.lang.OutOfMemoryError: unable to create new native thread</h5><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5><p>这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配 内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空 间，但是操作系统分配不出资源来了，就出现这个异常了。<br>分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存 越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给 单个线程的空间，也可以增加系统总共内生产的线程数。</p>
<h5 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h5><ol>
<li>重新设计系统减少线程数量。</li>
<li>线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。</li>
</ol>
<p>以上的内容转载自<a href=" http://pengjiaheng.javaeye.com" target="_blank" rel="external">JavaEye</a>上的文章,感谢作者的总结。下面的链接是该作者在JVM调优上的一系列文章，个人觉得写的很好，于是在这里也分享一下。<br><a href="https://github.com/LiuBigbin/download/blob/master/JVM%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93.pdf" target="_blank" rel="external">JVM调优总结.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/08/Java之JVM调优/" data-id="ciqi40s6n0056vkqyrybjr0xx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java底层机制/">Java底层机制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java之垃圾回收" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/Java之垃圾回收/" class="article-date">
  <time datetime="2016-07-07T11:01:03.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/Java之垃圾回收/">垃圾回收</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java垃圾回收机制主要有两个步骤：标记和回收</p>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>标记过程主要标记那些当前还在使用的对象，主要有两种方法：引用计数器和跟踪遍历</p>
<h5 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h5><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<p>优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。</p>
<p>缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<h5 id="跟踪遍历"><a href="#跟踪遍历" class="headerlink" title="跟踪遍历"></a>跟踪遍历</h5><p>现在大多数JVM采用对象引用遍历。对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，GC必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>采用引用计数器的GC一般可以混合在程序运行过程中，对没有被引用的对象及时清除，不需要打断程序的运行，但是除了无法删除循环引用的对象之外，这种垃圾回收会使得内存出现碎片。这种机制回收与标记一起执行，两个阶段区分不大。但对于跟踪遍历，回收阶段就有不同的回收算法。</p>
<h5 id="标记－清除收集器"><a href="#标记－清除收集器" class="headerlink" title="标记－清除收集器"></a>标记－清除收集器</h5><p>这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。并且，由于它只是清除了那些未标记的对象，而并没有对标记对象进行压缩，导致会产生大量内存碎片，从而浪费内存。</p>
<h5 id="标记－压缩收集器"><a href="#标记－压缩收集器" class="headerlink" title="标记－压缩收集器"></a>标记－压缩收集器</h5><p>有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。</p>
<h5 id="复制收集器"><a href="#复制收集器" class="headerlink" title="复制收集器"></a>复制收集器</h5><p>这种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中。GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。并且对于指定大小堆来说，需要两倍大小的内存，因为任何时候都只使用其中的一半。</p>
<h5 id="增量收集器"><a href="#增量收集器" class="headerlink" title="增量收集器"></a>增量收集器</h5><p>增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾，也可理解为把堆栈分成一小块一小块，每次仅对某一个块进行垃圾收集。这会造成较小的应用程序中断时间，使得用户一般不能觉察到垃圾收集器正在工作。</p>
<h5 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h5><p>复制收集器的缺点是：每次收集时，所有的标记对象都要被拷贝，从而导致一些生命周期很长的对象被来回拷贝多次，消耗大量的时间。而分代收集器则可解决这个问题，分代收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象(非短命对象)将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。<br><img src="/pictures/Java/Java底层机制/垃圾回收新生代.jpg" alt=""><br>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>
<h6 id="年轻代（Young-Generation）"><a href="#年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h6><p>1、所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>
<p>2、新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p>
<p>3、当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</p>
<p>4、新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</p>
<h6 id="年老代（Old-Generation）"><a href="#年老代（Old-Generation）" class="headerlink" title="年老代（Old Generation）"></a>年老代（Old Generation）</h6><p>1、在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>2、内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<h6 id="持久代（Permanent-Generation）"><a href="#持久代（Permanent-Generation）" class="headerlink" title="持久代（Permanent Generation）"></a>持久代（Permanent Generation）</h6><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<h3 id="GC的执行机制"><a href="#GC的执行机制" class="headerlink" title="GC的执行机制"></a>GC的执行机制</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<h5 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h5><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<p>1、年老代（Tenured）被写满</p>
<p>2、持久代（Perm）被写满</p>
<p>3、System.gc()被显示调用</p>
<p>4、上一次GC之后Heap的各域分配策略动态变化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/Java之垃圾回收/" data-id="ciqi40s6k0050vkqy5dznatw2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java底层机制/">Java底层机制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java之内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/Java之内存管理/" class="article-date">
  <time datetime="2016-07-07T11:00:44.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/Java之内存管理/">内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><img src="/pictures/Java/Java底层机制/内存管理之运行时数据区域图.gif" alt=""></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p>
<p>多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是 线程私有 的。</p>
<p>当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。</p>
<p>此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈也是线程私有的 ，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表中存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。</p>
<p>如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>
<p>会抛出stackOverflowError和OutOfMemoryError异常。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 。<br>Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。</p>
<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。</p>
<p>如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 。</p>
<p>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，</p>
<p>当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。</p>
<h5 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h5><p>是方法区的一部分，它用于存放编译期生成的各种字面量和符号引用。<br>以上内容来自<a href="http://www.codeceo.com/article/java-memory-area.html" target="_blank" rel="external">这里</a></p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>Sun的JVM Generational Collecting(垃圾回收)原理是这样的：把对象分为年青代(Young)、年老代(Tenured)、持久代(Perm)，对不同生命周期的对象使用不同的算法。(基于对对象生命周期分析)<br><img src="/pictures/Java/Java底层机制/内存管理之垃圾回收堆分区.png" alt=""></p>
<h5 id="Yong-新生代"><a href="#Yong-新生代" class="headerlink" title="Yong(新生代)"></a>Yong(新生代)</h5><p><img src="/pictures/Java/Java底层机制/内存管理新生代.jpg" alt=""></p>
<p>对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。</p>
<p>一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte[] data = <span class="keyword">new</span> byte[<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>]</span><br></pre></td></tr></table></figure></p>
<p>这种一般会直接在老年代分配存储空间。</p>
<p>当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。</p>
<h5 id="Tenured-年老代"><a href="#Tenured-年老代" class="headerlink" title="Tenured(年老代)"></a>Tenured(年老代)</h5><p>年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。</p>
<h5 id="Perm-持久代"><a href="#Perm-持久代" class="headerlink" title="Perm(持久代)"></a>Perm(持久代)</h5><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。持久代也就是下面所说的非堆内存，也是上面所说的方法区。</p>
<h4 id="简单的概念："><a href="#简单的概念：" class="headerlink" title="简单的概念："></a>简单的概念：</h4><h5 id="堆-Heap-和非堆-Non-heap-内存"><a href="#堆-Heap-和非堆-Non-heap-内存" class="headerlink" title="堆(Heap)和非堆(Non-heap)内存"></a>堆(Heap)和非堆(Non-heap)内存</h5><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p>
<h5 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h5><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由 -Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆 直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。</p>
<h5 id="非堆内存分配"><a href="#非堆内存分配" class="headerlink" title="非堆内存分配"></a>非堆内存分配</h5><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p>
<h5 id="JVM内存限制-最大值"><a href="#JVM内存限制-最大值" class="headerlink" title="JVM内存限制(最大值)"></a>JVM内存限制(最大值)</h5><p>首先JVM内存限制于实际的最大物理内存(废话！呵呵)，假设物理内存无限 大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是 2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了</p>
<p>以上内容来自<a href="http://blog.csdn.net/lengyuhong/article/details/5953544" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/Java之内存管理/" data-id="ciqi40s6m0053vkqykfh6o2nj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java底层机制/">Java底层机制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java之类的反射机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/Java之类的反射机制/" class="article-date">
  <time datetime="2016-07-07T11:00:31.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/Java之类的反射机制/">类的反射机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在java中，类、接口、Enum等编译后，都会生成.class文件，用来记录每一个类的具体信息。在加载.class文件时，JVM会产生一个Class实例来代表该.class文件，Class实例记录了每一个类的所有信息。通多Class实例，我们就可以实现反射机制了。<br>可以通过三种方法来获得java.lang.Class的实例</p>
<ol>
<li>通过对象的成员函数<code>getClass()</code>来获得，该函数为java.lang.Object类的public函数，由于每一个类都是继承Object的，所以每一个类都会有该函数</li>
<li>通过<code>类名.class</code>来获得。</li>
<li>通过<code>Class.forName()</code>来获得。<code>Class.forName</code>有两个版本，<code>Class.forName(&quot;类名&quot;)</code>和<code>Class.forName(&quot;类名&quot;， bool值是否加载初始化，类加载器)</code></li>
</ol>
<p>对于基本类型，也可以使用对应打包类上加.TYPE来取得Class对象，例如：<br>使用Integer.TYPE可取得代表int基本类型的Class，如果需要取得代表Integer.class文档的Class，那么必须使用Integer.class.</p>
<p>拥有Class实例后，就可以通过Class实例所记录的信息来获得对应类的信息以及生成类实例。可以得到类的所有构造方法、成员函数(包括静态方法)以及成员属性(包括静态属性)，还可以访问以及修改对象的私有成员属性。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package chb.test.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="params"><span class="keyword">int</span> age</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hi</span>(<span class="params"><span class="keyword">int</span> age,String name</span>)</span>&#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"大家好，我叫"</span>+name+<span class="string">"，今年"</span>+age+<span class="string">"岁"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>在方法调用中，参数类型必须正确，这里需要注意的是不能使用包装类替换基本类型，比如不能使用Integer.class代替int.class<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> cls = <span class="keyword">Class</span>.forName(<span class="string">"chb.test.reflect.Student"</span>);</span><br><span class="line">Method m = cls.getDeclaredMethod(<span class="string">"hi"</span>,<span class="keyword">new</span> <span class="keyword">Class</span>[]&#123;<span class="keyword">int</span>.<span class="keyword">class</span>,String.<span class="keyword">class</span>&#125;);</span><br><span class="line">m.invoke(cls.newInstance(),<span class="number">20</span>,<span class="string">"chb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//static方法调用时，不必得到对象</span></span><br><span class="line"><span class="keyword">Class</span> cls = <span class="keyword">Class</span>.forName(<span class="string">"chb.test.reflect.Student"</span>);</span><br><span class="line">Method staticMethod = cls.getDeclaredMethod(<span class="string">"hi"</span>,<span class="keyword">int</span>.<span class="keyword">class</span>,String.<span class="keyword">class</span>);</span><br><span class="line">staticMethod.invoke(cls,<span class="number">20</span>,<span class="string">"chb"</span>);<span class="comment">//这里不需要newInstance</span></span><br></pre></td></tr></table></figure></p>
<h5 id="private的成员变量赋值"><a href="#private的成员变量赋值" class="headerlink" title="private的成员变量赋值"></a>private的成员变量赋值</h5><p>如果直接通过反射给类的private成员变量赋值，是不允许的，这时我们可以通过setAccessible方法解决。代码示例：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">cls</span> = <span class="title">Class</span>.<span class="title">forName</span>("<span class="title">chb</span>.<span class="title">test</span>.<span class="title">reflect</span>.<span class="title">Student</span>");</span></span><br><span class="line">Object student = cls.newInstance();</span><br><span class="line"><span class="keyword">Field</span> <span class="keyword">field</span> = cls.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line"><span class="keyword">field</span>.setAccessible(<span class="literal">true</span>);//设置允许访问</span><br><span class="line"><span class="keyword">field</span>.set(student, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="keyword">field</span>.get(student));</span><br></pre></td></tr></table></figure></p>
<p>其实，在某些场合下(类中有get,set方法)，可以先反射调用set方法，再反射调用get方法达到如上效果，代码示例：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> cls = <span class="keyword">Class</span>.forName(<span class="string">"chb.test.reflect.Student"</span>);</span><br><span class="line">Object student = cls.newInstance();</span><br><span class="line"></span><br><span class="line">Method setMethod = cls.getDeclaredMethod(<span class="string">"setAge"</span>,Integer.<span class="keyword">class</span>);</span><br><span class="line">setMethod.invoke(student, <span class="number">15</span>);<span class="comment">//调用set方法</span></span><br><span class="line"></span><br><span class="line">Method getMethod = cls.getDeclaredMethod(<span class="string">"getAge"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(getMethod.invoke(student));<span class="comment">//再调用get方法</span></span><br></pre></td></tr></table></figure></p>
<p>以上的代码来自<a href="http://blog.csdn.net/hbcui1984/article/details/2719089" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/Java之类的反射机制/" data-id="ciqi40s6h004svkqy9lbezfka" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java底层机制/">Java底层机制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java之类的加载到执行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/Java之类的加载到执行/" class="article-date">
  <time datetime="2016-07-07T11:00:04.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/Java之类的加载到执行/">类的加载到执行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在命令行中输入<code>java xxx</code>指令后，java执行程序会在JRE安装目录中寻找JVM启动文件，如果在windows中，就是jvm.dll文件，启动JVM后，接着JVM产生Bootstrap Loader类加载器，Bootstrap Loader类加载器接着产生Extended Loader，并且设置该加载器的父加载器为Bootstrap Loader，接着有产生System Loader，并且设置其父加载器为Extended Loader.<br>在java中，除了Bootstrap Loader之外，其他的类加载器都有父加载器。Bootstrap由C语言编写，其他的由java语言编写。<br>三种类型的加载器的主要功能如下：</p>
<ol>
<li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。</li>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
</ol>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>当以上过程完成后，System Loader就开始加载运行类了，也就是在运行中，需要用到新的类时，在默认情况下就由System Loader来负责加载。每一个类加载器在加载类时，都会把加载工作交给其父类加载器来完成，一层一层的往上提交，如果父类加载器不能完成加载工作，才由当前的类加载器来完成加载工作。这就是所谓的”类加载代理模式”。之所以采用该模式主要是为了保证java核心库的类型安全。在java虚拟机中，判定两个类是否相同，Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Sample &#123;</span><br><span class="line">   <span class="keyword">private</span> Sample instance;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSample</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.instance = (Sample) instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassIdentity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String classDataRootPath = <span class="string">"C:\\workspace\\Classloader\\classData"</span>;</span><br><span class="line">    FileSystemClassLoader fscl1 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class="line">    FileSystemClassLoader fscl2 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</span><br><span class="line">    String className = <span class="string">"com.example.Sample"</span>; 	</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; class1 = fscl1.loadClass(className);</span><br><span class="line">        Object obj1 = class1.newInstance();</span><br><span class="line">        Class&lt;?&gt; class2 = fscl2.loadClass(className);</span><br><span class="line">        Object obj2 = class2.newInstance();</span><br><span class="line">        Method setSampleMethod = class1.getMethod(<span class="string">"setSample"</span>, java.lang.Object.<span class="keyword">class</span>);</span><br><span class="line">        setSampleMethod.invoke(obj1, obj2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行错误输出</span></span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">39</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">25</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">597</span>)</span><br><span class="line">at classloader.ClassIdentity.testClassIdentity(ClassIdentity.java:<span class="number">26</span>)</span><br><span class="line">at classloader.ClassIdentity.main(ClassIdentity.java:<span class="number">9</span>)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.example.Sample</span><br><span class="line">cannot be cast to com.example.Sample</span><br><span class="line">at com.example.Sample.setSample(Sample.java:<span class="number">7</span>)</span><br><span class="line">... <span class="number">6</span> more</span><br></pre></td></tr></table></figure></p>
<p>所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</p>
<p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>
<p>当类对应的.class文件加载到JVM后，会创建一个java.lang.Class对象，一个Class对象对应一个.class文件，主要记录该文件的关于类的所有信息。我们可以通过该对象的<code>newInstance()</code>函数来生成类的实例，这种情况只适合在类具有无参数构造函数的情况下。默认情况下，JVM只会用一个Class实例来代表一个.class文件（确切说，应该是通过同一类加载器载入的.class文件），每一个类的实例都会知道自己由哪一个Class实例生成，可以听过<code>对象.getClass()</code>或是<code>类名.class</code>或是<code>Class.forName(&quot;类名&quot;)</code>来获得类的Class实例。Class实例记录了类的所有信息，可以通过该实例来得到具体类的对象，java的反射机制就是通过Class来实现的。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>当类被加载后，系统就为之创建一个对应的Class对象，接着就会进入连接阶段。连接阶段会负责吧类的二进制数据合并到JRE中。类连接又可以分为如下三个阶段：</p>
<ol>
<li><p>验证：检验被加载的类是否有正确的内部结构，并和其它类协调一致。</p>
</li>
<li><p>准备：负责为类的静态属性分配内存，并设置默认初始值。</p>
</li>
<li><p>解析：将类的二进制数据中的符号引用替换成直接引用。</p>
</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>JVM负责对类进行初始化，也就是对静态属性进行初始化。在Java类中，对静态属性指定初始值的方式有两种：（1）声明静态属性时指定初始值；（2）使用静态初始化块为静态属性指定初始值。<br>默认情况下都是在Class实例生成后，对类进行初始化。但是也可以对其推迟，直到需要生成类的实例时，才进行初始化，而且只在第一次生成类的实例前才执行初始化。<code>Class.forName(&quot;类名&quot;， bool值初始化与否， 类加载器)</code>可以自定义初始化的时间。<br>完成以上工作后，程序就可以继续执行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/Java之类的加载到执行/" data-id="ciqi40s6i004xvkqyqykjy38m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java底层机制/">Java底层机制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式之单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/设计模式之单例模式/" class="article-date">
  <time datetime="2016-07-07T04:08:13.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/07/设计模式之单例模式/">设计模式之单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单例模式的定义：确保一个类只有一个实例，并提供一个全局访问点</p>
<h4 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;  <span class="comment">//属于类的，只能通过函数得到,也是唯一的单例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;;              <span class="comment">//私有的构造函数，不允许外界直接实例化对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//获得单例对象的全局访问点</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)                    </span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在单线程的环境下运行的很好，但是在多线程的情况下，就会出现问题。主要在于<code>getInstance</code>函数在多线程情况下会出现资源竞争，可以对<code>getInstance</code>函数变成同步的方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//获得单例对象的全局访问点</span></span><br><span class="line">  <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)                    </span><br><span class="line">      uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是同步一个方法可能造成程序执行效率降低100倍，而且其实在<code>getInstance</code>函数中，并不是整一个方法都属于资源竞争的范围，只有<code>uniqueInstance = new Singleton()</code>语句才是，而且只有在单例对象第一次初始化的时候才会执行该语句，其余的都不会进入到该语句中，所以直接对整一个方法进行同步有点浪费。<br>可以双重检查加锁，在<code>getInstance</code>函数中减少同步<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">  <span class="comment">//volatile 表明该变量是易变的，编译器不要对其进行优化，每一个反问的时候都要在内存中进行读取，不要存放在寄存器中</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.<span class="keyword">class</span>)&#123;</span><br><span class="line">        <span class="comment">//在执行到这里面是，并不知道uniqueInstance对象会不会被其他的线程改变，所以需要在检查一下</span></span><br><span class="line">        <span class="comment">//以确保在null的情况下才实例化一个对象</span></span><br><span class="line">        <span class="comment">//volatile关键字表明每一次对uniqueInstance变量的读取都是直接在内存中读的     </span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以在多线程的情况下保证代码的正确运行同时对程序执行效率没有影响，只有在第一次初始化是才会执行同步方法。</p>
<p>以上的单例程序都是在程序调用<code>getInstance</code>方法时，才会实例化Singleton对象的，这也就是所谓的”延迟实例化”，这样可以保证资源不被浪费。如果单例对象所占有的资源不大，那么也可以直接的实例化——“急切”实例化。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">  <span class="comment">//在类加载的时候直接的实例化，不存在多线程的问题</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中，我们依赖JVM在加载这个类的时候就直接创建单例实例。JVM确保在任何线程反问uniqueInstance静态变量前，一定先创建此实例。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/07/设计模式之单例模式/" data-id="ciqi40s2y000pvkqy8e82phxi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式之观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/设计模式之观察者模式/" class="article-date">
  <time datetime="2016-07-06T15:42:23.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/设计模式之观察者模式/">设计模式之观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>观察者模式有由两部分组成：主题和观察者。主题负责生产数据，观察者通过订阅主题来获得需要观察的数据<br>观察者模式定义：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都收到通知并自动更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主题接口</span></span><br><span class="line"><span class="keyword">public</span> Interface Subject&#123;</span><br><span class="line">  registerObserver(Observer);</span><br><span class="line">  removeObserver(Observer);</span><br><span class="line">  notifyObservers();  <span class="comment">//有新数据的时候，调用该函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line"><span class="keyword">public</span> Interface Observer&#123;</span><br><span class="line">  <span class="comment">//在主题有数据更新时，在notifyObservers函数里面，</span></span><br><span class="line">  <span class="comment">//会对每一个已经注册的Observer调用该函数，实现对Observer的通知</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer ob)</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer ob)</span></span>&#123;...&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;              <span class="comment">//有新数据的时候，调用该函数</span></span><br><span class="line">    <span class="keyword">for</span>(Observer ob : Observers)&#123;</span><br><span class="line">      ob.update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;  </span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的观察者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Subject sbj;     <span class="comment">//对主题的应用，以实现对所感兴趣的主题的订阅与取消订阅</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;...&#125;;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ol>
<li><p>“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。</p>
</li>
<li><p>在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义的字符串方式：String str = “Java String”;</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/设计模式之观察者模式/" data-id="ciqi40s2u000kvkqydes05rm2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式之工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/设计模式之工厂模式/" class="article-date">
  <time datetime="2016-07-06T14:52:50.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/设计模式之工厂模式/">设计模式之工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工厂模式分为两种：工厂方法模式和抽象工厂模式<br>一个Pizaa店的订单：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PizzaStore&#123;</span><br><span class="line">  <span class="keyword">public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    Pizza p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"aa"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">      p =  <span class="literal">new</span> AAPizaa();   <span class="comment">//AAPizza为Pizaa的子类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"bb"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">        p =  BBPizaa();     <span class="comment">//BBPizza为Pizaa的子类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>简单工厂只是一种编程习惯，并不是真正的设计模式。他只是把类中实例化一个对象的工作给抽出来，用一个工厂类来负责对象的实例化<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化的工作被抽离出来</span></span><br><span class="line"><span class="keyword">public</span> class SimplePizzaFactory&#123;</span><br><span class="line">  <span class="keyword">public</span> SimplePizzaFactory()&#123;&#125;;</span><br><span class="line">  <span class="keyword">public</span> Pizza createPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"aa"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">      reutrn <span class="literal">new</span> AAPizza();   <span class="comment">//AAPizza为Pizza的子类</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"bb"</span><span class="built_in">.</span><span class="keyword">equals</span>(<span class="keyword">type</span>))</span><br><span class="line">        <span class="keyword">return</span> BBPizza();     <span class="comment">//BBPizza为Pizza的子类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class PizzaStore&#123;</span><br><span class="line">  SimplePizzaFactory spf;</span><br><span class="line">  <span class="keyword">public</span> PizzaStore(SimplePizzaFactory spf)&#123;</span><br><span class="line">    this<span class="built_in">.</span>spf = spf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</span><br><span class="line">    Pizza p;</span><br><span class="line">    p = spf<span class="built_in">.</span>createPizza(<span class="keyword">type</span>);</span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式只是定义一个实例化子类的接口，具体子类的实例化由其派生类来决定实现<br>工厂方法模式定义：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个类，工厂方法让类把实例化推迟到子类里。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span>(</span>)&#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>);</span>   <span class="comment">//工厂方法，具体pizza类的实例化由派生类来实现</span></span><br><span class="line">  public <span class="type">Pizza</span> orderPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">    <span class="type">Pizza</span> p;</span><br><span class="line">    p = createPizza(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的对象实例化由派生类决定</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AAPizzaStore</span>(</span>) <span class="keyword">extends</span> <span class="type">PizzaStore</span>&#123;</span><br><span class="line">   <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="type">System</span>.out.println(<span class="string">"I'm AAPizzaStore"</span>);</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"aa"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>       reutrn <span class="keyword">new</span> <span class="type">AA1Pizza</span>();   <span class="comment">//AA1Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"bb"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>         <span class="keyword">return</span> <span class="type">AA2Pizza</span>();     <span class="comment">//AA2Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span> ...</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BBPizzaStore</span>(</span>) <span class="keyword">extends</span> <span class="type">PizzaStore</span>&#123;</span><br><span class="line">   <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)&#123;</span></span><br><span class="line">     <span class="type">System</span>.out.println(<span class="string">"I'm BBPizzaStore"</span>);</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"aa"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>       reutrn <span class="keyword">new</span> <span class="type">BB1Pizza</span>();   <span class="comment">//BB1Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"bb"</span>.equals(<span class="class"><span class="keyword">type</span>))</span><br><span class="line"></span>         <span class="keyword">return</span> <span class="type">BB2Pizza</span>();     <span class="comment">//BB2Pizza为Pizza的子类</span></span><br><span class="line">     <span class="keyword">if</span> ...</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式里面有很多个工厂方法，每一个工厂方法就是一个用来实例化类的接口<br>抽象工厂模式定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类<br>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出来的具体产品是什么。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> Interface PizzaIngredientFactory&#123;</span><br><span class="line">  <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Cheese <span class="title">crateCheese</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Clam <span class="title">CreateClam</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYDough</span><span class="params">()</span></span>;  <span class="comment">//NYDough 为 Dough的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYSauce</span><span class="params">()</span></span>;  <span class="comment">//NYSauce 为 Sauce的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYCheese</span><span class="params">()</span></span>;  <span class="comment">//NYCheese 为 Cheese的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Clam <span class="title">createClam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">NYClam</span><span class="params">()</span></span>;  <span class="comment">//NYClam 为 Clam的子类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">Dough <span class="title">createDough</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoDough</span><span class="params">()</span></span>;  <span class="comment">//ChicagoDough 为 Dough的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Sauce <span class="title">createSauce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoSauce</span><span class="params">()</span></span>;  <span class="comment">//ChicagoSauce 为 Sauce的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Cheese <span class="title">createCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoCheese</span><span class="params">()</span></span>;  <span class="comment">//ChicagoCheese 为 Cheese的子类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function">Clam <span class="title">createClam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">ChicagoClam</span><span class="params">()</span></span>;  <span class="comment">//ChicagoClam 为 Clam的子类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/设计模式之工厂模式/" data-id="ciqi40s2w000nvkqyc2pzdkhz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="new-C-11常规特性之auto和decltype" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/C-11常规特性之auto和decltype/" class="article-date">
  <time datetime="2016-07-06T10:48:56.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/C-11常规特性之auto和decltype/">C++11常规特性之auto和decltype</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在C++11之前，auto用来声明对象的存储期，修饰普通局部栈变量，是自动存储，这种对象会自动创建和销毁。在C++11新特性中，用来实现类型的推判。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。特别是在循环遍历容器的时候，auto会显得很有用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> Ptr();</span><br><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>,&amp;r=i;</span><br><span class="line"><span class="keyword">auto</span> a=r;<span class="comment">//a为int，因为r是i的别名，i为int。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> b = v.begin();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = begin(<span class="built_in">map</span>); it != end(<span class="built_in">map</span>); ++it) &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，auto不能用来声明函数的返回值。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typename T1, typename T2&gt;</span><br><span class="line"><span class="keyword">auto</span> compose(T1 t1, T2 t2) -&gt; decltype(t1 + t2)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> v = compose(<span class="number">2</span>, <span class="number">3.14</span>); <span class="comment">// v's type is double</span></span><br></pre></td></tr></table></figure></p>
<p>使用auto时,你只是需要一个变量的类型初始化。如果你需要一个类型不是一个变量，那么你需要用到decltype,例如返回类型。decltype是根据变量推导获取出变量的类型。目的是选择并返回操作数的数据类型，重要的是，在此过程中编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum=x;  <span class="comment">//sum的类型就是f返回值的类型， 但是这里不执行函数f()</span></span><br><span class="line"><span class="keyword">auto</span> x= <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">13</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(x*y)</span> Type</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x*y) xy;  <span class="comment">//xy的类型为int</span></span><br><span class="line"><span class="comment">//decltype声明函数指针的时，关键是要记住decltype返回的是一个函数的类型的，因此要加上*声明符才能构成完整的函数指针的类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(f)* k = f; <span class="comment">//直接decltype(f) k = f 是不可以的</span></span><br><span class="line">k(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果decltype使用表达式的结果类型可以作为一条赋值语句的左值，那么decltype返回一个引用类型，例如解引用操作和变量加括号的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c=k; <span class="comment">//c为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = k;  <span class="comment">//d为int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) e = k <span class="comment">//e为int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i++) f; <span class="comment">//f 为int类型</span></span><br><span class="line">tecltype(f=k) g <span class="comment">//g为int&amp;类型，必须初始化</span></span><br></pre></td></tr></table></figure></p>
<h4 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h4><h5 id="const和引用"><a href="#const和引用" class="headerlink" title="const和引用"></a>const和引用</h5><p>auto和const的推断与decltype不一样，对于auto，变量顶层的const会被忽略，只保留底层的const<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onst <span class="keyword">int</span> ci=i,&amp;cr=i;</span><br><span class="line"><span class="keyword">auto</span> a=ci;      <span class="comment">//a为int（忽略顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> b=cr;      <span class="comment">//b为int（忽略顶层const，cr是引用）</span></span><br><span class="line"><span class="keyword">auto</span> c=&amp;i;      <span class="comment">//c为int *</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;ci;     <span class="comment">//d是pointer to const int(&amp;ci为底层const）</span></span><br><span class="line"><span class="comment">//要声明顶层const，前面要加上const关键字；要声明引用要加上&amp;标识符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f=ci; <span class="comment">//ci的推演类型是int,f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g=ci;<span class="comment">// g是一个绑定到ci的引用</span></span><br></pre></td></tr></table></figure></p>
<p>对于decltype，其对const和应用的处理如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x=<span class="number">0</span>;   <span class="comment">//x的类型是const int</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p=&amp;i,&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b; <span class="comment">//b为int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) y=x;   <span class="comment">//y的类型是const int&amp;，y绑定到x上</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/06/C-11常规特性之auto和decltype/" data-id="ciqi40s750062vkqy88vjt1dn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java底层机制/">Java底层机制</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Java底层机制/" style="font-size: 16.67px;">Java底层机制</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/11/UDP之connect/">UDP之connect</a>
          </li>
        
          <li>
            <a href="/2016/07/08/Java之JVM调优/">JVM调优</a>
          </li>
        
          <li>
            <a href="/2016/07/07/Java之垃圾回收/">垃圾回收</a>
          </li>
        
          <li>
            <a href="/2016/07/07/Java之内存管理/">内存管理</a>
          </li>
        
          <li>
            <a href="/2016/07/07/Java之类的反射机制/">类的反射机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>