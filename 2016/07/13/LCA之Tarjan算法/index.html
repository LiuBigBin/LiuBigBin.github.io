<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LCA之Tarjan算法 | LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="寻找最近公共祖先有两种效率高的算法，一种是离线算法Tarjan算法，用户输入所有查询，算法给出所有查询结果，算法在运行的时候就已经知道用户的所有查询了，时间复杂度为O(nlogn)。另外一种是在线算法DFS+ST算法，算法运行不需要知道用户的输入，每一次查询可以在常数时间内给出结果。时间复杂度为DFS-&amp;gt;O(n), ST-&amp;gt;O(nlogn)。这里主要讲一下Tarjan算法。
Tarja">
<meta property="og:type" content="article">
<meta property="og:title" content="LCA之Tarjan算法">
<meta property="og:url" content="http://liubigbin.github.io/2016/07/13/LCA之Tarjan算法/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description" content="寻找最近公共祖先有两种效率高的算法，一种是离线算法Tarjan算法，用户输入所有查询，算法给出所有查询结果，算法在运行的时候就已经知道用户的所有查询了，时间复杂度为O(nlogn)。另外一种是在线算法DFS+ST算法，算法运行不需要知道用户的输入，每一次查询可以在常数时间内给出结果。时间复杂度为DFS-&amp;gt;O(n), ST-&amp;gt;O(nlogn)。这里主要讲一下Tarjan算法。
Tarja">
<meta property="og:image" content="http://liubigbin.github.io/pictures/图与树/LCA之Tarjan算法例子1.jpg">
<meta property="og:updated_time" content="2016-07-13T05:46:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LCA之Tarjan算法">
<meta name="twitter:description" content="寻找最近公共祖先有两种效率高的算法，一种是离线算法Tarjan算法，用户输入所有查询，算法给出所有查询结果，算法在运行的时候就已经知道用户的所有查询了，时间复杂度为O(nlogn)。另外一种是在线算法DFS+ST算法，算法运行不需要知道用户的输入，每一次查询可以在常数时间内给出结果。时间复杂度为DFS-&amp;gt;O(n), ST-&amp;gt;O(nlogn)。这里主要讲一下Tarjan算法。
Tarja">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-LCA之Tarjan算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/13/LCA之Tarjan算法/" class="article-date">
  <time datetime="2016-07-13T03:57:50.000Z" itemprop="datePublished">2016-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LCA之Tarjan算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>寻找最近公共祖先有两种效率高的算法，一种是离线算法Tarjan算法，用户输入所有查询，算法给出所有查询结果，算法在运行的时候就已经知道用户的所有查询了，时间复杂度为O(nlogn)。另外一种是在线算法DFS+ST算法，算法运行不需要知道用户的输入，每一次查询可以在常数时间内给出结果。时间复杂度为DFS-&gt;O(n), ST-&gt;O(nlogn)。这里主要讲一下Tarjan算法。</p>
<p>Tarjan算法是DFS搜索和并查集的思想的结合，深度搜索每一个节点，对于当前的节点x，将其看做一个新的集合，并将其作为该集合的代表，查询处理与该节点有关的查询，接着递归遍历该节点的所有子节点，在遍历完所有子节点后，将该集合与root集合合并，也就是并查集的Union操作。在查询的过程中还可以使用路径压缩的方法来提高查询效率。例如：如果有查询（a, b）,那么当遍历到a节点的时候，如果b节点已经遍历过了，那么分两种情况，如果b在另外一个子树上，那么查找b的时候，b所在的结合的代表就是a和b的最近公共祖先。如果b不在另一颗子树上，而是与a同在一颗子树，那么此时的b就是最近公共祖先。这也就是为什么在需要在遍历完节点的所有子节点后才可以将当前节点与root合并的原因。</p>
<h4 id="例子：Nearest-Common-Ancestors"><a href="#例子：Nearest-Common-Ancestors" class="headerlink" title="例子：Nearest Common Ancestors"></a>例子：<a href="http://poj.org/problem?id=1330" target="_blank" rel="external">Nearest Common Ancestors</a></h4><h6 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h6><p>  A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:</p>
<p>  <img src="/pictures/图与树/LCA之Tarjan算法例子1.jpg" alt=""></p>
<p>  In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.</p>
<p>  For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.</p>
<p>  Write a program that finds the nearest common ancestor of two distinct nodes in a tree.</p>
<h6 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h6><p>  The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,…, N. Each of the next N -1 lines contains a pair of integers that represent an edge –the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.<br>  Output</p>
<p>  Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.</p>
<h6 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h6><p>  2<br>  16<br>  1 14<br>  8 5<br>  10 16<br>  5 9<br>  4 6<br>  8 4<br>  4 10<br>  1 13<br>  6 15<br>  10 11<br>  6 7<br>  10 2<br>  16 3<br>  8 1<br>  16 12<br>  16 7<br>  5<br>  2 3<br>  3 4<br>  3 1<br>  1 5<br>  3 5</p>
<h6 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h6><p>  4<br>  3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Size <span class="number">11111</span>  <span class="comment">//节点个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; node[Size],que[Size];</span><br><span class="line"><span class="keyword">int</span> n,pare[Size],anse[Size],in[Size],rank[Size];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[Size];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		node[i].clear();</span><br><span class="line">		que[i].clear();</span><br><span class="line">		rank[i]=<span class="number">1</span>;</span><br><span class="line">		pare[i]=i;<span class="comment">///</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(in));</span><br><span class="line">	<span class="built_in">memset</span>(anse,<span class="number">0</span>,<span class="keyword">sizeof</span>(anse));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> nd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pare[nd]==nd?nd:pare[nd]=find(pare[nd]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> nd1,<span class="keyword">int</span> nd2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=find(nd1);</span><br><span class="line">	<span class="keyword">int</span> b=find(nd2);</span><br><span class="line">	<span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rank[a]&lt;=rank[b])</span><br><span class="line">	&#123;</span><br><span class="line">		pare[a]=b;</span><br><span class="line">		rank[b]+=rank[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pare[b]=a;</span><br><span class="line">		rank[a]+=rank[b];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> root)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,sz;</span><br><span class="line">	anse[root]=root;<span class="comment">//首先自成一个集合</span></span><br><span class="line">	sz=node[root].size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LCA(node[root][i]);<span class="comment">//递归子树</span></span><br><span class="line">		Union(root,node[root][i]);<span class="comment">//将子树和root并到一块</span></span><br><span class="line">		anse[find(node[root][i])]=root;<span class="comment">//修改子树的祖先也指向root</span></span><br><span class="line">	&#125;</span><br><span class="line">	vis[root]=<span class="number">1</span>;</span><br><span class="line">	sz=que[root].size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(vis[que[root][i]])&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//root和que[root][i]所表示的值的最近公共祖先</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anse[find(que[root][i])]);</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cas);</span><br><span class="line">	<span class="keyword">while</span>(cas--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> s,e;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;s,&amp;e);</span><br><span class="line">			<span class="keyword">if</span>(s!=e)</span><br><span class="line">			&#123;</span><br><span class="line">			    node[s].push_back(e);</span><br><span class="line">			   <span class="comment">// node[e].push_back(s);</span></span><br><span class="line">				in[e]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;s,&amp;e);</span><br><span class="line">		que[s].push_back(e);</span><br><span class="line">		que[e].push_back(s);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  <span class="keyword">if</span>(in[i]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//寻找根节点</span></span><br><span class="line">	  <span class="comment">//	printf("root=%d\n",i);</span></span><br><span class="line">		LCA(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码转载自<a href="http://blog.csdn.net/hnust_xiehonghao/article/details/9109295" target="_blank" rel="external">这里</a></p>
<h4 id="例子：CD操作"><a href="#例子：CD操作" class="headerlink" title="例子：CD操作"></a>例子：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4547" target="_blank" rel="external">CD操作</a></h4><h6 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h6><p>  在Windows下我们可以通过cmd运行DOS的部分功能，其中CD是一条很有意思的命令，通过CD操作，我们可以改变当前目录。<br>  这里我们简化一下问题，假设只有一个根目录，CD操作也只有两种方式：
  　　</p>
<ol>
<li>CD 当前目录名...\目标目录名 (中间可以包含若干目录，保证目标目录通过绝对路径可达)</li>
<li>CD .. (返回当前目录的上级目录)<br>　　<br>现在给出当前目录和一个目标目录，请问最少需要几次CD操作才能将当前目录变成目标目录？</li>
</ol>
<h6 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h6><p>  输入数据第一行包含一个整数T(T&lt;=20)，表示样例个数；<br>  每个样例首先一行是两个整数N和M(1&lt;=N,M&lt;=100000)，表示有N个目录和M个询问；<br>  接下来N-1行每行两个目录名A B(目录名是只含有数字或字母，长度小于40的字符串)，表示A的父目录是B。<br>  最后M行每行两个目录名A B，表示询问将当前目录从A变成B最少要多少次CD操作。<br>  数据保证合法，一定存在一个根目录，每个目录都能从根目录访问到。</p>
<h6 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h6><p>  请输出每次询问的结果，每个查询的输出占一行。</p>
<h6 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h6><p>  2<br>  3 1<br>  B A<br>  C A<br>  B C</p>
<p>  3 2<br>  B A<br>  C B<br>  A C<br>  C A</p>
<h6 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h6><p>  2<br>  1<br>  2<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　求出a和b的最近公共祖先,然后分4种情况讨论</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　①. a和b有一个公共祖先c，则用 c时间戳-a的时间戳+1(1步可以直接从c到b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　②. a是b的祖先，则只用1步就可以到达b点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　③. b是a的祖先，则用a的时间戳-b的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//　　④. a和b是同一个点，则答案是0</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Size <span class="number">111111</span>  <span class="comment">//节点个数</span></span></span><br><span class="line"><span class="keyword">struct</span> Query</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nd,id;</span><br><span class="line">&#125;temp;</span><br><span class="line"><span class="keyword">struct</span> out</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s,e;</span><br><span class="line">&#125;out[Size];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; node[Size];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">struct</span> Query&gt;que[Size];</span><br><span class="line"><span class="keyword">int</span> n,m,pare[Size],ance[Size],in[Size],rank[Size],dis[Size],ans[Size],vis[Size];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		node[i].clear();</span><br><span class="line">		que[i].clear();</span><br><span class="line">		rank[i]=<span class="number">1</span>;</span><br><span class="line">		pare[i]=i;<span class="comment">///</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(in));</span><br><span class="line">	<span class="built_in">memset</span>(ance,<span class="number">0</span>,<span class="keyword">sizeof</span>(ance));</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	mp.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aabs</span><span class="params">(<span class="keyword">int</span> aa)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(aa&gt;<span class="number">0</span>) <span class="keyword">return</span> aa;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> -aa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> nd)</span><span class="comment">//并查集操作  不解释</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pare[nd]==nd?nd:pare[nd]=find(pare[nd]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> nd1,<span class="keyword">int</span> nd2)</span><span class="comment">//并查集操作  不解释</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=find(nd1);</span><br><span class="line">	<span class="keyword">int</span> b=find(nd2);</span><br><span class="line">	<span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rank[a]&lt;=rank[b])</span><br><span class="line">	&#123;</span><br><span class="line">		pare[a]=b;</span><br><span class="line">		rank[b]+=rank[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pare[b]=a;</span><br><span class="line">		rank[a]+=rank[b];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,sz;</span><br><span class="line">	ance[root]=root;<span class="comment">//首先自成一个集合</span></span><br><span class="line">	dis[root]=num;</span><br><span class="line">	sz=node[root].size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		   LCA(node[root][i],num+<span class="number">1</span>);<span class="comment">//递归子树</span></span><br><span class="line">		   Union(root,node[root][i]);<span class="comment">//将子树和root并到一块</span></span><br><span class="line">		 ance[find(node[root][i])]=root;<span class="comment">//修改子树的祖先也指向root</span></span><br><span class="line">	&#125;</span><br><span class="line">	vis[root]=<span class="number">1</span>;</span><br><span class="line">	sz=que[root].size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">int</span> nd1,nd2,idx,ancestor;</span><br><span class="line">	    nd1=root;nd2=que[root][i].nd;idx=que[root][i].id;</span><br><span class="line">            <span class="keyword">if</span>(vis[nd2])</span><br><span class="line">			&#123;</span><br><span class="line">                  ans[idx]=ance[find(nd2)];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cas,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cas);</span><br><span class="line">	<span class="keyword">while</span>(cas--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span>  ss[<span class="number">100</span>],ee[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> s,e,cnt=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,ee,ss);</span><br><span class="line">			<span class="keyword">if</span>(mp.find(ss)==mp.end())</span><br><span class="line">            &#123;</span><br><span class="line">                 s=cnt;mp[ss]=cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s=mp[ss];</span><br><span class="line">			<span class="keyword">if</span>(mp.find(ee)==mp.end())</span><br><span class="line">            &#123;</span><br><span class="line">                e=cnt;mp[ee]=cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  e=mp[ee];</span><br><span class="line">			<span class="keyword">if</span>(s!=e)</span><br><span class="line">			&#123;</span><br><span class="line">			    node[s].push_back(e);</span><br><span class="line">				in[e]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">		   <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,ss,ee);</span><br><span class="line">		   s=mp[ss];e=mp[ee];</span><br><span class="line">		   out[i].s=s;out[i].e=e;</span><br><span class="line">		   temp.nd=e;temp.id=i;</span><br><span class="line">		   que[s].push_back(temp);</span><br><span class="line">		   temp.nd=s;temp.id=i;</span><br><span class="line">		   que[e].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  <span class="keyword">if</span>(in[i]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//寻找根节点</span></span><br><span class="line">		LCA(i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(out[i].s==out[i].e)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(out[i].s==ans[i])</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(out[i].e==ans[i])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[out[i].s]-dis[ans[i]]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[out[i].s]-dis[ans[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码转载自<a href="http://blog.csdn.net/hnust_xiehonghao/article/details/9109295" target="_blank" rel="external">这里</a></p>
<h4 id="例子：Connections-between-cities"><a href="#例子：Connections-between-cities" class="headerlink" title="例子：Connections between cities"></a>例子：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2874" target="_blank" rel="external">Connections between cities</a></h4><h6 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h6><p>  After World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.<br>  Now, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them.</p>
<h6 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h6><p>  Input consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j.</p>
<h6 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h6><p>  For each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them.</p>
<h6 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h6><p>  5 3 2<br>  1 3 2<br>  2 4 3<br>  5 2 3<br>  1 4<br>  4 5</p>
<h6 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h6><p>  Not connected<br>  6</p>
<h6 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h6><p>  Huge input, scanf recommended.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Size  <span class="number">11111</span></span></span><br><span class="line"><span class="keyword">struct</span> Edge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y,val;</span><br><span class="line">&#125;temp;</span><br><span class="line"><span class="keyword">struct</span> Query</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y,id;</span><br><span class="line">&#125;mid;</span><br><span class="line"><span class="keyword">int</span> pare[Size],ance[Size],vis[Size],dis[Size],rank[Size],ans[<span class="number">1000000</span>+<span class="number">100</span>],n,m,c,tree[Size];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">struct</span> Query&gt;que[Size];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">struct</span> Edge&gt;node[Size];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">        pare[i]=i;</span><br><span class="line">        dis[i]=<span class="number">0</span>;</span><br><span class="line">        rank[i]=<span class="number">1</span>;</span><br><span class="line">        que[i].clear();</span><br><span class="line">        node[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans,-<span class="number">1</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pare[x]==x?x:pare[x]=find(pare[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">void Union(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">x=find(x);</span><br><span class="line">y=find(y);</span><br><span class="line">if(x!=y)</span><br><span class="line">&#123;</span><br><span class="line">if(rank[x]&gt;rank[y])</span><br><span class="line">&#123;</span><br><span class="line">rank[x]+=rank[y];</span><br><span class="line">pare[y]=x;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">rank[y]+=rank[x];</span><br><span class="line">pare[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> d,<span class="keyword">int</span> k)</span><span class="comment">//k表示是以第k个点作为根的树</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sz,nd1,nd2;</span><br><span class="line">    vis[root]=<span class="number">1</span>; <span class="comment">//已经遍历过的点 要标记一下 不要</span></span><br><span class="line">    tree[root]=k;dis[root]=d;</span><br><span class="line">    <span class="comment">// ance[root]=root;</span></span><br><span class="line">    sz=node[root].size();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nd2=node[root][i].y;</span><br><span class="line">        <span class="keyword">if</span>(!vis[nd2])</span><br><span class="line">        &#123;</span><br><span class="line">            LCA(nd2,d+node[root][i].val,k);</span><br><span class="line">            <span class="comment">// Union(node[root][i].y,root);//用带rank的幷查集操作答案不对 不知道why</span></span><br><span class="line">            <span class="keyword">int</span> w=find(nd2),m=find(root);</span><br><span class="line">            <span class="keyword">if</span>(w!=m)</span><br><span class="line">            &#123;</span><br><span class="line">               pare[w]=m;<span class="comment">//这样才对</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ance[find(node[root][i].y)]=root;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sz=que[root].size();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nd1=root;</span><br><span class="line">        nd2=que[root][i].y;</span><br><span class="line">        <span class="keyword">if</span>(vis[nd2]&amp;&amp;tree[nd1]==tree[nd2])<span class="comment">//如果 nd1 nd2 的跟是同一个点 则是同一棵树上的</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[que[root][i].id]=dis[nd1]+dis[nd2]-<span class="number">2</span>*dis[find(nd2)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,x,y,val;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;c)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;val);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.y=y;temp.val=val;</span><br><span class="line">                node[x].push_back(temp);</span><br><span class="line">                temp.y=x;</span><br><span class="line">                node[y].push_back(temp);<span class="comment">//路是2个方向都可以通行的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            mid.id=i;</span><br><span class="line">            mid.y=y;</span><br><span class="line">            que[x].push_back(mid);</span><br><span class="line">            mid.y=x;</span><br><span class="line">            que[y].push_back(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LCA(i,<span class="number">0</span>,i);<span class="comment">//以每一个节点作为根节点去深度搜索  找出每个点作为根的所有最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==-<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not connected\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本题给的是一个森林 而不是一颗树，由于在加入边的时候，我们让2个方向都能走这样就形成了一个强连通的快，</span></span><br><span class="line"><span class="comment">//对于这个快来说，不管从快上那点出发 都可以遍历这个快上的所有的点，且相对距离是一样的</span></span><br></pre></td></tr></table></figure>
<p>代码转载自<a href="http://blog.csdn.net/hnust_xiehonghao/article/details/9109295" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/13/LCA之Tarjan算法/" data-id="ciqklv24a0052roqynxvwbp76" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图与树/">图与树</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/13/LCA之DFS-ST算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LCA之DFS+ST算法
        
      </div>
    </a>
  
  
    <a href="/2016/07/12/ST算法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ST算法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java底层机制/">Java底层机制</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图与树/">图与树</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Java底层机制/" style="font-size: 16.67px;">Java底层机制</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/图与树/" style="font-size: 16.67px;">图与树</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/13/LCA之DFS-ST算法/">LCA之DFS+ST算法</a>
          </li>
        
          <li>
            <a href="/2016/07/13/LCA之Tarjan算法/">LCA之Tarjan算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/ST算法/">ST算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/线段树/">线段树</a>
          </li>
        
          <li>
            <a href="/2016/07/12/并查集/">并查集</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>