<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>平衡二叉查找树(AVL树) | LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文转载自：一步一步写平衡二叉树（AVL树），个人感觉原文思路写的很好，也表达的很清楚，所以就转载一下，不过文中的代码感觉还有点小问题，但是结构写得很不错。
平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于">
<meta property="og:type" content="article">
<meta property="og:title" content="平衡二叉查找树(AVL树)">
<meta property="og:url" content="http://liubigbin.github.io/2016/03/12/平衡二叉查找树-AVL树/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description" content="本文转载自：一步一步写平衡二叉树（AVL树），个人感觉原文思路写的很好，也表达的很清楚，所以就转载一下，不过文中的代码感觉还有点小问题，但是结构写得很不错。
平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于">
<meta property="og:image" content="http://liubigbin.github.io/pictures/数据结构/树结构/AVL1.png">
<meta property="og:image" content="http://liubigbin.github.io/pictures/数据结构/树结构/AVL2.png">
<meta property="og:image" content="http://liubigbin.github.io/pictures/数据结构/树结构/AVL3.png">
<meta property="og:image" content="http://liubigbin.github.io/pictures/数据结构/树结构/AVL4.png">
<meta property="og:updated_time" content="2016-03-12T05:53:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="平衡二叉查找树(AVL树)">
<meta name="twitter:description" content="本文转载自：一步一步写平衡二叉树（AVL树），个人感觉原文思路写的很好，也表达的很清楚，所以就转载一下，不过文中的代码感觉还有点小问题，但是结构写得很不错。
平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-平衡二叉查找树-AVL树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/平衡二叉查找树-AVL树/" class="article-date">
  <time datetime="2016-03-12T05:24:02.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      平衡二叉查找树(AVL树)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转载自：<a href="http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html" target="_blank" rel="external">一步一步写平衡二叉树（AVL树）</a>，个人感觉原文思路写的很好，也表达的很清楚，所以就转载一下，不过文中的代码感觉还有点小问题，但是结构写得很不错。</p>
<p>平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><img src="/pictures/数据结构/树结构/AVL1.png" alt="两颗二叉查找树，只有右边的是AVL树"></p>
<h2 id="下面对于AVL树的构建进行描述："><a href="#下面对于AVL树的构建进行描述：" class="headerlink" title="下面对于AVL树的构建进行描述："></a>下面对于AVL树的构建进行描述：</h2><h4 id="第一步：节点信息"><a href="#第一步：节点信息" class="headerlink" title="第一步：节点信息"></a>第一步：节点信息</h4><p>相对于二叉查找树的节点来说，我们需要用一个属性二叉树的高度，目的是维护插入和删除过程中的旋转算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树节点信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode():lson(<span class="literal">NULL</span>),rson(<span class="literal">NULL</span>),freq(<span class="number">1</span>),hgt(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        T data;<span class="comment">//值</span></span><br><span class="line">        <span class="keyword">int</span> hgt;<span class="comment">//以此节点为根的树的高度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> freq;<span class="comment">//频率</span></span><br><span class="line">        TreeNode* lson;<span class="comment">//指向左儿子的地址</span></span><br><span class="line">        TreeNode* rson;<span class="comment">//指向右儿子的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第二步：平衡二叉树类的声明"><a href="#第二步：平衡二叉树类的声明" class="headerlink" title="第二步：平衡二叉树类的声明"></a>第二步：平衡二叉树类的声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树类的属性和方法声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> AVLTree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode&lt;T&gt;* root;<span class="comment">//根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insertpri</span><span class="params">(TreeNode&lt;T&gt;* &amp;node,T x)</span></span>;<span class="comment">//插入</span></span><br><span class="line">        TreeNode&lt;T&gt;* findpri(TreeNode&lt;T&gt;* node,T x);<span class="comment">//查找</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insubtree</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Deletepri</span><span class="params">(TreeNode&lt;T&gt;* &amp;node,T x)</span></span>;<span class="comment">//删除</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span>;<span class="comment">//求树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SingRotateLeft</span><span class="params">(TreeNode&lt;T&gt;* &amp;k2)</span></span>;<span class="comment">//左左情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SingRotateRight</span><span class="params">(TreeNode&lt;T&gt;* &amp;k2)</span></span>;<span class="comment">//右右情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateLR</span><span class="params">(TreeNode&lt;T&gt;* &amp;k3)</span></span>;<span class="comment">//左右情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateRL</span><span class="params">(TreeNode&lt;T&gt;* &amp;k3)</span></span>;<span class="comment">//右左情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> cmpa,<span class="keyword">int</span> cmpb)</span></span>;<span class="comment">//求最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        AVLTree():root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span></span>;<span class="comment">//插入接口</span></span><br><span class="line">        TreeNode&lt;T&gt;* find(T x);<span class="comment">//查找接口</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(T x)</span></span>;<span class="comment">//删除接口</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">()</span></span>;<span class="comment">//遍历接口</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第三步：两个辅助方法"><a href="#第三步：两个辅助方法" class="headerlink" title="第三步：两个辅助方法"></a>第三步：两个辅助方法</h4><p>　　旋转算法需要借助于两个功能的辅助，一个是求树的高度，一个是求两个高度的最大值。这里规定，一棵空树的高度为-1，只有一个根节点的树的高度为0，以后每多一层高度加1。为了解决指针NULL这种情况，写了一个求高度的函数，这个函数还是很有必要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算以节点为根的树的高度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::height(TreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;hgt;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最大值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::Max(<span class="keyword">int</span> cmpa,<span class="keyword">int</span> cmpb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cmpa&gt;cmpb?cmpa:cmpb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步：旋转"><a href="#第四步：旋转" class="headerlink" title="第四步：旋转"></a>第四步：旋转</h4><p>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：<br><img src="/pictures/数据结构/树结构/AVL2.png" alt="四种不平衡树的情况"></p>
<p>1、6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为<font color="red">左左</font>。</p>
<p>2、6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为<font color="red">左右</font>。</p>
<p>3、2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为<font color="red">右左</font>。</p>
<p>4、2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为<font color="red">右右</font>。</p>
<p>从图中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过<font color="red">一次旋转</font>就可以达到目标，我们称之为<font color="red">单旋转</font>。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行<font color="red">两次旋转</font>，我们称之为<font color="red">双旋转</font>。</p>
<h4 id="第五步：单旋转"><a href="#第五步：单旋转" class="headerlink" title="第五步：单旋转"></a>第五步：单旋转</h4><p>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p>
<p><img src="/pictures/数据结构/树结构/AVL3.png" alt="左左情况下的单旋转过程"></p>
<p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p>
<p>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左左情况下的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::SingRotateLeft(TreeNode&lt;T&gt;* &amp;k2)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* k1;</span><br><span class="line">    k1=k2-&gt;lson;</span><br><span class="line">    k2-&gt;lson=k1-&gt;rson;</span><br><span class="line">    k1-&gt;rson=k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    k1-&gt;hgt=Max(height(k1-&gt;lson),k2-&gt;hgt)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右右情况下的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::SingRotateRight(TreeNode&lt;T&gt;* &amp;k2)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* k1;</span><br><span class="line">    k1=k2-&gt;rson;</span><br><span class="line">    k2-&gt;rson=k1-&gt;lson;</span><br><span class="line">    k1-&gt;lson=k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    k1-&gt;hgt=Max(height(k1-&gt;rson),k2-&gt;hgt)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步：双旋转"><a href="#第六步：双旋转" class="headerlink" title="第六步：双旋转"></a>第六步：双旋转</h4><p>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p>
<p><img src="/pictures/数据结构/树结构/AVL4.png" alt="左右情况下的双旋转过程"></p>
<p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次<font color="red">右右旋转</font>，旋转之后就变成了<font color="red">左左</font>情况，所以第二步再进行一次<font color="red">左左旋转</font>，最后得到了一棵以k2为根的平衡二叉树树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右情况的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::DoubleRotateLR(TreeNode&lt;T&gt;* &amp;k3)</span><br><span class="line">&#123;</span><br><span class="line">    SingRotateRight(k3-&gt;lson);</span><br><span class="line">    SingRotateLeft(k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右左情况的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::DoubleRotateRL(TreeNode&lt;T&gt;* &amp;k3)</span><br><span class="line">&#123;</span><br><span class="line">    SingRotateLeft(k3-&gt;rson);</span><br><span class="line">    SingRotateRight(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第七步：插入"><a href="#第七步：插入" class="headerlink" title="第七步：插入"></a>第七步：插入</h4><p>插入的方法和二叉查找树基本一样，区别是，插入完成后需要从插入的节点开始维护一个到根节点的路径，每经过一个节点都要维持树的平衡。维持树的平衡要根据高度差的特点选择不同的旋转算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insertpri(TreeNode&lt;T&gt;* &amp;node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//如果节点为空,就在此节点处加入x信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        node=<span class="keyword">new</span> TreeNode&lt;T&gt;();</span><br><span class="line">        node-&gt;data=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;data&gt;x)<span class="comment">//如果x小于节点的值,就继续在节点的左子树中插入x</span></span><br><span class="line">    &#123;</span><br><span class="line">        insertpri(node-&gt;lson,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            <span class="keyword">if</span>(x&lt;node-&gt;lson-&gt;data)</span><br><span class="line">                SingRotateLeft(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                DoubleRotateLR(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;data&lt;x)<span class="comment">//如果x大于节点的值,就继续在节点的右子树中插入x</span></span><br><span class="line">    &#123;</span><br><span class="line">        insertpri(node-&gt;rson,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;rson)-height(node-&gt;lson))<span class="comment">//如果高度之差为2的话就失去了平衡,需要旋转</span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;node-&gt;rson-&gt;data)</span><br><span class="line">                SingRotateRight(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                DoubleRotateRL(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++(node-&gt;freq);<span class="comment">//如果相等,就把频率加1</span></span><br><span class="line">    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insert(T x)</span><br><span class="line">&#123;</span><br><span class="line">    insertpri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第八步：查找"><a href="#第八步：查找" class="headerlink" title="第八步：查找"></a>第八步：查找</h4><p>和二叉查找树相比，查找方法没有变法，不过根据存储的特性，AVL树能维持在一个O(logN)的稳定的时间，而二叉查找树则相当不稳定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::findpri(TreeNode&lt;T&gt;* node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//如果节点为空说明没找到,返回NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;data&gt;x)<span class="comment">//如果x小于节点的值,就继续在节点的左子树中查找x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findpri(node-&gt;lson,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;data&lt;x)<span class="comment">//如果x大于节点的值,就继续在节点的左子树中查找x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findpri(node-&gt;rson,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> node;<span class="comment">//如果相等,就找到了此节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::find(T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> findpri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第九步：删除"><a href="#第九步：删除" class="headerlink" title="第九步：删除"></a>第九步：删除</h4><p>删除的方法也和二叉查找树的一致，区别是，删除完成后，需要从删除节点的父亲开始向上维护树的平衡一直到根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::Deletepri(TreeNode&lt;T&gt;* &amp;node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> ;<span class="comment">//没有找到值是x的节点</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">         Deletepri(node-&gt;lson,x);<span class="comment">//如果x小于节点的值,就继续在节点的左子树中删除x</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;rson)-height(node-&gt;lson))</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;rson-&gt;lson!=<span class="literal">NULL</span>&amp;&amp;(height(node-&gt;rson-&gt;lson)&gt;height(node-&gt;rson-&gt;rson)) )</span><br><span class="line">                DoubleRotateRL(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                SingRotateRight(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">         Deletepri(node-&gt;rson,x);<span class="comment">//如果x大于节点的值,就继续在节点的右子树中删除x</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;lson-&gt;rson!=<span class="literal">NULL</span>&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))</span><br><span class="line">                DoubleRotateLR(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                SingRotateLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果相等,此节点就是要删除的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;lson&amp;&amp;node-&gt;rson)<span class="comment">//此节点有两个儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode&lt;T&gt;* temp=node-&gt;rson;<span class="comment">//temp指向节点的右儿子</span></span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;lson!=<span class="literal">NULL</span>) temp=temp-&gt;lson;<span class="comment">//找到右子树中值最小的节点</span></span><br><span class="line">            <span class="comment">//把右子树中最小节点的值赋值给本节点</span></span><br><span class="line">            node-&gt;data=temp-&gt;data;</span><br><span class="line">            node-&gt;freq=temp-&gt;freq;</span><br><span class="line">            Deletepri(node-&gt;rson,temp-&gt;data);<span class="comment">//删除右子树中最小值的节点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;lson-&gt;rson!=<span class="literal">NULL</span>&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))</span><br><span class="line">                    DoubleRotateLR(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    SingRotateLeft(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//此节点有1个或0个儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode&lt;T&gt;* temp=node;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;lson==<span class="literal">NULL</span>)<span class="comment">//有右儿子或者没有儿子</span></span><br><span class="line">            node=node-&gt;rson;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;rson==<span class="literal">NULL</span>)<span class="comment">//有左儿子</span></span><br><span class="line">            node=node-&gt;lson;</span><br><span class="line">            <span class="keyword">delete</span>(temp);</span><br><span class="line">            temp=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::Delete(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Deletepri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第十步：中序遍历"><a href="#第十步：中序遍历" class="headerlink" title="第十步：中序遍历"></a>第十步：中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insubtree(TreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    insubtree(node-&gt;lson);<span class="comment">//先遍历左子树</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;node-&gt;data&lt;&lt;<span class="string">" "</span>;<span class="comment">//输出根节点</span></span><br><span class="line">    insubtree(node-&gt;rson);<span class="comment">//再遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::traversal()</span><br><span class="line">&#123;</span><br><span class="line">    insubtree(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第十一步：关于效率"><a href="#第十一步：关于效率" class="headerlink" title="第十一步：关于效率"></a>第十一步：关于效率</h4><p>此数据结构插入、查找和删除的时间复杂度均为O(logN)，但是插入和删除需要额外的旋转算法需要的时间，有时旋转过多也会影响效率。</p>
<p>关于递归和非递归。我用的是递归的方法进行插入，查找和删除，而非递归的方法一般来说要比递归的方法快很多，但是我感觉非递归的方法写出来会比较困难，所以我还是选择了递归的方法。</p>
<p>还有一种效率的问题是关于高度信息的存储，由于我们需要的仅仅是高度的差，不需要知道这棵树的高度，所以只需要使用两个二进制位就可以表示这个差。这样可以避免平衡因子的重复计算，可以稍微的加快一些速度，不过代码也丧失了相对简明性和清晰度。如果采用递归写法的话，这种微加速就更显得微乎其微了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/12/平衡二叉查找树-AVL树/" data-id="cilz68piw000v04qy971g17cd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树结构/">树结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/14/TCP_IP模型常用协议/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TCP/IP模型常用协议
        
      </div>
    </a>
  
  
    <a href="/2016/03/11/Linux-之守护进程、僵死进程与孤儿进程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux 之守护进程、僵死进程与孤儿进程</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux-网络编程/" style="font-size: 12.5px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 20px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 17.5px;">Linux用户管理</a> <a href="/tags/TCP-IP/" style="font-size: 17.5px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 15px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 12.5px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 12.5px;">爬虫</a> <a href="/tags/随记/" style="font-size: 12.5px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/19/malloc函数的实现原理/">malloc函数的实现原理</a>
          </li>
        
          <li>
            <a href="/2016/03/19/Linux-内存管理/">Linux 内存管理</a>
          </li>
        
          <li>
            <a href="/2016/03/18/MySQL索引算法原理/">MySQL索引算法原理</a>
          </li>
        
          <li>
            <a href="/2016/03/18/那家姓B的树/">那家姓B的树</a>
          </li>
        
          <li>
            <a href="/2016/03/17/第K小元素选择算法/">第K小元素选择算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>