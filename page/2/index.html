<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/page/2/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-typedef与define的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/typedef与define的区别/" class="article-date">
  <time datetime="2016-04-12T02:50:47.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/typedef与define的区别/">typedef与define的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef故名思意就是类型定义的意思，但是它并不是定义一个新的类型而是给已有的类型起一个别名，在这一点上与引用的含义类似，引用是变量或对象的别名，而typedef定义的是类型的别名。typedef的作用主要有两点：</p>
<h4 id="1-1-简化复杂的类型声明"><a href="#1-1-简化复杂的类型声明" class="headerlink" title="1.1  简化复杂的类型声明"></a>1.1  简化复杂的类型声明</h4><p>简化复杂的类型声明，或给已有类型起一含义明确的别名；如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个返回 bool 类型并带有两个(int和double)形参的函数的指针类型FuncPointer</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncPointer)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了一个FuncPointer类型的函数指针对象pFunc</span></span><br><span class="line">FuncPointer pFunc;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-定义与平台无关的类型"><a href="#1-2-定义与平台无关的类型" class="headerlink" title="1.2  定义与平台无关的类型"></a>1.2  定义与平台无关的类型</h4><p>定义与平台无关的类型，屏蔽不同平台的类型差异化；如：<br>用typedef来定义与平台无关的类型。<br>比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：<br>typedef long double REAL;<br>在不支持 long double 的平台二上，改为：<br>typedef double REAL;<br>在连 double 都不支持的平台三上，改为：<br>typedef float REAL;<br>也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。<br>标准库就广泛使用了这个技巧，比如size_t。另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健。</p>
<h4 id="1-3-与struct的结合使用"><a href="#1-3-与struct的结合使用" class="headerlink" title="1.3  与struct的结合使用"></a>1.3  与struct的结合使用</h4><p>在C++中，struct与class的作用相同，就是默认的访问权限不同，struct默认为public，而class默认为private的。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Person  </span><br><span class="line">&#123;  </span><br><span class="line">    string name<span class="comment">;  </span></span><br><span class="line">    int age<span class="comment">;  </span></span><br><span class="line">    float height<span class="comment">;  </span></span><br><span class="line">&#125;<span class="comment">;  </span></span><br><span class="line">Person person<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，定义一个Person的对象person。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure>
<p>定义一个Struct的类型Person，在定义的同时还声明了一个Person的对象person。</p>
<p>但是在C语言中，struct的定义和声明要用typedef。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;Person;    <span class="comment">//这是Person是结构体的一个别名  </span></span><br><span class="line">Person person;</span><br></pre></td></tr></table></figure></p>
<p>如果没有typedef就必须用struct Person person;来声明，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">struct</span> Person person;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">float</span> height;  </span><br><span class="line">&#125;person;    <span class="comment">//person是Person的对象</span></span><br></pre></td></tr></table></figure></p>
<h2 id="typedef与-define的区别"><a href="#typedef与-define的区别" class="headerlink" title="typedef与#define的区别"></a>typedef与#define的区别</h2><h4 id="2-1-执行时间不同"><a href="#2-1-执行时间不同" class="headerlink" title="2.1.  执行时间不同"></a>2.1.  执行时间不同</h4><p>关键字typedef在编译阶段有效，由于是在编译阶段，因此typedef有类型检查的功能。</p>
<p>#define则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。<br>typedef会做相应的类型检查：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT value = <span class="string">"abc"</span>; <span class="comment">// error C2440: 'initializing' : cannot convert from 'const char [4]' to 'UINT'  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#define不做类型检查：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define用法例子：  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> f(x) x*x  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">6</span>, b=<span class="number">2</span>, c;  </span><br><span class="line">    c=f(a) / f(b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是: 36，根本原因就在于#define只是简单的字符串替换。</p>
<h4 id="2-2-功能有差异"><a href="#2-2-功能有差异" class="headerlink" title="2.2. 功能有差异"></a>2.2. 功能有差异</h4><p>typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。</p>
<p>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
<h4 id="2-3．作用域不同"><a href="#2-3．作用域不同" class="headerlink" title="2.3．作用域不同"></a>2.3．作用域不同</h4><p>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。<br>而typedef有自己的作用域。</p>
<p>【例2.3.1】没有作用域的限制，只要是之前预定义过就可以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="preprocessor">#<span class="keyword">define</span> HW <span class="string">"HelloWorld"</span>;  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> str = HW;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【例<span class="number">2.3</span><span class="number">.2</span>】而<span class="keyword">typedef</span>有自己的作用域</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    UINT uValue = <span class="number">5</span>;<span class="comment">//error C2065: 'UINT' : undeclared identifier  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例2.3.3】<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    typedef unsigned <span class="keyword">int</span> <span class="keyword">UINT</span>;  </span><br><span class="line">    <span class="keyword">UINT</span> valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">UINT</span> valueB;  </span><br><span class="line">    <span class="comment">//error C2146: syntax error : missing ';' before identifier 'valueB'  </span></span><br><span class="line">    <span class="comment">//error C4430: missing type specifier - int assumed. Note: C++ does not support default-int  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面例子在B类中使用UINT会出错，因为UINT只在类A的作用域中。此外，在类中用typedef定义的类型别名还具有相应的访问权限<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// error C2248: 'A::UINT' : cannot access private typedef declared in class 'A'  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而给UINT加上public访问权限后，则可编译通过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;  </span><br><span class="line">    UINT valueA;  </span><br><span class="line">    A() : valueA(<span class="number">0</span>)&#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    A::UINT i = <span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4．-对指针的操作"><a href="#2-4．-对指针的操作" class="headerlink" title="2.4． 对指针的操作"></a>2.4． 对指针的操作</h4><p>二者修饰指针类型时，作用不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * pint;  </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PINT int *  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;    <span class="comment">//p不可更改，p指向的内容可以更改，相当于 int * const p;  </span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;    <span class="comment">//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；  </span></span><br><span class="line"></span><br><span class="line">pint s1, s2;    <span class="comment">//s1和s2都是int型指针  </span></span><br><span class="line">PINT s3, s4;    <span class="comment">//相当于int * s3，s4；只有一个是指针。  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//p1 = &amp;i2; //error C3892: 'p1' : you cannot assign to a variable that is const  </span></span><br><span class="line">    *p1 = <span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">"  *p1:"</span> &lt;&lt; *p1 &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//*p2 = 10; //error C3892: 'p2' : you cannot assign to a variable that is const  </span></span><br><span class="line">    p2 = &amp;i1;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">"  *p2:"</span> &lt;&lt; *p2 &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">1</span></span><br><span class="line">p1:<span class="number">00</span>EFD094  *p1:<span class="number">5</span></span><br><span class="line">p2:<span class="number">00</span>EFD098  *p2:<span class="number">2</span></span><br><span class="line">p2:<span class="number">00</span>EFD094  *p2:<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.csdn.net/luoweifu/article/details/41630195" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/12/typedef与define的区别/" data-id="ciq4t54r7002gmgqyv903oab8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-epoll之ET和LT编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/epoll之ET和LT编程/" class="article-date">
  <time datetime="2016-04-07T07:45:11.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/epoll之ET和LT编程/">epoll之ET和LT编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在一个非阻塞的socket上调用read/write函数, 返回EAGAIN或者EWOULDBLOCK(注: EAGAIN就是EWOULDBLOCK)<br>从字面上看, 意思是:EAGAIN: 再试一次，EWOULDBLOCK: 如果这是一个阻塞socket, 操作将被block，perror输出: Resource temporarily unavailable</p>
<p>总结:<br>这个错误表示资源暂时不够，能read时，读缓冲区没有数据，或者write时，写缓冲区满了。遇到这种情况，如果是阻塞socket，read/write就要阻塞掉。而如果是非阻塞socket，read/write立即返回-1， 同时errno设置为EAGAIN。<br>所以，对于阻塞socket，read/write返回-1代表网络出错了。但对于非阻塞socket，read/write返回-1不一定网络真的出错了。可能是Resource temporarily unavailable。这时你应该再试，直到Resource available。</p>
<p>综上，对于non-blocking的socket，正确的读写操作为:<br>读：忽略掉errno = EAGAIN的错误，下次继续读<br>写：忽略掉errno = EAGAIN的错误，下次继续写</p>
<p>对于select和epoll的LT模式，这种读写方式是没有问题的。但对于epoll的ET模式，这种方式还有漏洞。</p>
<p>epoll的两种模式LT和ET<br>二者的差异在于level-trigger模式下只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket；而edge-trigger模式下只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</p>
<p>所以，在epoll的ET模式下，正确的读写方式为:<br>读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN<br>写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN</p>
<p>正确的读<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">    perror(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正确的写</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int nwrite, data_size = <span class="literal">strlen</span>(buf);</span><br><span class="line"><span class="keyword">n</span> = data_size;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">n</span> &gt; 0) &#123;</span><br><span class="line">    nwrite = write(fd, buf + data_size - <span class="keyword">n</span>, <span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">if</span> (nwrite &lt; <span class="keyword">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nwrite == -1 &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">            perror(<span class="string">"write error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">n</span> -= nwrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确的accept，accept-要考虑-2-个问题"><a href="#正确的accept，accept-要考虑-2-个问题" class="headerlink" title="正确的accept，accept 要考虑 2 个问题"></a>正确的accept，accept 要考虑 2 个问题</h3><h4 id="1-阻塞模式-accept-存在的问题"><a href="#1-阻塞模式-accept-存在的问题" class="headerlink" title="(1) 阻塞模式 accept 存在的问题"></a>(1) 阻塞模式 accept 存在的问题</h4><p>考虑这种情况：TCP连接被客户端夭折，即在服务器调用accept之前，客户端主动发送RST终止连接，导致刚刚建立的连接从就绪队列中移出，如果套接口被设置成阻塞模式，服务器就会一直阻塞在accept调用上，直到其他某个客户建立一个新的连接为止。但是在此期间，服务器单纯地阻塞在accept调用上，就绪队列中的其他描述符都得不到处理。</p>
<p>解决办法是把监听套接口设置为非阻塞，当客户在服务器调用accept之前中止某个连接时，accept调用可以立即返回-1，这时源自Berkeley的实现会在内核中处理该事件，并不会将该事件通知给epool，而其他实现把errno设置为ECONNABORTED或者EPROTO错误，我们应该忽略这两个错误。</p>
<h4 id="2-ET模式下accept存在的问题"><a href="#2-ET模式下accept存在的问题" class="headerlink" title="(2)ET模式下accept存在的问题"></a>(2)ET模式下accept存在的问题</h4><p>考虑这种情况：多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。</p>
<p>解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。</p>
<p>综合以上两种情况，服务器应该使用非阻塞地accept，accept在ET模式下的正确使用方式为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote, (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    handle_client(conn_sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">    perror(<span class="string">"accept"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll ET 模式简单HTTP服务器代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_EVENTS <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT <span class="number">8080</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置socket连接为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts;</span><br><span class="line"></span><br><span class="line">    opts = fcntl(sockfd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_GETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = (opts | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(sockfd, F_SETFL, opts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(F_SETFL)\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev, events[MAX_EVENTS];</span><br><span class="line">    <span class="keyword">int</span> addrlen, listenfd, conn_sock, nfds, epfd, fd, i, nread, n;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in local, remote;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建listen socket</span></span><br><span class="line">    <span class="keyword">if</span>( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sockfd\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setnonblocking(listenfd);</span><br><span class="line">    bzero(&amp;local, <span class="keyword">sizeof</span>(local));</span><br><span class="line">    local.sin_family = AF_INET;</span><br><span class="line">    local.sin_addr.s_addr = htonl(INADDR_ANY);;</span><br><span class="line">    local.sin_port = htons(PORT);</span><br><span class="line">    <span class="keyword">if</span>( bind(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;local, <span class="keyword">sizeof</span>(local)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    epfd = epoll_create(MAX_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epfd == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"epoll_ctl: listen_sock"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nfds = epoll_wait(epfd, events, MAX_EVENTS, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == -<span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_pwait"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            fd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (fd == listenfd) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((conn_sock = accept(listenfd,(<span class="keyword">struct</span> sockaddr *) &amp;remote,</span><br><span class="line">                                (<span class="keyword">size_t</span> *)&amp;addrlen)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    setnonblocking(conn_sock);</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = conn_sock;</span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                                &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"epoll_ctl: add"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (conn_sock == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != ECONNABORTED</span><br><span class="line">                            &amp;&amp; errno != EPROTO &amp;&amp; errno != EINTR)</span><br><span class="line">                        perror(<span class="string">"accept"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((nread = read(fd, buf + n, BUFSIZ-<span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    n += nread;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nread == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                    perror(<span class="string">"read error"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ev.data.fd = fd;</span><br><span class="line">                ev.events = events[i].events | EPOLLOUT;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &amp;ev) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">"epoll_ctl: mod"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\nHello World"</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">int</span> nwrite, data_size = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                n = data_size;</span><br><span class="line">                <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nwrite = write(fd, buf + data_size - n, n);</span><br><span class="line">                    <span class="keyword">if</span> (nwrite &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nwrite == -<span class="number">1</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">                            perror(<span class="string">"write error"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    n -= nwrite;</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://www.ccvita.com/515.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/epoll之ET和LT编程/" data-id="ciq4t54rh002umgqy405qx59d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-socket非阻塞读写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/socket非阻塞读写/" class="article-date">
  <time datetime="2016-04-07T07:39:46.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/socket非阻塞读写/">socket非阻塞读写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>对于阻塞的socket,当socket的接收缓冲区中没有数据时，read调用会一直阻塞住，直到有数据到来才返回。当socket缓冲区中的数据量小于期望读取的数据量时，返回实际读取的字节数。当sockt的接收缓冲区中的数据大于期望读取的字节数时，读取期望读取的字节数，返回实际读取的长度。对于非阻塞socket而言，socket的接收缓冲区中有没有数据，read调用都会立刻返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的，如果接收缓冲区中没有数据，则返回-1，错误号为EWOULDBLOCK或EAGAIN,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。如果返回值是其它负值，则表明读取错误。因此，非阻塞的read调用一般这样写:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(sock_fd, buffer, <span class="built_in">len</span>) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//没有读到数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读取失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment"></span><br><span class="line">//读到数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>对于写操作write,原理是类似的，非阻塞socket在发送缓冲区没有空间时会直接返回-1，错误号EWOULDBLOCK或EAGA,表示没有空间可写数据，如果错误号是别的值，则表明发送失败。如果发送缓冲区中有足够空间或者是不足以拷贝所有待发送数据的空间的话，则拷贝前面N个能够容纳的数据，返回实际拷贝的字节数。而对于阻塞Socket而言，如果发送缓冲区没有空间或者空间不足的话，write操作会直接阻塞住，如果有足够空间，则拷贝所有数据到发送缓冲区，然后返回.非阻塞的write操作一般写法是:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> write_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nLeft = nLen;</span><br><span class="line"><span class="keyword">while</span>(nLeft &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nWrite = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( (nWrite = write(sock_fd, data+write_pos, nLeft)) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EWOULDBLOCK || errno == EAGAIN)</span><br><span class="line">&#123;</span><br><span class="line">nWrite = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//写失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">nLeft -= nWrite;</span><br><span class="line">wirte_pos += nWrite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上内容转自<a href="http://blog.163.com/hbu_lijian/blog/static/126129153201311742750909/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/socket非阻塞读写/" data-id="ciq4t54ra002mmgqys96039v3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-之auto、static、extern、register" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/C-之auto、static、extern、register/" class="article-date">
  <time datetime="2016-04-07T02:56:21.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/C-之auto、static、extern、register/">C++之auto、static、extern、register</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>extern 用来声明一个外部变量或是函数，表示该变量已经在其他的地方定义了，这里只是做一个引用而已，不会产生新的变量。对于extern修饰的变量，编译器会在所在的文件先看看有没有对该变量的定义，有的话，直接应用，没有的话再到其他的文件里面进行查找。由于变量已经在其他的地方定义了，所以<code>extern int a = 10;</code>这种写法是不对的，会造成重定义错误！</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static可以用来修饰变量和函数。</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><p>static修饰的变量都存在静态数据区里面，由于静态数据区内存都是被系统初始化为0的，所以static修饰的变量默认初始值为0。<br>static修饰的变量的作用域只限制于该变量所在的文件，外面的文件不可以使用该变量，所以多个文件可以有相同的变量名（需要使用static修饰），只要在编译的最后链接阶段，在全局情况下，不出现相同的变量名就好。</p>
<h4 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h4><p>static修饰的函数主要有两个作用：限定该函数的作用域为本文件可见以及static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝，因此对于static函数的调用会比普通函数快很多。</p>
<h4 id="类中的static"><a href="#类中的static" class="headerlink" title="类中的static"></a>类中的static</h4><p>在类中，static修饰的成员变量或是函数表明该变量或是函数是属于类的，所以没有对应的this指针。static修饰的函数只能访问类的static修饰的成员变量，并且static修饰的函数不能是虚函数。</p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序都变量大多是自动变量。auto不能修饰全局变量，因为该变量的内存是放在栈上面的，有系统自动创建和销毁，所以不能用来修饰全局变量。在函数里面，一般所声明的变量都是直接的默认为auto的。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行。系统的寄存器是有限制的,声明变量时如:<code>register int i</code>.这种存储类型可以用于频繁使用的变量。实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。</p>
<p>使用register修饰符有几点限制</p>
<p>（1）register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。最好不要这样去用</p>
<p>（2）因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。</p>
<p>（3）只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。所以说不要用register修饰全局变量等，因为他长时间的占用寄存器不允许再被使用了。</p>
<p>（4）局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c，同样的道理，因为static变量函数结束不会被销毁，下面进入还会使用之前的数据，生命周期直到程序退出才结束，数据存放在静态区。</p>
<p>（5）由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。</p>
<p>auto register 是用来修饰变量的,static extern 变量函数都可以</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/07/C-之auto、static、extern、register/" data-id="ciq4t54sj004tmgqyrfptisku" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LinuxIO读取函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/LinuxIO读取函数/" class="article-date">
  <time datetime="2016-04-06T08:43:03.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/LinuxIO读取函数/">Linux IO 读写函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux IO 读取分两种类型，一种是本地文件的读取，一种是网络通信的读取</p>
<h2 id="本地文件的读取函数"><a href="#本地文件的读取函数" class="headerlink" title="本地文件的读取函数"></a>本地文件的读取函数</h2><p>对于本地文件的读取，Linux有两种方式，一种是有缓存的，另一种是没有缓存的。</p>
<h3 id="带缓存的文件读取"><a href="#带缓存的文件读取" class="headerlink" title="带缓存的文件读取"></a>带缓存的文件读取</h3><p>该类型会在内存开辟一个“缓冲区”，为程序中的每一个文件使用；当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读出需要的数据。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p>
<p>主要的函数有：<code>fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind</code>等。</p>
<h3 id="不带缓存的文件读取"><a href="#不带缓存的文件读取" class="headerlink" title="不带缓存的文件读取"></a>不带缓存的文件读取</h3><p>依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度快。主要的函数有：<code>open, close, read, write, getc, getchar, putc, putchar, feof, ferror</code>等</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><ol>
<li>open是UNIX系统调用函数（包括LINUX等），返回的是文件描述符（File Descriptor），它是文件在文件描述符表里的索引。</li>
<li>fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api。返回的是一个指向文件结构的指针。</li>
</ol>
<h4 id="移植性"><a href="#移植性" class="headerlink" title="移植性"></a>移植性</h4><p>这一点从上面的来源就可以推断出来，<code>fopen</code>是C标准函数，因此拥有良好的移植性；而<code>open</code>是UNIX系统调用，移植性有限。如windows下相似的功能使用API函数<code>CreateFile</code>。</p>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ol>
<li>open返回文件描述符，而文件描述符是UNIX系统下的一个重要概念，UNIX下的一切设备都是以文件的形式操作。如网络套接字、硬件设备等。当然包括操作普通正规文件（Regular File）。</li>
<li>fopen是用来操纵普通正规文件（Regular File）的。</li>
</ol>
<h4 id="文件IO层次"><a href="#文件IO层次" class="headerlink" title="文件IO层次"></a>文件IO层次</h4><p>如果从文件IO的角度来看，前者属于低级IO函数，后者属于高级IO函数。低级和高级的简单区分标准是：谁离系统内核更近。低级文件IO运行在内核态，高级文件IO运行在用户态。</p>
<p>使用fopen函数，由于在用户态下就有了缓冲，因此进行文件读写操作的时候就减少了用户态和内核态的切换（切换到内核态调用还是需要调用系统调用API:read，write）；而使用open函数，在文件读写时则每次都需要进行内核态和用户态的切换；表现为，如果顺序访问文件，fopen系列的函数要比直接调用open系列的函数快；如果随机访问文件则相反。</p>
<h2 id="网络IO的读取"><a href="#网络IO的读取" class="headerlink" title="网络IO的读取"></a>网络IO的读取</h2><p>网络IO的读取主要针对的是socket，主要有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>*buf,<span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbyte)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span>  </span><br><span class="line"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span> *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure></p>
<p>recv和send与read和write的不同就是函数参数多了一个标志，该标志如果为0的话，那么其作用就相当于read和write函数了。<br>flag的取值可以为0或是下面的组合：</p>
<p>MSG_DONTROUTE:是send函数使用的标志.这个标志告诉IP.目的主机在本地网络上面,没有必要查找表.这个标志一般用网络诊断和路由程序里面.<br>MSG_OOB:表示可以接收和发送带外的数据.关于带外数据我们以后会解释的.</p>
<p>MSG_PEEK:是recv函数的使用标志,表示只是从系统缓冲区中读取内容,而不清除系统缓冲区的内容.这样下次读的时候,仍然是一样的内容.一般在有多个进程读写数据时可以使用这个标志.</p>
<p>MSG_WAITALL是recv函数的使用标志,表示等到所有的信息到达时才返回.使用这个标志的时候recv回一直阻塞,直到指定的条件满足,或者是发生了错误. 1)当读到了指定的字节时,函数正常返回.返回值等于len 2)当读到了文件的结尾时,函数正常返回.返回值小于len 3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)</p>
<p>以上四个函数只适合与面向连接的套接字。对于UDP这样的非连接，需要使用下面的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/socket.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd,  <span class="keyword">struct</span> msghdr * msg, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd,  <span class="keyword">struct</span> msghdr * msg, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>成功时候返回读写字节数，出错时候返回-1.</p>
<p>这2个函数只用于套接口，不能用于普通的I/O读写，参数sockfd则是指明要读写的套接口。<br>flags用于传入控制信息，一般包括以下几个<br>MSG_DONTROUTE             send可用<br>MSG_DONWAIT                 send与recv都可用<br>MSG_PEEK                        recv可用<br>MSG_WAITALL                   recv可用<br>MSG_OOB                         send可用<br>MSG_EOR                          send recv可用</p>
<p>返回信息都记录在struct msghdr * msg中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msghdr &#123;</span><br><span class="line">        <span class="comment">//协议地址和套接口信息，在非连接的UDP中，发送者要指定对方地址端口，接受方用于的到数据来源，如果不需要的话</span></span><br><span class="line">        <span class="comment">//可以设置为NULL（在TCP或者连接的UDP中，一般设置为NULL）。</span></span><br><span class="line">        <span class="keyword">void</span> * msg_name;</span><br><span class="line">        <span class="keyword">socklen_t</span> msg_namelen;<span class="comment">//上面的长度</span></span><br><span class="line">        <span class="keyword">struct</span> lovec * msg_lov;</span><br><span class="line">        <span class="keyword">ssize_t</span> msg_lovlen;<span class="comment">//和readv和writev一样</span></span><br><span class="line">        <span class="keyword">void</span> * msg_control;</span><br><span class="line">        <span class="keyword">socklen_t</span> msg_controllen;</span><br><span class="line">        <span class="keyword">int</span> msg_flags; <span class="comment">//用于返回之前flags的控制信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是该函数使用的例子：</p>
<p>下面的源码来自<a href="http://memorymyann.iteye.com/blog/648513" target="_blank" rel="external">这里</a></p>
<p>服务器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argu)</span> </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;<span class="comment">//初始化struct msghdr</span></span><br><span class="line">        msg.msg_name = <span class="literal">NULL</span>; <span class="comment">//在tcp中，可以设置为NULL</span></span><br><span class="line">        <span class="keyword">struct</span> iovec io;<span class="comment">//初始化返回数据</span></span><br><span class="line">        io.iov_base = buf; <span class="comment">//只用了一个缓冲区</span></span><br><span class="line">        io.iov_len = MAXSIZE; <span class="comment">//定义返回数据长度</span></span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;<span class="comment">//只用了一个缓冲区，所以长度为1</span></span><br><span class="line"></span><br><span class="line">        ...................</span><br><span class="line">        <span class="keyword">ssize_t</span> recv_size = recvmsg(connfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> * temp = msg.msg_iov[<span class="number">0</span>].iov_base;<span class="comment">//获取得到的数据</span></span><br><span class="line">        temp[recv_size] = <span class="string">'\0'</span>;<span class="comment">//为数据末尾添加结束符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get message:%s"</span>, temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        .................</span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;<span class="comment">//初始化发送信息</span></span><br><span class="line">        msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = send_buff;</span><br><span class="line">        io.iov_len = <span class="keyword">sizeof</span>(send_buff);</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"please input port"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> size = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里控制信息都设置成0，主要是初始化返回信息struct msghdr结构。</p>
<p>未连接的UDP套接口<br>服务器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"/programe/net/head.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdlib.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unistd.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/wait.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/select.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/poll.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in serv_socket;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in *client_socket = (<span class="keyword">struct</span> sockaddr_in *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">        <span class="keyword">char</span> buf[MAXSIZE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line">        serv_socket.sin_family = AF_INET;</span><br><span class="line">        serv_socket.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_socket.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;</span><br><span class="line">        msg.msg_name = client_socket;</span><br><span class="line">        <span class="comment">//如果想得到对方的地址和端口，一定要把初始化完毕的内存头指针放入msg之中</span></span><br><span class="line">        msg.msg_namelen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);<span class="comment">//长度也要指定</span></span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = buf;</span><br><span class="line">        io.iov_len = MAXSIZE;</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> len = recvmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        client_socket = (<span class="keyword">struct</span> sockaddr_in *)msg.msg_name;</span><br><span class="line">        <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">        inet_ntop(AF_INET, &amp;(client_socket-&gt;sin_addr), ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">        <span class="keyword">int</span> port = ntohs(client_socket-&gt;sin_port);</span><br><span class="line">        <span class="keyword">char</span> * temp = msg.msg_iov[<span class="number">0</span>].iov_base;</span><br><span class="line">        temp[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get message from %s[%d]: %s\n"</span>, ip, port, temp);</span><br><span class="line">        close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"/programe/net/head.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"stdlib.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sys/select.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in serv_socket;</span><br><span class="line">        <span class="keyword">int</span> maxfdpl;</span><br><span class="line">        <span class="keyword">char</span> send[] = <span class="string">"hello yuna"</span>;</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"please input port"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        bzero(&amp;serv_socket, <span class="keyword">sizeof</span>(serv_socket));</span><br><span class="line">        serv_socket.sin_family = AF_INET;</span><br><span class="line">        serv_socket.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        inet_pton(AF_INET, <span class="string">"192.168.1.235"</span>, &amp;serv_socket.sin_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> msghdr msg;</span><br><span class="line">        msg.msg_name = &amp;serv_socket;</span><br><span class="line">        msg.msg_namelen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">        <span class="keyword">struct</span> iovec io;</span><br><span class="line">        io.iov_base = send;</span><br><span class="line">        io.iov_len = <span class="keyword">sizeof</span>(send);</span><br><span class="line">        msg.msg_iov = &amp;io;</span><br><span class="line">        msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> send_size = sendmsg(sockfd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendto和recvfrom<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span> <span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="keyword">int</span> tolen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="keyword">int</span> *fromlen)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对于sendto()函数，成功则返回实际传送出去的字符数，失败返回-1，错误原因存于errno 中。</p>
<p>对于recvfrom()函数，成功则返回接收到的字符数，失败则返回-1，错误原因存于errno中。</p>
<p>如果需要在TCP的socket中使用该函数，那么可以直接的对函数最后的两个参数设为NULL。</p>
<p>UDP Server和Client源码实例:</p>
<p>一下源码来自<a href="http://velep.com/archives/934.html" target="_blank" rel="external">这里</a><br>服务端：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	UDP_TEST_PORT		<span class="number">50001</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> sockfd, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 建立socket，注意必须是SOCK_DGRAM */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror (<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 填写sockaddr_in 结构 */</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(UDP_TEST_PORT);</span><br><span class="line">	addr.sin_addr.s_addr = htonl(INADDR_ANY) ;<span class="comment">// 接收任意IP发来的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 绑定socket */</span></span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"connect"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">		len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>,</span><br><span class="line">					   (<span class="keyword">struct</span> sockaddr *)&amp;addr ,&amp;addr_len);</span><br><span class="line">		<span class="comment">/* 显示client端的网络地址和收到的字符串消息 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Received a string from client %s, string is: %s\n"</span>,</span><br><span class="line">				inet_ntoa(addr.sin_addr), buffer);</span><br><span class="line">		<span class="comment">/* 将收到的字符串消息返回给client端 */</span></span><br><span class="line">		sendto(sockfd,buffer, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, addr_len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// End of udp_server.c</span></span><br></pre></td></tr></table></figure></p>
<p>UDP 客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	UDP_TEST_PORT		<span class="number">50001</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> UDP_SERVER_IP 		<span class="string">"127.0.0.1"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> sockfd, len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);		</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 建立socket，注意必须是SOCK_DGRAM */</span></span><br><span class="line">	<span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 填写sockaddr_in*/</span></span><br><span class="line">	bzero(&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(UDP_TEST_PORT);</span><br><span class="line">	addr.sin_addr.s_addr = inet_addr(UDP_SERVER_IP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Please enter a string to send to server: \n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从标准输入设备取得字符串*/</span></span><br><span class="line">		len = read(STDIN_FILENO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将字符串传送给server端*/</span></span><br><span class="line">		sendto(sockfd, buffer, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;addr, addr_len);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 接收server端返回的字符串*/</span></span><br><span class="line">		len = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>,</span><br><span class="line">				       (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addr_len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Receive from server: %s\n"</span>, buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// End of udp_client.c</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/06/LinuxIO读取函数/" data-id="ciq4t54s1003vmgqyzw01tajn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Boost智能指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/23/Boost智能指针/" class="article-date">
  <time datetime="2016-03-23T14:28:35.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/Boost智能指针/">Boost智能指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Boost 只能指针常用的有四种，分别为：shared_ptr、weak_ptr、auto_ptr以及scoped_ptr指针。</p>
<h2 id="shared-ptr指针"><a href="#shared-ptr指针" class="headerlink" title="shared_ptr指针"></a>shared_ptr指针</h2><p>shared_ptr指针就是所谓的只能计数指针，用来管理非栈上的内存指针。它可以从一个裸指针、另一个shared_ptr、一个auto_ptr、或者一个weak_ptr构造。还可以传递第二个参数给shared_ptr的构造函数，它被称为删除器（deleter）。删除器用于处理共享资源的释放，这对于管理那些不是用new分配也不是用delete释放的资源时非常有用。shared_ptr被创建后，就可以像普通指针一样使用了，除了一点，它不能被显式地删除。</p>
<p>shared_ptr指针的使用如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt1;</span><br><span class="line">assert(pInt1.use_count() == <span class="number">0</span>);         <span class="comment">// 还没有引用指针</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pInt2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>));</span><br><span class="line">      assert(pInt2.use_count() == <span class="number">1</span>);        <span class="comment">// new int(5)这个指针被引用1次</span></span><br><span class="line"></span><br><span class="line">    pInt1 = pInt2;</span><br><span class="line">      assert(pInt2.use_count() == <span class="number">2</span>);       <span class="comment">// new int(5)这个指针被引用2次</span></span><br><span class="line">    assert(pInt1.use_count() == <span class="number">2</span>);</span><br><span class="line">&#125;                                                   <span class="comment">//pInt2离开作用域, 所以new int(5)被引用次数-1</span></span><br><span class="line"></span><br><span class="line">assert(pInt1.use_count() == <span class="number">1</span>);</span><br><span class="line">&#125;         <span class="comment">// pInt1离开作用域，引用次数-1,现在new int(5)被引用0次，所以销毁它</span></span><br></pre></td></tr></table></figure></p>
<p>如果资源的创建销毁不是以new和delete的方式进行的，该怎么办呢？通过前面的接口可以看到，shared_ptr的构造函数中可以指定删除器。示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FileCloser</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE \*pf)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (pf != <span class="literal">NULL</span>)</span><br><span class="line">         &#123;</span><br><span class="line">               fclose(pf);</span><br><span class="line">               pf = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;FILE&gt; fp(fopen(pszConfigFile, <span class="string">"r"</span>), FileCloser());</span><br></pre></td></tr></table></figure></p>
<p>在使用shared_ptr时，需要避免同一个对象指针被两次当成shard_ptr构造函数里的参数的情况。考虑如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> *pInt = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp1(pInt);</span><br><span class="line">     assert(temp1.use_count() == <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp2(pInt);</span><br><span class="line">     assert(temp2.use_count() == <span class="number">1</span>);</span><br><span class="line">&#125;      <span class="comment">// temp1和temp2都离开作用域，它们都销毁pInt，会导致两次释放同一块内存</span></span><br></pre></td></tr></table></figure>
<p>正确的做法是将原始指针赋给智能指针后，以后的操作都要针对智能指针了。参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>));</span><br><span class="line">  assert(temp1.use_count() == <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; temp2(temp1);</span><br><span class="line">  assert(temp2.use_count() == <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="comment">// temp1和temp2都离开作用域，引用次数变为0，指针被销毁。</span></span><br></pre></td></tr></table></figure></p>
<p>另外，使用shared_ptr来包装this时，也会产生与上面类似的问题。考虑如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;A&gt; Get()</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pA(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pB = pA-&gt;Get();</span><br></pre></td></tr></table></figure></p>
<p>当pA和pB离开作用域时，会将堆上的对象释放两次。如何解决上述问题呢？C++ 11提供了如下机制：将类从enable_shared_from_this类派生，获取shared_ptr时使用shared_from_this接口。参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A ：<span class="keyword">public</span> enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;A&gt; Get()</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> shared_from_this();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在多线程中使用shared_ptr时，如果存在拷贝或赋值操作，可能会由于同时访问引用计数而导致计数无效。解决方法是向每个线程中传递公共的week_ptr，线程中需要使用shared_ptr时，将week_ptr转换成shared_ptr即可。<br>以上例子来自<a href="http://www.cnblogs.com/hujian/archive/2012/12/10/2810754.html" target="_blank" rel="external">这里</a></p>
<h2 id="weak-ptr指针"><a href="#weak-ptr指针" class="headerlink" title="weak_ptr指针"></a>weak_ptr指针</h2><p>weak_ptr是为配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手，而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和operator-&gt;，它的最大作用在于协助shared_ptr，像旁观者那样观测资源的使用情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> weak_ptr&#123;  </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">     weak_ptr();  </span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(<span class="built_in">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span> &amp; r);  </span><br><span class="line">     weak_ptr(weak_ptr <span class="keyword">const</span> &amp; r);  </span><br><span class="line"></span><br><span class="line">     ~weak_ptr();  </span><br><span class="line">     weak_ptr &amp; <span class="keyword">operator</span>=(weak_ptr <span class="keyword">const</span> &amp;r);  </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span></span>;  </span><br><span class="line">     <span class="built_in">shared_ptr</span>&lt;T&gt; lock() <span class="keyword">const</span>;  </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;  </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(weak_ptr&lt;T&gt; &amp;b)</span></span>;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>weak_ptr是一个“弱”指针，但它能够完成一些特殊的工作，足以证明它的存在价值。</p>
<p>weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。同样，在weak_ptr析构时也不会导致引用计数的减少，它只是一个静静地观察者。</p>
<p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count() == 0，但更快，表示观测的资源（也就是shared_ptr管理的资源）已经不复存在了。</p>
<p>weak_ptr 没有重载operator*和-&gt;，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。但它可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。当expired() == true的时候，lock()函数将返回一个存储空指针的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">   <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));  </span><br><span class="line">   assert(sp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   <span class="comment">//create a weak_ptr from shared_ptr  </span></span><br><span class="line">   weak_ptr&lt;<span class="keyword">int</span>&gt; wp(sp);  </span><br><span class="line">   <span class="comment">//not increase the use count  </span></span><br><span class="line">   assert(sp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   <span class="comment">//judge wp is invalid  </span></span><br><span class="line">   <span class="comment">//expired() is equivalent with use_count() == 0  </span></span><br><span class="line">   <span class="keyword">if</span>(!wp.expired())&#123;  </span><br><span class="line">      <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = wp.lock();<span class="comment">//get a shared_ptr  </span></span><br><span class="line">      \*sp2 = <span class="number">100</span>;  </span><br><span class="line">      assert(wp.use_count() == <span class="number">2</span>);  </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; \*sp2 &lt;&lt; endl;  </span><br><span class="line">   &#125;<span class="comment">//out of scope,sp2 destruct automatically,use_count()--;  </span></span><br><span class="line">   assert(wp.use_count() == <span class="number">1</span>);  </span><br><span class="line">   sp.reset();<span class="comment">//shared_ptr is invalid  </span></span><br><span class="line">   assert(wp.expired());  </span><br><span class="line">   assert(!wp.lock());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得this的shared_ptr</p>
<p>weak_ptr的一个重要用途是获得this指针的shared_ptr,使对象自己能够生产shared_ptr管理自己：对象使用weak_ptr观测this指，这并不影响引用计数，在需要的时候就调用lock()函数，返回一个符合要求的shared_ptr使外界使用。</p>
<p>这个解决方案被实现为一个惯用法，在头文件<booost enable_shared_from_this.hpp="">定义了一个助手类enable_shared_from_this<t>，其声明如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> enable<span class="number">_</span><span class="annotation">shared</span><span class="number">_f</span>rom<span class="number">_</span><span class="keyword">this</span>  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">   <span class="annotation">shared</span><span class="number">_p</span>tr&lt;T&gt; <span class="annotation">shared</span><span class="number">_f</span>rom<span class="number">_</span><span class="keyword">this</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></booost></p>
<p>使用的时候只需要让想被shared_ptr管理的类从它继承即可，成员函数shared_from_this()会返回this的shared_ptr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/smart_ptr.hpp&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/enable_shared_from_this.hpp&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/make_shared.hpp&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">class</span> self_shared:  </span><br><span class="line"><span class="keyword">public</span> enable_shared_from_this&lt;self_shared&gt;&#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">    self_shared(<span class="keyword">int</span> n):x(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"self_shared:"</span> &lt;&lt; x &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;self_shared&gt; sp =   </span><br><span class="line">                           make_shared&lt;self_shared&gt;(<span class="number">315</span>);  </span><br><span class="line">    sp-&gt;print();  </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;self_shared&gt; p = sp-&gt;shared_from_this();  </span><br><span class="line">    p-&gt;x = <span class="number">100</span>;  </span><br><span class="line">    p-&gt;print();    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">self_shared:</span><span class="number">315</span></span><br><span class="line"><span class="label">self_shared:</span><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是千万不能从一个普通对象（非shared_ptr）使用shared_from_this ()获取shared_ptr，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self_shared ss;</span><br><span class="line"></span><br><span class="line">shaerd_ptr&lt;self_shared&gt; p = ss.shared_from_this();<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>这样虽然语法上能通过，编译也无问题，但在运行时会导致shared_ptr析构时企图删除一个栈上分配的对象，发生未定义行为。</p>
<p>以上内容来自<a href="http://blog.csdn.net/ajioy/article/details/7377099" target="_blank" rel="external">这里</a></p>
<h2 id="auto-ptr指针"><a href="#auto-ptr指针" class="headerlink" title="auto_ptr指针"></a>auto_ptr指针</h2><p>auto_ptr通过在栈上构建一个对象a，对象a中wrap了动态分配内存的指针p，所有对指针p的操作都转为对对象a的操作。而在a的析构函数中会自动释放p的空间，而该析构函数是编译器自动调用的，无需程序员操心。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用法一：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example(<span class="keyword">new</span> MyClass());  </span><br><span class="line"></span><br><span class="line">用法二：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example;  </span><br><span class="line">m_example.reset(<span class="keyword">new</span> MyClass());  </span><br><span class="line"></span><br><span class="line">用法三（指针的赋值操作）：  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example1(<span class="keyword">new</span> MyClass());  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;MyClass&gt;m_example2(<span class="keyword">new</span> MyClass());  </span><br><span class="line">m_example2=m_example1;  </span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>对于上面的代码：m_example2=m_example1;  则C++会把m_example所指向的内存回收，使m_example1 的值为NULL，所以在C++中，应绝对避免把auto_ptr放到容器中。即应避免下列代码：<br>vector<auto_ptr<myclass>&gt;m_example;<br>当用算法对容器操作的时候，你很难避免STL内部对容器中的元素实现赋值传递，这样便会使容器中多个元素被置位NULL，而这不是我们想看到的。</auto_ptr<myclass></p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1(a)：原始代码    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="function">T* <span class="title">pt</span><span class="params">( new T )</span></span>;  </span><br><span class="line">      <span class="comment">/*...更多的代码...*/</span>  </span><br><span class="line">      <span class="keyword">delete</span> pt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码需要手动的delete掉堆上的内存，如果使用auto_ptr指针的话，就不需要：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1(b)：安全代码，使用了auto_ptr  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt( <span class="keyword">new</span> T );  </span><br><span class="line">      <span class="comment">/*...更多的代码...*/</span>  </span><br><span class="line">&#125; <span class="comment">// 酷：当pt出了作用域时析构函数被调用，从而对象被自动删除</span></span><br></pre></td></tr></table></figure></p>
<p>使用一个auto_ptr就像使用一个内建的指针一样容易，而且如果想要“撤销”资源，重新采用手动的所有权，我们只要调用release()。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例2：使用一个auto_ptr  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="comment">// 现在，我们有了一个分配好的对象  </span></span><br><span class="line">T* pt1 = <span class="keyword">new</span> T;  </span><br><span class="line">      <span class="comment">// 将所有权传给了一个auto_ptr对象  </span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt2(pt1);  </span><br><span class="line">      <span class="comment">// 使用auto_ptr就像我们以前使用简单指针一样，  </span></span><br><span class="line">*pt2 = <span class="number">12</span>;          <span class="comment">// 就像*pt1 = 12  </span></span><br><span class="line">pt2-&gt;SomeFunc(); <span class="comment">// 就像pt1-&gt;SomeFunc();  </span></span><br><span class="line">      <span class="comment">// 用get()来获得指针的值  </span></span><br><span class="line">assert( pt1 == pt2.get() );  </span><br><span class="line">      <span class="comment">// 用release()来撤销所有权  </span></span><br><span class="line">T* pt3 = pt2.release();  </span><br><span class="line">      <span class="comment">// 自己删除这个对象，因为现在没有任何auto_ptr拥有这个对象  </span></span><br><span class="line"><span class="keyword">delete</span> pt3;  </span><br><span class="line">&#125; <span class="comment">// pt2不再拥有任何指针，所以不要试图删除它...OK，不要重复删除  </span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用auto_ptr的reset()函数来重置auto_ptr使之拥有另一个对象。如果这个auto_ptr已经拥有了一个对象，那么，它会先删除已经拥有的对象，因此调用reset()就如同销毁这个auto_ptr，然后新建一个并拥有一个新对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 3：使用reset()  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt; pt( <span class="keyword">new</span> T(<span class="number">1</span>) );  </span><br><span class="line">pt.reset( <span class="keyword">new</span> T(<span class="number">2</span>) );         <span class="comment">// 删除由"new T(1)"分配出来的第一个T  </span></span><br><span class="line">&#125; <span class="comment">// 最后pt出了作用域，第二个T也被删除了</span></span><br></pre></td></tr></table></figure></p>
<p>以上原文来自<a href="http://blog.csdn.net/monkey_d_meng/article/details/5901392" target="_blank" rel="external">这里</a></p>
<h2 id="scoped-ptr指针"><a href="#scoped-ptr指针" class="headerlink" title="scoped_ptr指针"></a>scoped_ptr指针</h2><p>scoped_ptr和std::auto_ptr非常类似，是一个简单的智能指针，它能够保证在离开作用域后对象被自动释放。下列代码演示了该指针的基本应用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> implementation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~implementation() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"destroying implementation\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"did something\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    boost::scoped_ptr&lt;implementation&gt; impl(<span class="keyword">new</span> implementation());</span><br><span class="line">    impl-&gt;do_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Test Begin ... \n"</span>;</span><br><span class="line">    test();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Test End.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码的输出结果是：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="keyword">Begin</span> ...</span><br><span class="line">did something</span><br><span class="line">destroying <span class="keyword">implementation</span></span><br><span class="line">Test <span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>
<p>可以看到：当implementation类离其开impl作用域的时候，会被自动删除，这样就会避免由于忘记手动调用delete而造成内存泄漏了。</p>
<p>scoped_ptr的实现和std::auto_ptr非常类似，都是利用了一个栈上的对象去管理一个堆上的对象，从而使得堆上的对象随着栈上的对象销毁时自动删除。不同的是，boost::scoped_ptr有着更严格的使用限制——不能拷贝。这就意味着：boost::scoped_ptr指针是不能转换其所有权的。</p>
<ol>
<li><p>不能转换所有权<br>boost::scoped_ptr所管理的对象生命周期仅仅局限于一个区间（该指针所在的”{}”之间），无法传到区间之外，这就意味着boost::scoped_ptr对象是不能作为函数的返回值的（std::auto_ptr可以）。</p>
</li>
<li><p>不能共享所有权<br>这点和std::auto_ptr类似。这个特点一方面使得该指针简单易用。另一方面也造成了功能的薄弱——不能用于stl的容器中。</p>
</li>
<li><p>不能用于管理数组对象<br>由于boost::scoped_ptr是通过delete来删除所管理对象的，而数组对象必须通过deletep[]来删除，因此boost::scoped_ptr是不能管理数组对象的，如果要管理数组对象需要使用boost::scoped_array类。</p>
</li>
</ol>
<p>scoped_ptr的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> scoped_ptr : noncopyable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">(T* p = <span class="number">0</span>)</span></span>;</span><br><span class="line">        ~scoped_ptr();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* p = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&amp; b)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&lt;T&gt; &amp; a, scoped_ptr&lt;T&gt; &amp; b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_array.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/config.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/detail/lightweight_test.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// test scoped_ptr with a built-in type</span></span><br><span class="line">    <span class="keyword">long</span> * lp = <span class="keyword">new</span> <span class="keyword">long</span>;</span><br><span class="line">    boost::scoped_ptr&lt;<span class="keyword">long</span>&gt; sp ( lp );</span><br><span class="line">    BOOST_TEST( sp.get() == lp );</span><br><span class="line">    BOOST_TEST( lp == sp.get() );</span><br><span class="line">    BOOST_TEST( &amp;\*sp == lp );</span><br><span class="line"></span><br><span class="line">    \*sp = <span class="number">1234568901L</span>;</span><br><span class="line">    BOOST_TEST( \*sp == <span class="number">1234568901L</span> );</span><br><span class="line">    BOOST_TEST( \*lp == <span class="number">1234568901L</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> * lp2 = <span class="keyword">new</span> <span class="keyword">long</span>;</span><br><span class="line">    boost::scoped_ptr&lt;<span class="keyword">long</span>&gt; sp2 ( lp2 );</span><br><span class="line"></span><br><span class="line">    sp.swap(sp2);</span><br><span class="line">    BOOST_TEST( sp.get() == lp2 );</span><br><span class="line">    BOOST_TEST( sp2.get() == lp );</span><br><span class="line"></span><br><span class="line">    sp.reset(<span class="literal">NULL</span>);</span><br><span class="line">    BOOST_TEST( sp.get() == <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="boost-scoped-ptr和std-auto-ptr的选取："><a href="#boost-scoped-ptr和std-auto-ptr的选取：" class="headerlink" title="boost::scoped_ptr和std::auto_ptr的选取："></a>boost::scoped_ptr和std::auto_ptr的选取：</h4><p>boost::scoped_ptr和std::auto_ptr的功能和操作都非常类似，如何在他们之间选取取决于是否需要转移所管理的对象的所有权（如是否需要作为函数的返回值）。如果没有这个需要的话，大可以使用boost::scoped_ptr，让编译器来进行更严格的检查，来发现一些不正确的赋值操作。</p>
<p>以上原文来自<a href="http://www.cnblogs.com/TianFang/archive/2008/09/15/1291050.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/23/Boost智能指针/" data-id="ciq4t54ph0000mgqyx6k9vzic" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux任务调度机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/Linux任务调度机制/" class="article-date">
  <time datetime="2016-03-21T14:16:33.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/Linux任务调度机制/">Linux任务调度机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux中，每一个CPU都会有一个队列来存储处于TASK_RUNNING状态的任务，任务调度就是从这些队列中取出优先级最高的任务作为下一个放入CPU执行的任务。</p>
<p>任务的调度需要进过两个过程：上下文切换和选择算法</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>从一个进程的上下文切换到另一个进程的上下文，因为其发生频率很高，所以通常都是调度器效率高低的关键。schedule()函数中调用了switch_to宏，这个宏实现了进程之间的真正切换，其代码存放于include/i386/system.h。switch_to宏是用嵌入式汇编写成的，较难理解。由switch_to()实现，而它的代码段在schedule()过程中调用，以一个宏实现。switch_to()函数正常返回，栈上的返回地址是新进程的task_struct::thread::eip，即新进程上一次被挂起时设置的继续运行的位置（上一次执行switch_to()时的标号”1:”位置）。至此转入新进程的上下文中运行。这其中涉及到wakeup，sleepon等函数来对进程进行睡眠与唤醒操作。</p>
<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>Linux schedule()函数将遍历就绪队列中的所有进程，调用goodness()函数计算每一个进程的权值weight，从中选择权值最大的进程投入运行。Linux的调度器主要实现在schedule()函数中。</p>
<p>调度步骤：</p>
<p>Schedule函数工作流程如下：</p>
<p>（1）清理当前运行中的进程<br>（2）选择下一个要运行的进程（pick_next_task）<br>（3）设置新进程的运行环境<br>（4） 进程上下文切换</p>
<h3 id="Linux-调度器将进程分为三类"><a href="#Linux-调度器将进程分为三类" class="headerlink" title="Linux 调度器将进程分为三类"></a>Linux 调度器将进程分为三类</h3><p>进程调度是操作系统的核心功能。调度器只是调度过程中的一部分，进程调度是非常复杂的过程，需要多个系统协同工作完成。本文所关注的仅为调度器，它的主要工作是在所有RUNNING 进程中选择最合适的一个。作为一个通用操作系统，Linux 调度器将进程分为三类：</p>
<ol>
<li><p>交互式进程<br>此类进程有大量的人机交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如编辑器 vi。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。</p>
</li>
<li><p>批处理进程<br>此类进程不需要人机交互，在后台运行，需要占用大量的系统资源。但是能够忍受响应延迟。比如编译器。</p>
</li>
<li><p>实时进程<br>实时对调度延迟的要求最高，这些进程往往执行非常重要的操作，要求立即响应并执行。比如视频播放软件或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟，轻则影响电影放映效果，重则机毁人亡。</p>
</li>
</ol>
<h3 id="调度时机：调度什么时候发生？即：schedule-函数什么时候被调用？"><a href="#调度时机：调度什么时候发生？即：schedule-函数什么时候被调用？" class="headerlink" title="调度时机：调度什么时候发生？即：schedule()函数什么时候被调用？"></a>调度时机：调度什么时候发生？即：schedule()函数什么时候被调用？</h3><p>调度的发生主要有两种方式：</p>
<p>1：主动式调度(自愿调度)</p>
<p>在内核中主动直接调用进程调度函数schedule()，当进程需要等待资源而暂时停止运行时，会把状态置于挂起（睡眠），并主动请求调度，让出cpu。</p>
<p>2：被动式调度（抢占式调度、强制调度）</p>
<p>用户抢占（2.4  2.6）<br>内核抢占（2.6）</p>
<h4 id="1-用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。"><a href="#1-用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。" class="headerlink" title="(1)用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。"></a>(1)用户抢占发生在：从系统调用返回用户空间；从中断处理程序返回用户空间。</h4><p>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。主动式调度是用户程序自己调度schedule，也许有人会觉得自己的代码中能引用schedule吗？也许不行吧，但大家知道wait4我们是可以调用的，前面我们没有给出wait4的代码，但我们知道在执行了wait4效果是父进程被挂起，所谓的挂起就是不运行了，放弃了CPU，这里发生了进程调度是显而易见的，其实在代码中有如下几行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current­&gt;state = TASK_INTERRUPIBLE;<span class="function"><span class="title">schedule</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还有exit也有<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current­&gt;state = TASK_ZOMBIE; <span class="function"><span class="title">schedule</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这2种发生了进程调度，从代码上也可以看出（状态被改成了睡眠和僵死，然后去调度可运行进程，当前进程自然不会再占有CPU运行了），从效果中也能看出。这说明用户程序自己可以执行进程调度。</p>
<h4 id="2-内核抢占"><a href="#2-内核抢占" class="headerlink" title="(2)内核抢占"></a>(2)内核抢占</h4><p>在不支持内核抢占的系统中，进程/线程一旦运行于内核空间，就可以一直执行，直到它主动放弃或时间片耗尽为止。这样一些非常紧急的进程或线程将长时间得不到运行。在支持内核抢占的系统中，更高优先级的进程/线程可以抢占正在内核空间运行的低优先级的进程/线程。关于抢占式调度(强制调度），需要知道的是，CPU在执行了当前指令之后，在执行下一条指令之前，CPU要判断在当前指令执行之后是否发生了中断或异常，如果发生了，CPU将比较到来的中断优先级和当前进程的优先级（有硬件参与实现，如中断控制器8259A芯片；通过比较寄存器的值来判断优先级；中断服务程序的入口地址形成有硬件参与实现，等等，具体实现请见相关资料和书籍），如果新来任务的优先级更高，则执行中断服务程序，在返回中断时，将执行进程调度函数schedule。</p>
<p>在支持内核抢占的系统中,某些特例下是不允许内核被抢占的：<br>（a）内核正在运行中断处理程序，进程调度函数schedule（）会对此作出判断，如果是在中断中调用，会打印出错误信息。</p>
<p>（b） 内核正在进行中断上下文的bottom half（中断的底半部）处理，硬件中断返回前会执行软中断，此时仍然处于中断上下文。</p>
<p>（c） 进程正持有spinlock自旋锁，writelock/readlock读写锁等，当持有这些锁时，不应该被抢占，否则由于抢占将导致其他cpu长时间不能获得锁而死锁。</p>
<p>（d） 内核正在执行调度程序scheduler</p>
<p>为了保证linux内核在以上情况下不会被抢占，抢占式内核使用了一个变量preempt_count,称为内核抢占计数。这一变量被设置在进程的thread_info结构体中，每当内核要进入以上几种状态时，变量preempt_count就加1，指示内核不允许抢占，反之减1。</p>
<h3 id="Linux任务调度策略"><a href="#Linux任务调度策略" class="headerlink" title="Linux任务调度策略"></a>Linux任务调度策略</h3><h4 id="Linux支持SCHED-FIFO、SCHED-RR和SCHED-OTHER的调度策略。"><a href="#Linux支持SCHED-FIFO、SCHED-RR和SCHED-OTHER的调度策略。" class="headerlink" title="Linux支持SCHED_FIFO、SCHED_RR和SCHED_OTHER的调度策略。"></a>Linux支持SCHED_FIFO、SCHED_RR和SCHED_OTHER的调度策略。</h4><p>linux用函数goodness（）统一计算进程（包括普通进程和实时进程）的优先级权值，该权值衡量一个处于可运行状态的进程值得运行的程度，权值越大，进程优先级越高。 每个进程的task_struct结构中，与goodness（）计算权值相关的域有以下四项：policy、nice(2.2版内核该项为priority)、counter、rt_priority。其中，policy是进程的调度策略，其可用来区分实时进程和普通进程，实时进程优先于普通进程运行。nice从最初的UNIX沿用而来，表示进程的静态负向优先级，其取值范围为19~-20，以-20优先级最高。counter表示进程剩余的时间片计数值，由于counter在计算goodness（）时起重要作用，因此，counter也可以看作是进程的动态优先级。rt_priority是实时进程特有的，表示实时优先级。</p>
<p>首先，linux根据调度策略policy从整体上区分实时进程和普通进程。对于policy为SCHED_OTHER的普通进程，linux采用动态优先级调，其优先级权值取决于(20-nice)和进程当前的剩余时间片计数counter之和。进程创建时，子进程继承父进程的nice值，而父进程的counter值则被分为二半，子进程和父进程各得一半。时间片计数器每次清零后由(20-nice)经过换算重新赋值。字面上看，nice是“优先级”、counter是“计数器”的意思，然而实际上，它们表达的是同个意思：nice决定了分配给该进程的时间片计数，nice优先级越高的进程分到的时间片越长，用户通过系统调用nice（）或setpriority（）改变进程静态优先级nice值的同时，也改变了该进程的时间片长度；counter表示该进程剩余的时间片计数值，而nice和counter综合起来又决定进程可运行的优先级权值。在进程运行过程中，counter不断减少，而nice保持相对不变；当一个普通进程的时间片用完以后，并不马上根据nice对counter进行重新赋值，只有所有处于可运行状态的普通进程的时间片都用完了以后（counter等于0），才根据nice对counter重新赋值，这个普通进程才有了再次被调度的机会。这说明，普通进程运行过程中，counter的减小给了其它进程得以运行的机会，直至counter减为0时才完全放弃对CPU的使用，这就相当于优先级在动态变化，所以称之为动态优先调度。</p>
<p>对于实时进程，linux采用了两种调度策略，即SCHED_FIFO(先来先服务调度)和SCHED_RR（时间片轮转调度）。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，采用了一个比较固定的标准，即参考rt_priority的值。用函数goodness（）计算进程的优先级权值时，对实时进程是在1000的基础上加上rt_priority的值，而非实时进程的动态优先级综合起来的调度权值始终在以下，所以goodness（）的优先级权值计算方法确保实时进程的调度权值始终比所有的非实时进程都要大，这就保证了实时进程的优先运行。实时进程的counter与nice都与其优先级权值无关，这和普通进程是有区别的，实时进程task_struct中的counter和nice只与SCHED_RR调度策略进程的时间片计数相关；而对于SCHED_FIFO调度策略的实时进程没有调度的参考意义。</p>
<h2 id="进程状态说明"><a href="#进程状态说明" class="headerlink" title="进程状态说明"></a>进程状态说明</h2><h4 id="R-task-running-可执行状态"><a href="#R-task-running-可执行状态" class="headerlink" title="R (task_running) : 可执行状态"></a>R (task_running) : 可执行状态</h4><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。</p>
<p>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p>
<h4 id="S-task-interruptible-可中断的睡眠状态"><a href="#S-task-interruptible-可中断的睡眠状态" class="headerlink" title="S (task_interruptible): 可中断的睡眠状态"></a>S (task_interruptible): 可中断的睡眠状态</h4><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p>
<p>通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于task_interruptible状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p>
<h4 id="D-task-uninterruptible-不可中断的睡眠状态"><a href="#D-task-uninterruptible-不可中断的睡眠状态" class="headerlink" title="D (task_uninterruptible): 不可中断的睡眠状态"></a>D (task_uninterruptible): 不可中断的睡眠状态</h4><p>与task_interruptible状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。</p>
<p>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。但是uninterruptible sleep 状态的进程不接受外来的任何信号，因此无法用kill杀掉这些处于D状态的进程，无论是”kill”, “kill -9″还是”kill -15″，这种情况下，一个可选的方法就是reboot。</p>
<p>处于uninterruptible sleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了.</p>
<p>而task_uninterruptible状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。</p>
<p>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用task_uninterruptible状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的task_uninterruptible状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p>
<p>我们通过vmstat 命令中procs下的b 可以来查看是否有处于uninterruptible 状态的进程。 该命令只能显示数量。</p>
<p>In computer operating systems terminology, a sleeping process can either be interruptible (woken via signals) or uninterruptible (woken explicitly). An uninterruptible sleep state is a sleep state that cannot handle a signal (such as waiting for disk or network IO (input/output)).</p>
<p>When the process is sleeping uninterruptibly, the signal will be noticed when the process returns from the system call or trap.<br> – 这句是关键。 当处于uninterruptibly sleep 状态时，只有当进程从system 调用返回时，才通知signal。</p>
<p>A process which ends up in “D” state for any measurable length of time is trapped in the midst of a system call (usually an I/O operation on a device — thus the initial in the ps output).</p>
<p>Such a process cannot be killed — it would risk leaving the kernel in an inconsistent state, leading to a panic. In general you can consider this to be a bug in the device driver that the process is accessing.</p>
<h4 id="T-task-stopped-or-task-traced-：暂停状态或跟踪状态"><a href="#T-task-stopped-or-task-traced-：暂停状态或跟踪状态" class="headerlink" title="T(task_stopped or task_traced)：暂停状态或跟踪状态"></a>T(task_stopped or task_traced)：暂停状态或跟踪状态</h4><p>向进程发送一个sigstop信号，它就会因响应该信号而进入task_stopped状态（除非该进程本身处于task_uninterruptible状态而不响应信号）。（sigstop与sigkill信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）</p>
<p>向进程发送一个sigcont信号，可以让其从task_stopped状态恢复到task_running状态。</p>
<p>当进程正在被跟踪时，它处于task_traced这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于task_traced状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。</p>
<p>对于进程本身来说，task_stopped和task_traced状态很类似，都是表示进程暂停下来。</p>
<p>而task_traced状态相当于在task_stopped之上多了一层保护，处于task_traced状态的进程不能响应sigcont信号而被唤醒。只能等到调试进程通过ptrace系统调用执行ptrace_cont、ptrace_detach等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复task_running状态。</p>
<h4 id="Z-task-dead-exit-zombie-：退出状态，进程成为僵尸进程"><a href="#Z-task-dead-exit-zombie-：退出状态，进程成为僵尸进程" class="headerlink" title="Z (task_dead - exit_zombie)：退出状态，进程成为僵尸进程"></a>Z (task_dead - exit_zombie)：退出状态，进程成为僵尸进程</h4><p>在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。    </p>
<p>它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
<p>进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。</p>
<p>之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。</p>
<p>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p>
<p>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</p>
<p>这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p>
<p>如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，子进程的尸体（task_struct）也就无法释放掉。</p>
<p>如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
<p>当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管的进程可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。</p>
<p>linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：</p>
<p>1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；<br>2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；</p>
<p>init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于task_interruptible状态，“收尸”过程中则处于task_running状态。</p>
<h4 id="X-task-dead-exit-dead-：退出状态，进程即将被销毁"><a href="#X-task-dead-exit-dead-：退出状态，进程即将被销毁" class="headerlink" title="X (task_dead - exit_dead)：退出状态，进程即将被销毁"></a>X (task_dead - exit_dead)：退出状态，进程即将被销毁</h4><p>进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程。或者父进程通过设置sigchld信号的handler为sig_ign，显式的忽略了sigchld信号。（这是posix的规定，尽管子进程的退出信号可以被设置为sigchld以外的其他信号。）</p>
<p>此时，进程将被置于exit_dead退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以exit_dead状态是非常短暂的，几乎不可能通过ps命令捕捉到。</p>
<h2 id="进程状态变化说明"><a href="#进程状态变化说明" class="headerlink" title="进程状态变化说明"></a>进程状态变化说明</h2><h4 id="进程的初始状态"><a href="#进程的初始状态" class="headerlink" title="进程的初始状态"></a>进程的初始状态</h4><p>进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）</p>
<p>那么既然调用进程处于task_running状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于task_running状态。<br>另外，在系统调用调用clone和内核函数kernel_thread也接受clone_stopped选项，从而将子进程的初始状态置为 task_stopped。</p>
<h4 id="进程状态变迁"><a href="#进程状态变迁" class="headerlink" title="进程状态变迁"></a>进程状态变迁</h4><p>进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从task_running状态变为非task_running状态、或者从非task_running状态变为task_running状态。</p>
<p>也就是说，如果给一个task_interruptible状态的进程发送sigkill信号，这个进程将先被唤醒（进入task_running状态），然后再响应sigkill信号而退出（变为task_dead状态）。并不会从task_interruptible状态直接退出。</p>
<p>进程从非task_running状态变为task_running状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为task_running，然后将其task_struct结构加入到某个cpu的可执行队列中。于是被唤醒的进程将有机会被调度执行。</p>
<p>而进程从task_running状态变为非task_running状态，则有两种途径：</p>
<p>1、响应信号而进入task_stoped状态、或task_dead状态；</p>
<p>2、执行系统调用主动进入task_interruptible状态（如nanosleep系统调用）、或task_dead状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入task_interruptible状态或task_uninterruptible状态（如select系统调用）。</p>
<p>显然，这两种情况都只能发生在进程正在cpu上执行的情况下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/21/Linux任务调度机制/" data-id="ciq4t54s0003tmgqy03p5i1ib" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-链接库以及编译过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/链接库以及编译过程/" class="article-date">
  <time datetime="2016-03-20T11:44:08.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/链接库以及编译过程/">链接库以及编译过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux中，链接库有两种，静态链接库和动态链接库。静态链接库文件以.a作为后缀，动态链接库以.so作为文件名。</p>
<p>一个源文件编程一个可运行的程序，需要进过两个步骤，编译跟链接。编译就是编译器将源文件编译成目标文件，以.o作为文件名后缀，生成目标文件后，接下来就是链接器的工作了。<br>对于静态链接库，连接器将目标文件和所涉及到的库函数（引用的是静态链接库的函数）连接起来合成一个可执行的文件，此时的库函数数据是直接存在可运行文件里面，这样的可运行程序在在生成后，就可以脱离静态库函数而成功运行了。但是所生成的可执行文件会比较大。对于动态链接库，只是做一下符号标记，在程序运行需要用到库函数的时候，才会将动态库里面的函数加载在内存中，由于不是直接的将库函数代码拷贝到自己的空间，只是一个符号链接，所生成的可运行文件就会比较小。</p>
<h3 id="静态链接库、动态链接库各自的特点"><a href="#静态链接库、动态链接库各自的特点" class="headerlink" title="静态链接库、动态链接库各自的特点"></a>静态链接库、动态链接库各自的特点</h3><ol>
<li><p>动态链接库有利于进程间资源共享<br>什么概念呢？就是说，某个程序的在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。如果有，则让其共享那一个拷贝；只有没有时才链接载入。这样的模式虽然会带来一些“动态链接”额外的开销，却大大的节省了系统的内存资源。C的标准库就是动态链接库，也就是说系统中所有运行的程序共享着同一个C标准库的代码段。而静态链接库则不同，如果系统中多个程序都要调用某个静态链接库函数时，则每个程序都要将这个库函数拷贝到自己的代码段，显然将占有更大的内存资源。</p>
</li>
<li><p>将一些程序升级变得简单。用静态库，如果库发生变化，使用库的程序要重新编译。使用动态库，只要动态库提供给该程序的接口没变，只要重新用新生成的动态库替换原来就可以了。</p>
</li>
<li><p>甚至可以真正坐到链接载入完全由程序员在程序代码中控制。<br>程序员在编写程序的时候，可以明确的指明什么时候或者什么情况下，链接载入哪个动态链接库函数。你可以有一个相当大的软件，但每次运行的时候，由于不同的操作需求，只有一小部分程序被载入内存。所有的函数本着“有需求才调入”的原则，于是大大节省了系统资源。比如现在的软件通常都能打开若干种不同类型的文件，这些读写操作通常都用动态链接库来实现。在一次运行当中，一般只有一种类型的文件将会被打开。所以直到程序知道文件的类型以后再载入相应的读写函数，而不是一开始就将所有的读写函数都载入，然后才发觉在整个程序中根本没有用到它们。</p>
</li>
<li><p>由于静态库在编译的时候，就将库函数装载到程序中去了，而动态库函数必须在运行的时候才装载，所以程序执行的时候，用静态库更快些。</p>
</li>
</ol>
<h3 id="源文件的编译过程"><a href="#源文件的编译过程" class="headerlink" title="源文件的编译过程"></a>源文件的编译过程</h3><p>如果有一个源文件file.c需要编译，那么其编译过程如下图所示：<br><img src="/pictures/Linux/链接库以及编译过程-编译过程.png" alt=""></p>
<p>一般在执行命令 gcc -o file file.c ，会转化成以下几个步骤：</p>
<p>生成预处理后的文件：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">E</span> -o <span class="keyword">file</span>.i  <span class="keyword">file</span>.</span><br></pre></td></tr></table></figure></p>
<p>预处理文件到汇编代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -s <span class="type">file</span>.s <span class="type">file</span>.c</span><br></pre></td></tr></table></figure></p>
<p>汇编代码到目标文件：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="keyword">file</span>.<span class="literal">s</span></span><br></pre></td></tr></table></figure></p>
<p>生成可执行文件：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="type">file</span> <span class="type">file</span>.o</span><br></pre></td></tr></table></figure></p>
<h2 id="静态链接库创建"><a href="#静态链接库创建" class="headerlink" title="静态链接库创建"></a>静态链接库创建</h2><p>所有的库，不管是静态库还是动态库，都是有.o文件生成的，所以在创建库函数的时候，需要先生成.o文件。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="built_in">file</span>.c<span class="comment"> //生成file.o</span></span><br><span class="line"></span><br><span class="line">ar <span class="constant">cr</span> libfile.<span class="operator">a</span> <span class="built_in">file</span>.o</span><br></pre></td></tr></table></figure></p>
<h2 id="动态链接库的创建"><a href="#动态链接库的创建" class="headerlink" title="动态链接库的创建"></a>动态链接库的创建</h2><p>由于动态链接库函数的共享特性(故又叫共享库)，它们不会被拷贝到可执行文件中。在编译的时候，编译器只会做一些函数名之类的检查。在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。因此，这些代码必须实用相对地址，而不是绝对地址。在编译的时候，我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址不无关代码（Position Independent Code （PIC））。<br>对gcc编译器，只需添加上 -fPIC 标签，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c file1<span class="class">.c</span></span><br><span class="line">gcc -fPIC -c file2<span class="class">.c</span></span><br><span class="line">gcc -shared libxxx<span class="class">.so</span> file1<span class="class">.o</span> file2.o</span><br></pre></td></tr></table></figure></p>
<h2 id="静态链接库和动态链接库的使用"><a href="#静态链接库和动态链接库的使用" class="headerlink" title="静态链接库和动态链接库的使用"></a>静态链接库和动态链接库的使用</h2><p>由于是自己生成的链接库，所以在需要用到的时候，需要跟编译器说链接库放在那个位置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc –o main main.o –L. –lxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># -L 参数告诉编译器先到path目录下搜索libxxx.so文件，如果没有找到，继续搜索libxxx.a（静态库）。</span></span><br><span class="line"></span><br><span class="line">如果想要直接的搜索静态的链接库，那么加上-<span class="keyword">static</span> 就可以了</span><br><span class="line">gcc –o main main.o -<span class="keyword">static</span> –L. –lxxxx</span><br></pre></td></tr></table></figure></p>
<p>对于动态链接库，如果想要让程序能可以顺利运行的话，那么可以通过下面的三种方法：</p>
<ol>
<li><p>在程序运行期间，也需要告诉系统去哪里找你的动态链接库文件。在UNIX下是通过定义名为 LD_LIBRARY_PATH 的环境变量来实现的。只需将path赋值给此变量即可</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export <span class="constant">LD_LIBRARY_PATH=</span><span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:~/C_pram/practice</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把库拷贝到/usr/lib和/lib目录下。</p>
</li>
<li><p>修改/etc/ld.so.conf文件，把库所在的路径加到文件末尾，并执行sudo ldconfig刷新(需要超级用户权限)。这样，加入的目录下的所有库文件都可见.</p>
</li>
</ol>
<p>如果想要查看某个可执行文件依赖于那些库，可以使用ldd命令：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldd</span> executefilenam</span><br></pre></td></tr></table></figure></p>
<p>查看静态库中的文件<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　[root<span class="variable">@node56</span> <span class="class"><span class="keyword">lib</span>]<span class="comment"># ar -t libhycu.a</span></span></span><br><span class="line">　　base64.c.o</span><br><span class="line">　　binbuf.c.o</span><br><span class="line">　　cache.c.o</span><br><span class="line">　　chunk.c.o</span><br><span class="line">　　codec_a.c.o</span><br><span class="line">　　…</span><br><span class="line">　　xort.c.o</span><br><span class="line">　　[root<span class="variable">@node56</span> <span class="class"><span class="keyword">lib</span>]<span class="comment">#</span></span></span><br><span class="line">　　[root<span class="variable">@node56</span> <span class="class"><span class="keyword">lib</span>]<span class="comment"># ar -tv libhycu.a</span></span></span><br><span class="line">　　rw-r--r-- <span class="number">0</span>/<span class="number">0</span>   <span class="number">7220</span> <span class="constant">Jul</span> <span class="number">29</span> <span class="number">19</span>:<span class="number">18</span> <span class="number">2011</span> base64.c.o</span><br><span class="line">　　rw-r--r-- <span class="number">0</span>/<span class="number">0</span>   <span class="number">2752</span> <span class="constant">Jul</span> <span class="number">29</span> <span class="number">19</span>:<span class="number">18</span> <span class="number">2011</span> binbuf.c.o</span><br><span class="line">　　rw-r--r-- <span class="number">0</span>/<span class="number">0</span>  <span class="number">19768</span> <span class="constant">Jul</span> <span class="number">29</span> <span class="number">19</span>:<span class="number">18</span> <span class="number">2011</span> cache.c.o</span><br></pre></td></tr></table></figure></p>
<p>查看动态库中的文件可以使用nm命令<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -<span class="keyword">D</span> <span class="keyword">file</span>.<span class="keyword">so</span></span><br></pre></td></tr></table></figure></p>
<p>下面是在网上找的生成动态链接库的例子，原文参考<a href="http://www.cnblogs.com/Xiao_bird/archive/2010/03/01/1675821.html" target="_blank" rel="external">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*mylib.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*mylib.c*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"mylib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is in mylib\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">gcc</span> <span class="tag">-fpic</span> <span class="tag">-shared</span> <span class="tag">mylib</span><span class="class">.c</span> <span class="tag">-o</span> <span class="tag">mylib</span><span class="class">.so</span></span><br></pre></td></tr></table></figure></p>
<p>此时将生成mylib.so动态链接库文件。</p>
<p>动态链接库在使用时，分为“隐式调用”和“显式调用”两种，如果是隐式调用，则与静态库的使用方法差不多，注意需要包含导出函数的头文件，即mylib.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"mylib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译方法：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -<span class="keyword">L</span>./ mylib.<span class="keyword">so</span></span><br></pre></td></tr></table></figure></p>
<p>注意要加上动态链接库的搜索路径，否则编译器只会到系统路径中去寻找。</p>
<p>显式调用的方式，不必包含mylib.h，但是需要增加几个系统调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span> // 显式加载需要用到的头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *pdlHandle = dlopen(<span class="string">"./mylib.so"</span>, RTLD_LAZY); <span class="comment">// RTLD_LAZY 延迟加载</span></span><br><span class="line">    <span class="keyword">char</span> *pszErr = dlerror();</span><br><span class="line">    <span class="keyword">if</span>( !pdlHandle || pszErr )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Load mylib failed!\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*Print)() = dlsym(pdlHandle, <span class="string">"Print"</span>); <span class="comment">// 定位动态链接库中的函数</span></span><br><span class="line">    <span class="keyword">if</span>( !Print )</span><br><span class="line">    &#123;</span><br><span class="line">        pszErr = dlerror();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Find symbol failed!%s\n"</span>, pszErr);</span><br><span class="line">        dlclose(pdlHandle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Print(); <span class="comment">// 调用动态链接库中的函数</span></span><br><span class="line"></span><br><span class="line">    dlclose(pdlHandle); <span class="comment">// 系统动态链接库引用数减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，显式调用的代码看上去要复杂很多，但是却比隐式调用要灵活，我们不必在编译时就确定要加载哪个动态链接库，可以在运行时再确定，甚至重新加载。</p>
<p>看一下显式调用的编译方式：</p>
<p>gcc -ldl -o main main.c</p>
<p>注意要添加-ldl选项，以使用显式调用相关的函数调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/20/链接库以及编译过程/" data-id="ciq4t54pw0003mgqy2b6hs163" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-malloc函数的实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/malloc函数的实现原理/" class="article-date">
  <time datetime="2016-03-19T12:41:36.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/malloc函数的实现原理/">malloc函数的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天看到了一个博文，感觉真的很不错，所以这里转载了一下，原文在<a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h2><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><img src="/pictures/C与C++/mallo函数实现原理-heap内存模型.png" alt=""></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h3 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(intptr_t increment)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p>
<h3 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rlimit *limit = (<span class="keyword">struct</span> rlimit *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rlimit));</span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"soft limit: %ld, hard limit: %ld\n"</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中rlimit是一个结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rlimit &#123;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h2 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h2><p>####　玩具实现<br>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个玩具malloc */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h3 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h3><p>下面严肃点讨论malloc的实现方案。</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：<br><img src="/pictures/C与C++/mallo函数实现原理-block内存模型.png" alt=""></p>
<h5 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h5><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<p>First fit：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块<br>Best fit：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</p>
<p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First fit */</span></span><br><span class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, size_t size)</span> </span>&#123;</span><br><span class="line">    t_block b = first_block;</span><br><span class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">        *last = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p>
<h5 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h5><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCK_SIZE <span class="number">24</span> <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, size_t s)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h4><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：<br><img src="/pictures/C与C++/mallo函数实现原理-block分裂.png" alt=""></p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, size_t s)</span> </span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + s;</span><br><span class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h5><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> align8(<span class="keyword">size_t</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCK_SIZE <span class="number">24</span></span></span><br><span class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* other functions... */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    <span class="comment">/* 对齐地址 */</span></span><br><span class="line">    s = align8(size);</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="comment">/* 查找合适的block */</span></span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">/* 如果可以，则分裂 */</span></span><br><span class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li>将数据区内容置为0</li>
</ol>
<p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t number, size_t size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s8, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li>
<li>如何解决碎片问题</li>
</ol>
<p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p>
<ol>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ol>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。<font color="red">这里个人觉得可以直接根据block数据结构中的成员char data[1]来实现，不需要引入新的magic pointer？？？</font></p>
<p>这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后我们定义检查地址合法性的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;  </span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>合并方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            b-&gt;next-&gt;prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</span><br><span class="line">            b = fusion(b-&gt;prev);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            fusion(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first_block = <span class="literal">NULL</span>;</span><br><span class="line">            brk(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ol>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并<br>下面是realloc的实现：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, size_t size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    t_block b, <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">void</span> *newp;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 看是否可进行合并 */</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span></span><br><span class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                fusion(b);</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 新malloc */</span></span><br><span class="line">                newp = <span class="built_in">malloc</span> (s);</span><br><span class="line">                <span class="keyword">if</span> (!newp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">new</span> = get_block(newp);</span><br><span class="line">                copy_block(b, <span class="keyword">new</span>);</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">return</span>(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h3><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<ol>
<li>同时兼容32位和64位系统</li>
<li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li>
<li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/19/malloc函数的实现原理/" data-id="ciq4t54rd002qmgqyuj0peyue" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/19/Linux-内存管理/" class="article-date">
  <time datetime="2016-03-19T08:20:42.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/Linux-内存管理/">Linux 内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Linux中，对于内存地址的处理，采用的是虚拟内存地址技术。之所以要使用虚拟内存，是因为对于每一个进程来说，都有自己的地址空间，而计算机的物理内存只有一份，每一个程序在编写的时候，都不会考虑到其他程序所需要的内存地址，也无法考虑，由于不同的进程的地址空间都是独立的（除了共享的之外），这样的话，程序编写就不知道怎样获得自己的所需内存，而采用虚拟内存的话，就解决了很多的问题，每一个进程的虚拟内存地址都是一样的，而实际运行时所对应的真实物理地址就直接的交给系统来处理，程序不需要考虑，同时也解决了内存空间独立的问题。<br>对于32为的机器，其所能访问的物理内存大小为4GB，所以每一个进程所能得到的虚拟内存大小为4GB，由于系统运行需要使用内存，也就是所谓的内核空间，一般大小为1GB，所以一般的进程所能使用的用户空间为3GB，地址从0开始。对于64位的机器，内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space），如下图所示：<br><img src="/pictures/Linux/虚拟内存空间.png" alt="64位Linux虚拟内存空间"></p>
<p>对于内存的管理，一般有两种方式：分段机制和分页机制，下面就只简单的介绍一下分页机制。</p>
<p>以32位的系统来说，对于4GB的虚拟内存，系统要怎样来管理该内存呢？一般就是采用所谓的分页机制，就是把这么大的内存按照每一页的大小分成很多页，内存的管理也就以页作为单位，而不是以字节作为单位。对也4GB的地址，如果按照每一页4K大小计算的话，那么总共需要的页数为2^20，这个时候就需要一个页目录来存储这些页的信息，以方便查找，每一个页表项存储的就是对应页的内存起始地址，每一项的大小为4Byte，这样的话，页目录所需要的内存大小为2^20*4Byte，也就是4MB的大小。</p>
<p>而对于进程来说，一般不会使用这么大的内存空间，加上程序对内存的访问具有局部性，这样的话，就会出现很多的页表项不会被用到，也就是程序所需要的页数很少。如果一直将所有的页目录存在内存的话，或造成很到的内存浪费，此时就出现了多级页表了。</p>
<p>以二级页表来说，将总的页目录按照页的大小（4KB）划分，所得到的二级页数为：4MB/4KB=1K,此时引入一级页表，用来存储二级页表的信息，那么每一个一级页表项的大小为4B，所需要的一级页表大小为4KB，恰好也是一个页的大小，这样，进程在运行的时候，只需要先读取一级页表，接着在根据需要对二级页表以及内存页进行配置，这样就可以大大减少页的索引信息了（因为大部分都是不会被索引的到的，只需要记录目前需要索引的页信息）。</p>
<p>上面说道二级页表，那么对于一个线性地址（虚拟地址），内存怎样把他映射为对应的物理地址呢？我们知道在二级页表下，一级页的大小为4KB，也就是对应着1K的二级页表，所以要索引二级页表，需要将虚拟地址的高10位用来作为一级页表的表内便偏移索引，在找到二级页表后，二级页表也有1K的页数，所以需要虚拟地址的中10位作为二级页表的表内偏移索引，在得到对应的物理页地址的时候，由于每一页有4K大小，想要找到具体的字节地址，那么需要12位的索引，也就是32位地址所剩下的底12位。这样就完成了一个虚拟地址到实际的物理地址的映射。</p>
<p>对于一级页表，其起始地址要怎样存储呢？一般的话，由于起始地址是一个4B的指针，可以存储在寄存器上，所以每次进程运行的时候，每一个进程都有自己的一级页表起始地址，当进程被加载运行的时候，操作系统为其分配的一级页表地址就直接的存在CR3寄存器中，这样开始了进程的虚拟地址访问。</p>
<p>完成虚拟地址到物理地址的转换一般是MMU（Memory Management Unit）硬件来实现的。为了实现跟快的转换，就有了TLB（TranslationLook-aside Buffer），用来根据程序访问内存的局部性机制来缓存已经转换过的虚拟页与实际页的对应关系！TLB 中包含了最近使用过的页面的内存映射信息，处理器提供了专门的电路来并发地读取并比较TLB中的页面映射项。因此，对于频繁使用的虚拟地址，它们很可能在TLB中有对应的映射项，因而处理器可以绝对快速地将虚拟地址转译成物理地址；反之，如果一个虚拟地址没有出现在TLB中，那么处理器必须采用以上介绍的两次查表过程（意味着要两次访问内存）才能完成地址转译。在这种情况下，这一次内存访问会慢一些，但是，经过这次访问以后，此虚拟页面与对应物理页面之间的映射关系将被记录到TLB中，所以，下次再访问此虚拟页面时，处理器就可以从TLB 中实现快速转译，除非此映射项已经被 TLB 移除了。研究表明，由于计算机程序的内存访问有一定的局部性，因此，即使处理器只维护一个相对较小的TLB，程序的运行也能获得较显著的性能提升。</p>
<h3 id="进程的建立和执行"><a href="#进程的建立和执行" class="headerlink" title="进程的建立和执行"></a>进程的建立和执行</h3><p>执行程序时，操作系统会创建一个执行该程序的进程，然后装载程序或程序片段等，然后开始顺序执行代码段。在这个过程中，操作系统总的来说做三件事情：</p>
<h4 id="（1）-为进程创建一个独立的虚拟地址空间（范围）"><a href="#（1）-为进程创建一个独立的虚拟地址空间（范围）" class="headerlink" title="（1） 为进程创建一个独立的虚拟地址空间（范围）"></a>（1） 为进程创建一个独立的虚拟地址空间（范围）</h4><p>例如在32位系统常规分页状态下，操作系统发现待执行程序的指令和数据总和为32KB，那么操作系统会为进程分配8个页的虚拟内存空间，并分配页目录和页表，把页目录装入CR3，把进程用到的页表加载到内存。但并不把指令和数据加载到内存。</p>
<h4 id="（2）-读取程序可执行文件文件头，并且建立虚拟空间与可执行文件中的代码段、数据段的逻辑地址的映射关系"><a href="#（2）-读取程序可执行文件文件头，并且建立虚拟空间与可执行文件中的代码段、数据段的逻辑地址的映射关系" class="headerlink" title="（2） 读取程序可执行文件文件头，并且建立虚拟空间与可执行文件中的代码段、数据段的逻辑地址的映射关系"></a>（2） 读取程序可执行文件文件头，并且建立虚拟空间与可执行文件中的代码段、数据段的逻辑地址的映射关系</h4><p>这一步将程序指令和数据映射到虚拟内存空间中。</p>
<h4 id="（3）-将-CPU-的指令寄存器设置成可执行文件的入口地址，启动运行"><a href="#（3）-将-CPU-的指令寄存器设置成可执行文件的入口地址，启动运行" class="headerlink" title="（3） 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行"></a>（3） 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行</h4><p>执行程序过程时，如果当前指令或数据之在虚拟地址空间中，而实际上并不在物理内存中（前两步都没有将指令或数据加载到物理内存），将发生页错误，这时操作系统再从物理内存分配一个空闲的物理页帧，并将虚拟地址页对应的数据从磁盘拷贝加载到物理页帧中，并建立页表项和页帧的映射关系。随着进程的执行，页错误也会不断产生，操作系统也会响应每个页错误并为进程分配物理内存页帧。但物理内存是有限的，为一个进程可分配的物理内存也有限。全部可用物理内存都分配给进程后，如果进程继续抛出页错误请求更多物理内存，这时候操作系统根据自身的页置换操作算法，在保证进程正常运行的前提下，将先前为进程分配的物理内存页帧收回，重新分给该进程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/19/Linux-内存管理/" data-id="ciq4t54s3003ymgqyv67fkqin" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux-网络编程/" style="font-size: 18px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 18px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 16px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 18px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 14px;">动态规划</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 14px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 12px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 12px;">爬虫</a> <a href="/tags/随记/" style="font-size: 12px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/02/套接字/">套接字</a>
          </li>
        
          <li>
            <a href="/2016/07/02/信号灯/">信号灯</a>
          </li>
        
          <li>
            <a href="/2016/07/02/消息队列/">消息队列</a>
          </li>
        
          <li>
            <a href="/2016/07/02/共享内存/">共享内存</a>
          </li>
        
          <li>
            <a href="/2016/07/02/管道/">管道</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>