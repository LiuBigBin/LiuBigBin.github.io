<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/page/3/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-套接字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/套接字/" class="article-date">
  <time datetime="2016-07-02T06:37:39.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/套接字/">套接字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息队列、信号灯、共享内存等，都是基于Sys V的IPC机制进行讨论的，它们的应用局限在单一计算机内的进程间通信；基于BSD套接口不仅可以实现单机内的进程间通信，还可以实现不同计算机进程之间的通信。</p>
<p>一个套接口可以看作是进程间通信的端点（endpoint），每个套接口的名字都是唯一的（唯一的含义是不言而喻的），其他进程可以发现、连接并且与之通信。通信域用来说明套接口通信的协议，不同的通信域有不同的通信协议以及套接口的地址结构等等，因此，创建一个套接口时，要指明它的通信域。比较常见的是unix域套接口（采用套接口机制实现单机内的进程间通信）及网际通信域。</p>
<h3 id="1、背景知识"><a href="#1、背景知识" class="headerlink" title="1、背景知识"></a>1、背景知识</h3><p>linux目前的网络内核代码主要基于伯克利的BSD的unix实现，整个结构采用的是一种面向对象的分层机制。层与层之间有严格的接口定义。这里我们引用[1]中的一个图表来描述linux支持的一些通信协议：<br><img src="/pictures/Linux/进程间通信/共享内存-套接字通信协议.png" alt=""></p>
<p>我们这里只关心IPS，即因特网协议族，也就是通常所说的TCP/IP网络。我们这里假设读者具有网络方面的一些背景知识，如了解网络的分层结构，通常所说的7层结构；了解IP地址以及路由的一些基本知识。</p>
<p>目前linux网络API是基于BSD套接口的（系统V提供基于流I/O子系统的用户接口，但是linux内核目前不支持流I/O子系统）。套接口可以说是网络编程中一个非常重要的概念，linux以文件的形式实现套接口，与套接口相应的文件属于sockfs特殊文件系统，创建一个套接口就是在sockfs中创建一个特殊文件，并建立起为实现套接口功能的相关数据结构。换句话说，对每一个新创建的BSD套接口，linux内核都将在sockfs特殊文件系统中创建一个新的inode。描述套接口的数据结构是socket，将在后面给出。</p>
<h3 id="2、重要数据结构"><a href="#2、重要数据结构" class="headerlink" title="2、重要数据结构"></a>2、重要数据结构</h3><p>下面是在网络编程中比较重要的几个数据结构，读者可以在后面介绍编程API部分再回过头来了解它们。</p>
<h4 id="（1）表示套接口的数据结构struct-socket"><a href="#（1）表示套接口的数据结构struct-socket" class="headerlink" title="（1）表示套接口的数据结构struct socket"></a>（1）表示套接口的数据结构struct socket</h4><p>套接口是由socket数据结构代表的，形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> socket</span><br><span class="line">&#123;</span><br><span class="line">socket_state  state;     <span class="comment">/* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种</span><br><span class="line">套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>    flags;</span><br><span class="line">  <span class="keyword">struct</span> proto_ops  ops;  <span class="comment">/* 指明可对套接口进行的各种操作 */</span></span><br><span class="line">  <span class="keyword">struct</span> inode    inode;    <span class="comment">/* 指向sockfs文件系统中的相应inode */</span></span><br><span class="line">  <span class="keyword">struct</span> fasync_struct  *fasync_list;  <span class="comment">/* Asynchronous wake up list  */</span></span><br><span class="line">  <span class="keyword">struct</span> file    *file;          <span class="comment">/* 指向sockfs文件系统中的相应文件  */</span></span><br><span class="line"><span class="keyword">struct</span> sock    sk;  <span class="comment">/* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对</span><br><span class="line">象。 */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span>  wait;</span><br><span class="line">  <span class="keyword">short</span>      type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>    passcred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（2）描述套接口通用地址的数据结构struct-sockaddr"><a href="#（2）描述套接口通用地址的数据结构struct-sockaddr" class="headerlink" title="（2）描述套接口通用地址的数据结构struct sockaddr"></a>（2）描述套接口通用地址的数据结构struct sockaddr</h4><p>由于历史的缘故，在bind、connect等系统调用中，特定于协议的套接口地址结构指针都要强制转换成该通用的套接口地址结构指针。结构形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr &#123;</span><br><span class="line">	<span class="keyword">sa_family_t</span>	sa_family;	<span class="comment">/* address family, AF_xxx	*/</span></span><br><span class="line">	<span class="keyword">char</span>		sa_data[<span class="number">14</span>];	<span class="comment">/* 14 bytes of protocol address	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）："><a href="#（3）描述因特网地址结构的数据结构struct-sockaddr-in（这里局限于IP4）：" class="headerlink" title="（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）："></a>（3）描述因特网地址结构的数据结构struct sockaddr_in（这里局限于IP4）：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sockaddr_in</span><br><span class="line">  &#123;</span><br><span class="line">    __SOCKADDR_COMMON (sin_);	<span class="comment">/* 描述协议族 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;			<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="keyword">struct</span> in_addr sin_addr;		<span class="comment">/* 因特网地址 */</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr'.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">			   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">			   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，读者最关心的是前三个域，即通信协议、端口号及地址。</p>
<h3 id="3、套接口编程的几个重要步骤："><a href="#3、套接口编程的几个重要步骤：" class="headerlink" title="3、套接口编程的几个重要步骤："></a>3、套接口编程的几个重要步骤：</h3><h4 id="（1）创建套接口，由系统调用socket实现："><a href="#（1）创建套接口，由系统调用socket实现：" class="headerlink" title="（1）创建套接口，由系统调用socket实现："></a>（1）创建套接口，由系统调用socket实现：</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> ptotocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数domain指明通信域，如PF_UNIX（unix域），PF_INET（IPv4），PF_INET6(IPv6)等；type指明通信类型，如SOCK_STREAM(面向连接方式)、SOCK_DGRAM(非面向连接方式)等。一般来说，参数protocol可设置为0，除非用在原始套接口上（原始套接口有一些特殊功能，后面还将介绍）。</p>
<p>注：socket（）系统调用为套接口在sockfs文件系统中分配一个新的文件和dentry对象，并通过文件描述符把它们与调用进程联系起来。进程可以像访问一个已经打开的文件一样访问套接口在sockfs中的对应文件。但进程绝不能调用open()来访问该文件（sockfs文件系统没有可视安装点，其中的文件永远不会出现在系统目录树上），当套接口被关闭时，内核会自动删除sockfs中的inodes。</p>
<h4 id="（2）绑定地址"><a href="#（2）绑定地址" class="headerlink" title="（2）绑定地址"></a>（2）绑定地址</h4><p>根据传输层协议（TCP、UDP）的不同，客户机及服务器的处理方式也有很大不同。但是，不管通信双方使用何种传输协议，都需要一种标识自己的机制。</p>
<p>通信双方一般由两个方面标识：地址和端口号（通常，一个IP地址和一个端口号常常被称为一个套接口）。根据地址可以寻址到主机，根据端口号则可以寻址到主机提供特定服务的进程，实际上，一个特定的端口号代表了一个提供特定服务的进程。</p>
<p>对于使用TCP传输协议通信方式来说，通信双方需要给自己绑定一个唯一标识自己的套接口，以便建立连接；对于使用UDP传输协议，只需要服务器绑定一个标识自己的套接口就可以了，用户则不需要绑定(在需要时，如调用connect时[注1]，内核会自动分配一个本地地址和本地端口号)。绑定操作由系统调用bind()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * my_addr, socklen_t my_addr_len)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第二个参数对于Ipv4来说，实际上需要填充的结构是struct sockaddr_in，前面已经介绍了该结构。这里只想强调该结构的第一个域，它表明该套接口使用的通信协议，如AF_INET。联系socket系统调用的第一个参数，读者可能会想到PF_INET与AF_INET究竟有什么不同？实际上，原来的想法是每个通信域（如PF_INET）可能对应多个协议（如AF<em>INET），而事实上支持多个协议的通信域一直没有实现。因此，在linux内核中，AF</em><strong><em>与PF_</em></strong>被定义为同一个常数，因此，在编程时可以不加区分地使用他们。</p>
<p>注1：在采用非面向连接通信方式时，也会用到connect()调用，不过与在面向连接中的connect（）调用有本质的区别：在非面向连接通信中，connect调用只是先设置一下对方的地址，内核为本地套接口记下对方的地址，然后采用send()来发送数据，这样避免每次发送时都要提供相同的目的地址。其中的connect()调用不涉及握手过程；而在面向连接的通信方式中，connect()要完成一个严格的握手过程。</p>
<h4 id="（3）请求建立连接（由TCP客户发起）"><a href="#（3）请求建立连接（由TCP客户发起）" class="headerlink" title="（3）请求建立连接（由TCP客户发起）"></a>（3）请求建立连接（由TCP客户发起）</h4><p>对于采用面向连接的传输协议TCP实现通信来说，一个比较重要的步骤就是通信双方建立连接（如果采用udp传输协议则不需要），由系统调用connect()完成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr * servaddr, socklen_t addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数为本地调用socket后返回的描述符，第二个参数为服务器的地址结构指针。connect（）向指定的套接口请求建立连接。</p>
<p>注：与connect（）相对应，在服务器端，通过系统调用listen()，指定服务器端的套接口为监听套接口，监听每一个向服务器套接口发出的连接请求，并通过握手机制建立连接。内核为listen()维护两个队列：已完成连接队列和未完成连接队列。</p>
<h4 id="（4）接受连接请求（由TCP服务器端发起）"><a href="#（4）接受连接请求（由TCP服务器端发起）" class="headerlink" title="（4）接受连接请求（由TCP服务器端发起）"></a>（4）接受连接请求（由TCP服务器端发起）</h4><p>服务器端通过监听套接口，为所有连接请求建立了两个队列：已完成连接队列和未完成连接队列（每个监听套接口都对应这样两个队列，当然，一般服务器只有一个监听套接口）。通过accept()调用，服务器将在监听套接口的已连接队列头中，返回用于代表当前连接的套接口描述字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">( <span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr * cliaddr, socklen_t * addrlen)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数指明哪个监听套接口，一般是由listen（）系统调用指定的（由于每个监听套接口都对应已连接和未连接两个队列，因此它的内部机制实质是通过sockfd指定在哪个已连接队列头中返回一个用于当前客户的连接，如果相应的已连接队列为空，accept进入睡眠）。第二个参数指明客户的地址结构，如果对客户的身份不感兴趣，可指定其为空。</p>
<p>注：对于采用TCP传输协议进行通信的服务器和客户机来说，一定要经过客户请求建立连接，服务器接受连接请求这一过程；而对采用UDP传输协议的通信双方则不需要这一步骤。</p>
<h4 id="（5）通信"><a href="#（5）通信" class="headerlink" title="（5）通信"></a>（5）通信</h4><p>客户机可以通过套接口接收服务器传过来的数据，也可以通过套接口向服务器发送数据。前面所有的准备工作（创建套接口、绑定等操作）都是为这一步骤准备的。</p>
<p>常用的从套接口中接收数据的调用有：recv、recvfrom、recvmsg等，常用的向套接口中发送数据的调用有send、sendto、sendmsg等。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">void</span> *</span><br><span class="line">        buf, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvfrom</span>(<span class="params"><span class="keyword">int</span> s,  <span class="keyword">void</span> *</span><br><span class="line">        buf,  size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags, <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        <span class="keyword">from</span>, socklen_t *</span><br><span class="line">        fromlen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">recvmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">send</span>(<span class="params"><span class="keyword">int</span> s,<span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendto</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">void</span> *</span><br><span class="line">        msg, size_t</span><br><span class="line">        len, <span class="keyword">int</span></span><br><span class="line">        flags <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *</span><br><span class="line">        to, socklen_t</span><br><span class="line">        tolen</span>)</span><br><span class="line"><span class="keyword">int</span> <span class="title">sendmsg</span>(<span class="params"><span class="keyword">int</span> s, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *</span><br><span class="line">        msg, <span class="keyword">int</span></span><br><span class="line">        flags</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>这里不再对这些调用作具体的说明，只想强调一下，recvfrom（）以及recvmsg（）可用于面向连接的套接口，也可用于面向非连接的套接口；而recv（）一般用于面向连接的套接口。另外，在调用了connect()之后，就应给调用send()而不是sendto()了，因为调用了connect之后，目标就已经确定了。</p>
<p>前面讲到，socket（）系统调用返回套接口描述字，实际上它是一个文件描述符。所以，可以对套接口进行通常的读写操作，即使用read()及write()方法。在实际应用中，由于面向连接的通信（采用TCP传输协议）是可靠的，同时又保证字节流原有的顺序，所以更适合用read及write方法。而非面向连接的通信（采用UDP传输协议）是不可靠的，字节流也不一定保持原有的顺序，所以一般不宜用read及write方法。</p>
<h4 id="（6）通信的最后一步是关闭套接口"><a href="#（6）通信的最后一步是关闭套接口" class="headerlink" title="（6）通信的最后一步是关闭套接口"></a>（6）通信的最后一步是关闭套接口</h4><p>由close()来完成此项功能，它唯一的参数是套接口描述字，不再赘述。</p>
<h3 id="4、典型调用代码："><a href="#4、典型调用代码：" class="headerlink" title="4、典型调用代码："></a>4、典型调用代码：</h3><p>到处可以发现基于套接口的客户机及服务器程序，这里不再给出完整的范例代码，只是给出它们的典型调用代码，并给出简要说明。</p>
<h4 id="（1）典型的TCP服务器代码："><a href="#（1）典型的TCP服务器代码：" class="headerlink" title="（1）典型的TCP服务器代码："></a>（1）典型的TCP服务器代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="keyword">int</span> listen_fd, connect_fd;</span><br><span class="line"><span class="keyword">struct</span> sockaddr_in serv_addr, client_addr;</span><br><span class="line">... ...</span><br><span class="line">listen_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建网际Ipv4域的（由PF_INET指定）面向连接的（由SOCK_STREAM指定，</span><br><span class="line">如果创建非面向连接的套接口则指定为SOCK_DGRAM）</span><br><span class="line">的套接口。第三个参数0表示由内核确定缺省的传输协议，</span><br><span class="line">对于本例，由于创建的是可靠的面向连接的基于流的套接口，</span><br><span class="line">内核将选择TCP作为本套接口的传输协议） */</span></span><br><span class="line"></span><br><span class="line">bzero( &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr) );</span><br><span class="line">serv_addr.sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr.sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, &amp;serv_addr.sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">bind( listen_fd, (<span class="keyword">struct</span> sockaddr*) serv_addr, <span class="keyword">sizeof</span> ( <span class="keyword">struct</span> sockaddr_in )) ;</span><br><span class="line"><span class="comment">/* 实现绑定操作 */</span></span><br><span class="line">listen( listen_fd, max_num) ;</span><br><span class="line"><span class="comment">/* 套接口进入侦听状态，max_num规定了内核为此套接口排队的最大连接个数 */</span></span><br><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">... ...</span><br><span class="line">connect_fd = accept( listen_fd, (<span class="keyword">struct</span> sockaddr*)client_addr, &amp;len ) ; <span class="comment">/* 获得连接fd. */</span></span><br><span class="line">... ...					<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：端口号的分配是有一些惯例的，不同的端口号对应不同的服务或进程。比如一般都把端口号21分配给FTP服务器的TCP/IP实现。端口号一般分为3段，0-1023（受限的众所周知的端口，由分配数值的权威机构IANA管理），1024-49151（可以从IANA那里申请注册的端口），49152-65535（临时端口，这就是为什么代码中的端口号为49152）。</p>
<p>对于多字节整数在内存中有两种存储方式：一种是低字节在前，高字节在后，这样的存储顺序被称为低端字节序（little-endian）；高字节在前，低字节在后的存储顺序则被称为高端字节序（big-endian）。网络协议在处理多字节整数时，采用的是高端字节序，而不同的主机可能采用不同的字节序。因此在编程时一定要考虑主机字节序与网络字节序间的相互转换。这就是程序中使用htons函数的原因，它返回网络字节序的整数。</p>
<h4 id="（2）典型的TCP客户代码："><a href="#（2）典型的TCP客户代码：" class="headerlink" title="（2）典型的TCP客户代码："></a>（2）典型的TCP客户代码：</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">int socket_fd;</span><br><span class="line">struct sockaddr_in serv_addr ;</span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">socket_fd = socket ( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">bzero( <span class="subst">&amp;</span>serv_addr, sizeof(serv_addr) );</span><br><span class="line">serv_addr<span class="built_in">.</span>sin_family = AF_INET ;  <span class="comment">/* 指明通信协议族 */</span></span><br><span class="line">serv_addr<span class="built_in">.</span>sin_port = htons( <span class="number">49152</span> ) ;       <span class="comment">/* 分配端口号 */</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">" 192.168.0.11"</span>, <span class="subst">&amp;</span>serv_addr<span class="built_in">.</span>sin_sddr) ;</span><br><span class="line"><span class="comment">/* 分配地址，把点分十进制IPv4地址转化为32位二进制Ipv4地址。 */</span></span><br><span class="line">connect( socket_fd, (struct sockaddr*)serv_addr, sizeof( serv_addr ) ) ; <span class="comment">/* 向服务器发起连接请求 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span>							<span class="comment">/* 发送和接收数据 */</span></span><br><span class="line"><span class="attribute">...</span> <span class="attribute">...</span></span><br></pre></td></tr></table></figure>
<p>对比两段代码可以看出，许多调用是服务器或客户机所特有的。另外，对于非面向连接的传输协议，代码还有简单些，没有连接的发起请求和接收请求部分。</p>
<h3 id="5、网络编程中的其他重要概念"><a href="#5、网络编程中的其他重要概念" class="headerlink" title="5、网络编程中的其他重要概念"></a>5、网络编程中的其他重要概念</h3><p>下面列出了网络编程中的其他重要概念，基本上都是给出这些概念能够实现的功能，读者在编程过程中如果需要这些功能，可查阅相关概念。</p>
<h4 id="（1）、I-O复用的概念"><a href="#（1）、I-O复用的概念" class="headerlink" title="（1）、I/O复用的概念"></a>（1）、I/O复用的概念</h4><p>I/O复用提供一种能力，这种能力使得当一个I/O条件满足时，进程能够及时得到这个信息。I/O复用一般应用在进程需要处理多个描述字的场合。它的一个优势在于，进程不是阻塞在真正的I/O调用上，而是阻塞在select()调用上，select()可以同时处理多个描述字，如果它所处理的所有描述字的I/O都没有处于准备好的状态，那么将阻塞；如果有一个或多个描述字I/O处于准备好状态，则select()不阻塞，同时会根据准备好的特定描述字采取相应的I/O操作。</p>
<h4 id="（2）、Unix通信域"><a href="#（2）、Unix通信域" class="headerlink" title="（2）、Unix通信域"></a>（2）、Unix通信域</h4><p>前面主要介绍的是PF_INET通信域，实现网际间的进程间通信。基于Unix通信域（调用socket时指定通信域为PF_LOCAL即可）的套接口可以实现单机之间的进程间通信。采用Unix通信域套接口有几个好处：Unix通信域套接口通常是TCP套接口速度的两倍；另一个好处是，通过Unix通信域套接口可以实现在进程间传递描述字。所有可用描述字描述的对象，如文件、管道、有名管道及套接口等，在我们以某种方式得到该对象的描述字后，都可以通过基于Unix域的套接口来实现对描述字的传递。接收进程收到的描述字值不一定与发送进程传递的值一致（描述字是特定于进程的），但是特们指向内核文件表中相同的项。</p>
<h4 id="（3）、原始套接口"><a href="#（3）、原始套接口" class="headerlink" title="（3）、原始套接口"></a>（3）、原始套接口</h4><p>原始套接口提供一般套接口所不提供的功能：<br>原始套接口可以读写一些用于控制的控制协议分组，如ICMPv4等，进而可实现一些特殊功能。<br>原始套接口可以读写特殊的IPv4数据包。内核一般只处理几个特定协议字段的数据包，那么一些需要不同协议字段的数据包就需要通过原始套接口对其进行读写；<br>通过原始套接口可以构造自己的Ipv4头部，也是比较有意思的一点。</p>
<p>创建原始套接口需要root权限。</p>
<h4 id="（4）、对数据链路层的访问"><a href="#（4）、对数据链路层的访问" class="headerlink" title="（4）、对数据链路层的访问"></a>（4）、对数据链路层的访问</h4><p>对数据链路层的访问，使得用户可以侦听本地电缆上的所有分组，而不需要使用任何特殊的硬件设备，在linux下读取数据链路层分组需要创建SOCK_PACKET类型的套接口，并需要有root权限。</p>
<h4 id="（5）、带外数据（out-of-band-data）"><a href="#（5）、带外数据（out-of-band-data）" class="headerlink" title="（5）、带外数据（out-of-band data）"></a>（5）、带外数据（out-of-band data）</h4><p>如果有一些重要信息要立刻通过套接口发送（不经过排队），请查阅与带外数据相关的文献。</p>
<h4 id="（6）、多播"><a href="#（6）、多播" class="headerlink" title="（6）、多播"></a>（6）、多播</h4><p>linux内核支持多播，但是在默认状态下，多数linux系统都关闭了对多播的支持。因此，为了实现多播，可能需要重新配置并编译内核。具体请参考[4]及[2]。</p>
<p>结论：linux套接口编程的内容可以说是极大丰富，同时它涉及到许多的网络背景知识，有兴趣的读者可在[2]中找到比较系统而全面的介绍。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>Understanding the Linux Kernel, 2nd Edition, By Daniel P. Bovet, Marco Cesati , 对各主题阐述得重点突出，脉络清晰。网络部分分析集中在TCP/IP协议栈的数据连路层、网络层以及传输层。</li>
<li>UNIX网络编程第一卷：套接口API和X/Open传输接口API，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。不仅对套接口网络编程有极好的描述，而且极为详尽的阐述了相关的网络背景知识。不论是入门还是深入研究，都是不可多得的好资料。</li>
<li>Linux内核源代码情景分析（下），毛德操、胡希明著，浙江大学出版社，给出了unix域套接口部分的内核代码分析。</li>
<li>GNU/Linux编程指南，入门、应用、精通，第二版，Kurt Wall等著，张辉译</li>
</ol>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part6/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/套接字/" data-id="ciqklv21i001qroqybxforxtq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-信号灯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/信号灯/" class="article-date">
  <time datetime="2016-07-02T04:57:06.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/信号灯/">信号灯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。</p>
<h3 id="一、信号灯概述"><a href="#一、信号灯概述" class="headerlink" title="一、信号灯概述"></a>一、信号灯概述</h3><p>信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号灯有以下两种类型：</p>
<ol>
<li>二值信号灯：最简单的信号灯形式，信号灯的值只能取0或1，类似于互斥锁。<br>注：二值信号灯能够实现互斥锁的功能，但两者的关注内容不同。信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</li>
<li>计算信号灯：信号灯的值可以取任意非负值（当然受内核本身的约束）。</li>
</ol>
<h3 id="二、Linux信号灯"><a href="#二、Linux信号灯" class="headerlink" title="二、Linux信号灯"></a>二、Linux信号灯</h3><p>linux对信号灯的支持状况与消息队列一样，在red had 8.0发行版本中支持的是系统V的信号灯。因此，本文将主要介绍系统V信号灯及其相应API。在没有声明的情况下，以下讨论中指的都是系统V信号灯。</p>
<p>注意，通常所说的系统V信号灯指的是计数信号灯集。</p>
<h3 id="三、信号灯与内核"><a href="#三、信号灯与内核" class="headerlink" title="三、信号灯与内核"></a>三、信号灯与内核</h3><ol>
<li><p>系统V信号灯是随内核持续的，只有在内核重起或者显示删除一个信号灯集时，该信号灯集才会真正被删除。因此系统中记录信号灯的数据结构（struct ipc_ids sem_ids）位于内核中，系统中的所有信号灯都可以在结构sem_ids中找到访问入口。</p>
</li>
<li><p>下图说明了内核与信号灯是怎样建立起联系的：<br>其中：struct ipc_ids sem_ids是内核中记录信号灯的全局数据结构；描述一个具体的信号灯及其相关信息。<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯全局数据结构.png" alt=""></p>
</li>
</ol>
<p>其中，struct sem结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sem&#123;</span><br><span class="line"><span class="keyword">int</span> semval;		<span class="comment">// current value</span></span><br><span class="line"><span class="keyword">int</span> sempid		<span class="comment">// pid of last operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上图可以看出，全局数据结构struct ipc_ids sem_ids可以访问到struct kern_ipc_perm的第一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的信号灯对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个信号灯集；同时，结构struct kern_ipc_perm的最后一个成员sem_nsems确定了该信号灯在信号灯集中的顺序，这样内核就能够记录每个信号灯的信息了。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*系统中的每个信号灯集对应一个sem_array 结构 */</span><br><span class="line">struct sem_array &#123;</span><br><span class="line">  struct kern_ipc_perm  sem_perm;    /* permissions .. see ipc.h */</span><br><span class="line">  time_t      sem_otime;      /* last semop time */</span><br><span class="line">  time_t      sem_ctime;      /* last change time */</span><br><span class="line">  struct sem    *sem_base;      /* ptr to first semaphore in<span class="instruction"> array </span>*/</span><br><span class="line">  struct sem_queue  *sem_pending;    /* pending operations to be processed */</span><br><span class="line">  struct sem_queue  **sem_pending_last;   /* last pending operation */</span><br><span class="line">  struct sem_undo    *undo;      /* undo requests on this<span class="instruction"> array </span>*/</span><br><span class="line">  unsigned<span class="instruction"> long </span>   sem_nsems;    /* no. of semaphores in<span class="instruction"> array </span>*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，sem_queue结构如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span> 系统中每个因为信号灯而睡眠的进程，都对应一个sem_queue结构<span class="keyword">*</span>/</span><br><span class="line"> struct sem_queue &#123;</span><br><span class="line">  struct sem_queue <span class="keyword">*</span>  next;     /<span class="keyword">*</span> next entry in the queue <span class="keyword">*</span>/</span><br><span class="line">  struct sem_queue <span class="keyword">*</span><span class="keyword">*</span>  prev;</span><br><span class="line">  /<span class="keyword">*</span> previous entry in the queue, <span class="keyword">*</span>(q-&gt;prev) == q <span class="keyword">*</span>/</span><br><span class="line">  struct task_struct<span class="keyword">*</span>  sleeper;   /<span class="keyword">*</span> this process <span class="keyword">*</span>/</span><br><span class="line">  struct sem_undo <span class="keyword">*</span>  undo;     /<span class="keyword">*</span> undo structure <span class="keyword">*</span>/</span><br><span class="line">  int   pid;             /<span class="keyword">*</span> process id of requesting process <span class="keyword">*</span>/</span><br><span class="line">  int   status;           /<span class="keyword">*</span> completion status of operation <span class="keyword">*</span>/</span><br><span class="line">  struct sem_array <span class="keyword">*</span>  sma;       /<span class="keyword">*</span> semaphore array for operations <span class="keyword">*</span>/</span><br><span class="line">  int  id;               /<span class="keyword">*</span> internal sem id <span class="keyword">*</span>/</span><br><span class="line">  struct sembuf <span class="keyword">*</span>  sops;       /<span class="keyword">*</span> array of pending operations <span class="keyword">*</span>/</span><br><span class="line">  int  nsops;             /<span class="keyword">*</span> number of operations <span class="keyword">*</span>/</span><br><span class="line">  int  alter;             /<span class="keyword">*</span> operation will alter semaphore <span class="keyword">*</span>/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、操作信号灯"><a href="#四、操作信号灯" class="headerlink" title="四、操作信号灯"></a>四、操作信号灯</h3><p>对消息队列的操作无非有下面三种类型：</p>
<ol>
<li><p>打开或创建信号灯<br>与消息队列的创建及打开基本相同，不再详述。</p>
</li>
<li><p>信号灯值操作<br>linux可以增加或减小信号灯的值，相应于对共享资源的释放和占有。具体参见后面的semop系统调用。</p>
</li>
<li><p>获得或设置信号灯属性：<br>系统中的每一个信号灯集都对应一个struct sem_array结构，该结构记录了信号灯集的各种信息，存在于系统空间。为了设置、获得该信号灯集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即union semun。<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯union_semun数据结构.png" alt=""></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">	<span class="keyword">int</span> val;					<span class="comment">/* value for SETVAL */</span></span><br><span class="line">	<span class="keyword">struct</span> semid_ds *buf;		<span class="comment">/* buffer for IPC_STAT &amp; IPC_SET */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;		<span class="comment">/* array for GETALL &amp; SETALL */</span></span><br><span class="line">	<span class="keyword">struct</span> seminfo *__buf;		<span class="comment">/* buffer for IPC_INFO */</span>   <span class="comment">//test!!</span></span><br><span class="line">	<span class="keyword">void</span> *__pad;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span>  seminfo &#123;</span><br><span class="line">	<span class="keyword">int</span> semmap;</span><br><span class="line">	<span class="keyword">int</span> semmni;</span><br><span class="line">	<span class="keyword">int</span> semmns;</span><br><span class="line">	<span class="keyword">int</span> semmnu;</span><br><span class="line">	<span class="keyword">int</span> semmsl;</span><br><span class="line">	<span class="keyword">int</span> semopm;</span><br><span class="line">	<span class="keyword">int</span> semume;</span><br><span class="line">	<span class="keyword">int</span> semusz;</span><br><span class="line">	<span class="keyword">int</span> semvmx;</span><br><span class="line">	<span class="keyword">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="信号灯API"><a href="#信号灯API" class="headerlink" title="信号灯API"></a>信号灯API</h3><h4 id="1、文件名到键值"><a href="#1、文件名到键值" class="headerlink" title="1、文件名到键值"></a>1、文件名到键值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)；</span><br></pre></td></tr></table></figure>
<p>它返回与路径pathname相对应的一个键值.</p>
<h4 id="2、linux特有的ipc-调用："><a href="#2、linux特有的ipc-调用：" class="headerlink" title="2、linux特有的ipc()调用："></a>2、linux特有的ipc()调用：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> call, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> third, <span class="keyword">void</span> \*ptr, <span class="keyword">long</span> fifth)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数call取不同值时，对应信号灯的三个系统调用：</p>
<ol>
<li>当call为SEMOP时，对应int semop(int semid, struct sembuf *sops, unsigned nsops)调用；</li>
<li>当call为SEMGET时，对应int semget(key_t key, int nsems, int semflg)调用；</li>
<li>当call为SEMCTL时，对应int semctl(int semid，int semnum，int cmd，union semun arg)调用；<br>这些调用将在后面阐述。</li>
</ol>
<h3 id="3、系统V信号灯API"><a href="#3、系统V信号灯API" class="headerlink" title="3、系统V信号灯API"></a>3、系统V信号灯API</h3><p>系统V消息队列API只有三个，使用时需要包括几个头文件：<br> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="1）int-semget-key-t-key-int-nsems-int-semflg"><a href="#1）int-semget-key-t-key-int-nsems-int-semflg" class="headerlink" title="1）int semget(key_t key, int nsems, int semflg)"></a>1）int semget(key_t key, int nsems, int semflg)</h5><p>  参数key是一个键值，由ftok获得，唯一标识一个信号灯集，用法与msgget()中的key相同；参数nsems指定打开或者新创建的信号灯集中将包含信号灯的数目；semflg参数是一些标志位。参数key和semflg的取值，以及何时打开已有信号灯集或者创建一个新的信号灯集与msgget()中的对应部分相同，不再祥述。<br>  该调用返回与健值key相对应的信号灯集描述字。<br>  调用返回：成功返回信号灯集描述字，否则返回-1。<br>  注：如果key所代表的信号灯已经存在，且semget指定了IPC_CREAT|IPC_EXCL标志，那么即使参数nsems与原来信号灯的数目不等，返回的也是EEXIST错误；如果semget只指定了IPC_CREAT标志，那么参数nsems必须与原来的值一致，在后面程序实例中还要进一步说明。</p>
<h5 id="2）int-semop-int-semid-struct-sembuf-sops-unsigned-nsops"><a href="#2）int-semop-int-semid-struct-sembuf-sops-unsigned-nsops" class="headerlink" title="2）int semop(int semid, struct sembuf *sops, unsigned nsops);"></a>2）int semop(int semid, struct sembuf *sops, unsigned nsops);</h5><p>  semid是信号灯集ID，sops指向数组的每一个sembuf结构都刻画一个在特定信号灯上的操作。nsops为sops指向数组的大小。<br>  sembuf结构如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sembuf &#123;</span><br><span class="line">	unsigned short  	sem_num;		/* semaphore index in<span class="instruction"> array </span>*/</span><br><span class="line">	short			sem_op;		/* semaphore operation */</span><br><span class="line">	short			sem_flg;		/* operation flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>sem_num对应信号集中的信号灯，0对应第一个信号灯。sem_flg可取IPC_NOWAIT以及SEM_UNDO两个标志。如果设置了SEM_UNDO标志，那么在进程结束时，相应的操作将被取消，这是比较重要的一个标志位。如果设置了该标志位，那么在进程没有释放共享资源就退出时，内核将代为释放。如果为一个信号灯设置了该标志，内核都要分配一个sem_undo结构来记录它，为的是确保以后资源能够安全释放。事实上，如果进程退出了，那么它所占用就释放了，但信号灯值却没有改变，此时，信号灯值反映的已经不是资源占有的实际情况，在这种情况下，问题的解决就靠内核来完成。这有点像僵尸进程，进程虽然退出了，资源也都释放了，但内核进程表中仍然有它的记录，此时就需要父进程调用waitpid来解决问题了。<br> sem_op的值大于0，等于0以及小于0确定了对sem_num指定的信号灯进行的三种操作。具体请参考linux相应手册页。<br> 这里需要强调的是semop同时操作多个信号灯，在实际应用中，对应多种资源的申请或释放。semop保证操作的原子性，这一点尤为重要。尤其对于多种资源的申请来说，要么一次性获得所有资源，要么放弃申请，要么在不占有任何资源情况下继续等待，这样，一方面避免了资源的浪费；另一方面，避免了进程之间由于申请共享资源造成死锁。<br> 也许从实际含义上更好理解这些操作：信号灯的当前值记录相应资源目前可用数目；sem_op&gt;0对应相应进程要释放sem_op数目的共享资源；sem_op=0可以用于对共享资源是否已用完的测试；sem_op&lt;0相当于进程要申请-sem_op个共享资源。再联想操作的原子性，更不难理解该系统调用何时正常返回，何时睡眠等待。<br> 调用返回：成功返回0，否则返回-1。</p>
<h5 id="3-int-semctl-int-semid，int-semnum，int-cmd，union-semun-arg"><a href="#3-int-semctl-int-semid，int-semnum，int-cmd，union-semun-arg" class="headerlink" title="3) int semctl(int semid，int semnum，int cmd，union semun arg)"></a>3) int semctl(int semid，int semnum，int cmd，union semun arg)</h5><p> 该系统调用实现对信号灯的各种控制操作，参数semid指定信号灯集，参数cmd指定具体的操作类型；参数semnum指定对哪个信号灯操作，只对几个特殊的cmd操作有意义；arg用于设置或返回信号灯信息。<br> 该系统调用详细信息请参见其手册页，这里只给出参数cmd所能指定的操作。</p>
<ol>
<li><p>IPC_STAT</p>
<p>获取信号灯信息，信息由arg.buf返回；</p>
</li>
</ol>
<ol>
<li><p>IPC_SET 设置信号灯信息，待设置信息保存在arg.buf中（在manpage中给出了可以设置哪些信息）；<br>GETALL 返回所有信号灯的值，结果保存在arg.array中，参数sennum被忽略；<br>GETNCNT 返回等待semnum所代表信号灯的值增加的进程数，相当于目前有多少进程在等待semnum代表的信号灯所代表的共享资源；<br>GETPID 返回最后一个对semnum所代表信号灯执行semop操作的进程ID；<br>GETVAL 返回semnum所代表信号灯的值；<br>GETZCNT 返回等待semnum所代表信号灯的值变成0的进程数；<br>SETALL 通过arg.array更新所有信号灯的值；同时，更新与本信号集相关的semid_ds结构的sem_ctime成员；<br>SETVAL 设置semnum所代表信号灯的值为arg.val；</p>
<p>调用返回：调用失败返回-1，成功返回与cmd相关：</p>
</li>
</ol>
<h6 id="Cmd-return-value"><a href="#Cmd-return-value" class="headerlink" title="Cmd          return value"></a>Cmd          return value</h6><p> GETNCNT      Semncnt<br> GETPID       Sempid<br> GETVAL       Semval<br> GETZCNT      Semzcnt</p>
<h3 id="五、信号灯的限制"><a href="#五、信号灯的限制" class="headerlink" title="五、信号灯的限制"></a>五、信号灯的限制</h3><ol>
<li><p>一次系统调用semop可同时操作的信号灯数目SEMOPM，semop中的参数nsops如果超过了这个数目，将返回E2BIG错误。SEMOPM的大小特定与系统，redhat 8.0为32。</p>
</li>
<li><p>信号灯的最大数目：SEMVMX，当设置信号灯值超过这个限制时，会返回ERANGE错误。在redhat 8.0中该值为32767。</p>
</li>
<li><p>系统范围内信号灯集的最大数目SEMMNI以及系统范围内信号灯的最大数目SEMMNS。超过这两个限制将返回ENOSPC错误。redhat 8.0中该值为32000。</p>
</li>
<li><p>每个信号灯集中的最大信号灯数目SEMMSL，redhat 8.0中为250。 SEMOPM以及SEMVMX是使用semop调用时应该注意的；SEMMNI以及SEMMNS是调用semget时应该注意的。SEMVMX同时也是semctl调用应该注意的。</p>
</li>
</ol>
<h3 id="六、竞争问题"><a href="#六、竞争问题" class="headerlink" title="六、竞争问题"></a>六、竞争问题</h3><p>第一个创建信号灯的进程同时也初始化信号灯，这样，系统调用semget包含了两个步骤：创建信号灯；初始化信号灯。由此可能导致一种竞争状态：第一个创建信号灯的进程在初始化信号灯时，第二个进程又调用semget，并且发现信号灯已经存在，此时，第二个进程必须具有判断是否有进程正在对信号灯进行初始化的能力。在参考文献[1]中，给出了绕过这种竞争状态的方法：当semget创建一个新的信号灯时，信号灯结构semid_ds的sem_otime成员初始化后的值为0。因此，第二个进程在成功调用semget后，可再次以IPC_STAT命令调用semctl，等待sem_otime变为非0值，此时可判断该信号灯已经初始化完毕。下图描述了竞争状态产生及解决方法：<br><img src="/pictures/Linux/进程间通信/共享内存-信号灯竞争问题.png" alt=""><br>实际上，这种解决方法也是基于这样一个假定：第一个创建信号灯的进程必须调用semop，这样sem_otime才能变为非零值。另外，因为第一个进程可能不调用semop，或者semop操作需要很长时间，第二个进程可能无限期等待下去，或者等待很长时间。</p>
<h3 id="七、信号灯应用实例"><a href="#七、信号灯应用实例" class="headerlink" title="七、信号灯应用实例"></a>七、信号灯应用实例</h3><p>本实例有两个目的：1、获取各种信号灯信息；2、利用信号灯实现共享资源的申请和释放。并在程序中给出了详细注释。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SEM_PATH <span class="string">"/unix/my_sem"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> max_tries <span class="number">3</span></span></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flag1,flag2,key,i,init_ok,tmperrno;</span><br><span class="line"><span class="keyword">struct</span> semid_ds sem_info;</span><br><span class="line"><span class="keyword">struct</span> seminfo sem_info2;</span><br><span class="line"><span class="keyword">union</span> semun arg;       <span class="comment">//union semun： 请参考附录2</span></span><br><span class="line"><span class="keyword">struct</span> sembuf askfor_res, free_res;</span><br><span class="line">flag1=IPC_CREAT|IPC_EXCL|<span class="number">00666</span>;</span><br><span class="line">flag2=IPC_CREAT|<span class="number">00666</span>;</span><br><span class="line">key=ftok(SEM_PATH,<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//error handling for ftok here;</span></span><br><span class="line">init_ok=<span class="number">0</span>;</span><br><span class="line">semid=semget(key,<span class="number">1</span>,flag1);</span><br><span class="line"><span class="comment">//create a semaphore set that only includes one semphore.</span></span><br><span class="line"><span class="keyword">if</span>(semid&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  tmperrno=errno;</span><br><span class="line">  perror(<span class="string">"semget"</span>);</span><br><span class="line"><span class="keyword">if</span>(tmperrno==EEXIST)</span><br><span class="line"><span class="comment">//errno is undefined after a successful library call( including perror call)</span></span><br><span class="line"><span class="comment">//so it is saved  in tmperrno.</span></span><br><span class="line">    &#123;</span><br><span class="line">    semid=semget(key,<span class="number">1</span>,flag2);</span><br><span class="line"><span class="comment">//flag2 只包含了IPC_CREAT标志, 参数nsems(这里为1)必须与原来的信号灯数目一致</span></span><br><span class="line">    arg.buf=&amp;sem_info;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;max_tries; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_STAT, arg)==-<span class="number">1</span>)</span><br><span class="line">      &#123;  perror(<span class="string">"semctl error"</span>); i=max_tries;&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(arg.buf-&gt;sem_otime!=<span class="number">0</span>)&#123; i=max_tries;  init_ok=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span>   sleep(<span class="number">1</span>);  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!init_ok)</span><br><span class="line">  <span class="comment">// do some initializing, here we assume that the first process that creates the sem</span></span><br><span class="line">  <span class="comment">//  will finish initialize the sem and run semop in max_tries*1 seconds. else it will  </span></span><br><span class="line">  <span class="comment">// not run semop any more.</span></span><br><span class="line">    &#123;</span><br><span class="line">      arg.val=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,arg)==-<span class="number">1</span>) perror(<span class="string">"semctl setval error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;perror(<span class="string">"semget error, process exit"</span>);  <span class="built_in">exit</span>();  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//semid&gt;=0; do some initializing   </span></span><br><span class="line">&#123;</span><br><span class="line">  arg.val=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl setval error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get some information about the semaphore and the limit of semaphore in redhat8.0</span></span><br><span class="line">  arg.buf=&amp;sem_info;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_STAT, arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC STAT"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"owner's uid is %d\n"</span>,   arg.buf-&gt;sem_perm.uid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"owner's gid is %d\n"</span>,   arg.buf-&gt;sem_perm.gid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"creater's uid is %d\n"</span>,   arg.buf-&gt;sem_perm.cuid);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"creater's gid is %d\n"</span>,   arg.buf-&gt;sem_perm.cgid);</span><br><span class="line">  arg.__buf=&amp;sem_info2;</span><br><span class="line">  <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,IPC_INFO,arg)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC_INFO"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the number of entries in semaphore map is %d \n"</span>,  arg.__buf-&gt;semmap);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of semaphore identifiers is %d \n"</span>,    arg.__buf-&gt;semmni);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"mas number of semaphores in system is %d \n"</span>,   arg.__buf-&gt;semmns);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the number of undo structures system wide is %d \n"</span>,  arg.__buf-&gt;semmnu);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of semaphores per semid is %d \n"</span>,   arg.__buf-&gt;semmsl);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of ops per semop call is %d \n"</span>,  arg.__buf-&gt;semopm);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"max number of undo entries per process is %d \n"</span>,  arg.__buf-&gt;semume);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the sizeof of struct sem_undo is %d \n"</span>,  arg.__buf-&gt;semusz);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the maximum semaphore value is %d \n"</span>,  arg.__buf-&gt;semvmx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//now ask for available resource:  </span></span><br><span class="line">  askfor_res.sem_num=<span class="number">0</span>;</span><br><span class="line">  askfor_res.sem_op=-<span class="number">1</span>;</span><br><span class="line">  askfor_res.sem_flg=SEM_UNDO;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(semid,&amp;askfor_res,<span class="number">1</span>)==-<span class="number">1</span>)<span class="comment">//ask for resource</span></span><br><span class="line">      perror(<span class="string">"semop error"</span>);</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//do some handling on the sharing resource here, just sleep on it 3 seconds</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"now free the resource\n"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//now free resource  </span></span><br><span class="line">  free_res.sem_num=<span class="number">0</span>;</span><br><span class="line">  free_res.sem_op=<span class="number">1</span>;</span><br><span class="line">  free_res.sem_flg=SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span>(semop(semid,&amp;free_res,<span class="number">1</span>)==-<span class="number">1</span>)<span class="comment">//free the resource.</span></span><br><span class="line">    <span class="keyword">if</span>(errno==EIDRM)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"the semaphore set was removed\n"</span>);</span><br><span class="line"><span class="comment">//you can comment out the codes below to compile a different version:      </span></span><br><span class="line">  <span class="keyword">if</span>(semctl(semid, <span class="number">0</span>, IPC_RMID)==-<span class="number">1</span>)</span><br><span class="line">    perror(<span class="string">"semctl IPC_RMID"</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"remove sem ok\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：读者可以尝试一下注释掉初始化步骤，进程在运行时会出现何种情况（进程在申请资源时会睡眠），同时可以像程序结尾给出的注释那样，把该程序编译成两个不同版本。下面是本程序的运行结果（操作系统redhat8.0）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">owne<span class="string">r's uid is 0</span><br><span class="line">owner'</span>s gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">create<span class="string">r's uid is 0</span><br><span class="line">creater'</span>s gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">the number of entries <span class="keyword">in</span> semaphore map <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">max number of semaphore identifiers <span class="keyword">is</span> <span class="number">128</span></span><br><span class="line">mas number of semaphores <span class="keyword">in</span> system <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">the number of undo structures system wide <span class="keyword">is</span> <span class="number">32000</span></span><br><span class="line">max number of semaphores per semid <span class="keyword">is</span> <span class="number">250</span></span><br><span class="line">max number of ops per semop call <span class="keyword">is</span> <span class="number">32</span></span><br><span class="line">max number of undo entries per process <span class="keyword">is</span> <span class="number">32</span></span><br><span class="line">the sizeof of struct sem_undo <span class="keyword">is</span> <span class="number">20</span></span><br><span class="line">the maximum semaphore value <span class="keyword">is</span> <span class="number">32767</span></span><br><span class="line">now free the resource</span><br><span class="line">remove sem ok</span><br></pre></td></tr></table></figure></p>
<p>Summary：信号灯与其它进程间通信方式有所不同，它主要用于进程间同步。通常所说的系统V信号灯实际上是一个信号灯的集合，可用于多种共享资源的进程间同步。每个信号灯都有一个值，可以用来表示当前该信号灯代表的共享资源可用（available）数量，如果一个进程要申请共享资源，那么就从信号灯值中减去要申请的数目，如果当前没有足够的可用资源，进程可以睡眠等待，也可以立即返回。当进程要申请多种共享资源时，linux可以保证操作的原子性，即要么申请到所有的共享资源，要么放弃所有资源，这样能够保证多个进程不会造成互锁。Linux对信号灯有各种各样的限制，程序中给出了输出结果。另外，如果读者想对信号灯作进一步的理解，建议阅读sem.h源代码，该文件不长，但给出了信号灯相关的重要数据结构。</p>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part4/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/信号灯/" data-id="ciqklv21z002nroqy13onwsnn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-消息队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/消息队列/" class="article-date">
  <time datetime="2016-07-02T04:38:11.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/消息队列/">消息队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>消息队列（也叫做报文队列）能够克服早期unix通信机制的一些缺点。作为早期unix通信机制之一的信号能够传送的信息量有限，后来虽然POSIX 1003.1b在信号的实时性方面作了拓广，使得信号在传递信息量方面有了相当程度的改进，但是信号这种通信方式更像”即时”的通信方式，它要求接受信号的进程在某个时间范围内对信号做出反应，因此该信号最多在接受信号进程的生命周期内才有意义，信号所传递的信息是接近于随进程持续的概念（process-persistent），见 附录 1；管道及有名管道及有名管道则是典型的随进程持续IPC，并且，只能传送无格式的字节流无疑会给应用程序开发带来不便，另外，它的缓冲区大小也受到限制。</p>
<p>消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列是随内核持续的（参见 附录 1）。</p>
<p>目前主要有两种类型的消息队列：POSIX消息队列以及系统V消息队列，系统V消息队列目前被大量使用。考虑到程序的可移植性，新开发的应用程序应尽量使用POSIX消息队列。</p>
<p>在本系列专题的序（深刻理解Linux进程间通信（IPC））中，提到对于消息队列、信号灯、以及共享内存区来说，有两个实现版本：POSIX的以及系统V的。Linux内核（内核2.4.18）支持POSIX信号灯、POSIX共享内存区以及POSIX消息队列，但对于主流Linux发行版本之一redhad8.0（内核2.4.18），还没有提供对POSIX进程间通信API的支持，不过应该只是时间上的事。</p>
<p>因此，本文将主要介绍系统V消息队列及其相应API。 在没有声明的情况下，以下讨论中指的都是系统V消息队列。</p>
<h3 id="消息队列基本概念"><a href="#消息队列基本概念" class="headerlink" title="消息队列基本概念"></a>消息队列基本概念</h3><p>1、系统V消息队列是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构（struct ipc_ids msg_ids）位于内核中，系统中的所有消息队列都可以在结构msg_ids中找到访问入口。<br>2、消息队列就是一个消息的链表。每个消息队列都有一个队列头，用结构struct msg_queue来描述（参见 附录 2）。队列头中包含了该消息队列的大量信息，包括消息队列键值、用户ID、组ID、消息队列中消息数目等等，甚至记录了最近对消息队列读写进程的ID。读者可以访问这些信息，也可以设置其中的某些信息。<br>3、下图说明了内核与消息队列是怎样建立起联系的：<br> 其中：struct ipc_ids msg_ids是内核中记录消息队列的全局数据结构；struct msg_queue是每个消息队列的队列头。</p>
<p><img src="/pictures/Linux/进程间通信/共享内存-消息队列全局数据结构.png" alt=""></p>
<p>从上图可以看出，全局数据结构 struct ipc_ids msg_ids 可以访问到每个消息队列头的第一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的消息队列对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个消息队列。kern_ipc_perm结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kern_ipc_perm&#123;   <span class="comment">//内核中记录消息队列的全局数据结构msg_ids能够访问到该结构；</span></span><br><span class="line">            <span class="keyword">key_t</span>   key;    <span class="comment">//该键值则唯一对应一个消息队列</span></span><br><span class="line">            <span class="keyword">uid_t</span>   uid;</span><br><span class="line">            <span class="keyword">gid_t</span>   gid;</span><br><span class="line"><span class="keyword">uid_t</span>   cuid;</span><br><span class="line"><span class="keyword">gid_t</span>   cgid;</span><br><span class="line"><span class="keyword">mode_t</span>  mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作消息队列"><a href="#操作消息队列" class="headerlink" title="操作消息队列"></a>操作消息队列</h3><h5 id="对消息队列的操作无非有下面三种类型："><a href="#对消息队列的操作无非有下面三种类型：" class="headerlink" title="对消息队列的操作无非有下面三种类型："></a>对消息队列的操作无非有下面三种类型：</h5><p>1、 打开或创建消息队列<br> 消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，只需提供该消息队列的键值即可；</p>
<p>注：消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。</p>
<p>2、 读写操作<br>消息读写操作非常简单，对开发人员来说，每个消息都类似如下的数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msgbuf&#123;</span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mtype成员代表消息类型，从消息队列中读取消息的一个重要依据就是消息的类型；mtext是消息内容，当然长度不一定为1。因此，对于发送消息来说，首先预置一个msgbuf缓冲区并写入消息类型和内容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个msgbuf缓冲区，然后把消息读入该缓冲区即可。</p>
<p>3、 获得或设置消息队列属性：<br>消息队列的信息基本上都保存在消息队列头中，因此，可以分配一个类似于消息队列头的结构(struct msqid_ds，见 附录 2)，来返回消息队列的属性；同样可以设置该数据结构。 <img src="/pictures/Linux/进程间通信/共享内存-消息队列数据结构.png" alt=""></p>
<h3 id="消息队列API"><a href="#消息队列API" class="headerlink" title="消息队列API"></a>消息队列API</h3><h4 id="1、文件名到键值"><a href="#1、文件名到键值" class="headerlink" title="1、文件名到键值"></a>1、文件名到键值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="keyword">key_t</span> ftok (<span class="keyword">char</span>*pathname, <span class="keyword">char</span> proj)；</span><br></pre></td></tr></table></figure>
<p>它返回与路径pathname相对应的一个键值。该函数不直接对消息队列操作，但在调用ipc(MSGGET,…)或msgget()来获得消息队列描述字前，往往要调用该函数。典型的调用代码是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key=ftok(path_ptr, <span class="string">'a'</span>);</span><br><span class="line">    ipc_id=ipc(MSGGET, (<span class="keyword">int</span>)key, flags,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    …</span><br></pre></td></tr></table></figure></p>
<h4 id="2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面："><a href="#2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面：" class="headerlink" title="2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面："></a>2、linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）提供了一个统一的用户界面：</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ipc(unsigned <span class="keyword">int</span> <span class="built_in">call</span>, <span class="keyword">int</span> <span class="keyword">first</span>, <span class="keyword">int</span> second, <span class="keyword">int</span> third, void * <span class="keyword">ptr</span>, long fifth);</span><br><span class="line">第一个参数指明对IPC对象的操作方式，对消息队列而言共有四种操作：MSGSND、MSGRCV、MSGGET以及MSGCTL，分别代表向消息队列发送消息、从消息队列读取消息、打开或创建消息队列、控制消息队列；<span class="keyword">first</span>参数代表唯一的IPC对象；下面将介绍四种操作.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGGET, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgget( (key_t)<span class="keyword">first</span>，second)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGCTL, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth)</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgctl( <span class="keyword">first</span>，second, (struct msqid_ds*) <span class="keyword">ptr</span>)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGSND, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgsnd( <span class="keyword">first</span>, (struct msgbuf*)<span class="keyword">ptr</span>, second, third)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ipc( MSGRCV, intfirst, intsecond, intthird, void*<span class="keyword">ptr</span>, longfifth);</span><br><span class="line"> 与该操作对应的系统V调用为：<span class="keyword">int</span> msgrcv( <span class="keyword">first</span>，(struct msgbuf*)<span class="keyword">ptr</span>, second, fifth,third)，</span><br></pre></td></tr></table></figure>
<p>注：本人不主张采用系统调用ipc()，而更倾向于采用系统V或者POSIX进程间通信API。原因如下：</p>
<li>虽然该系统调用提供了统一的用户界面，但正是由于这个特性，它的参数几乎不能给出特定的实际意义（如以first、second来命名参数），在一定程度上造成开发不便。</li><br><li>正如ipc手册所说的：ipc()是linux所特有的，编写程序时应注意程序的移植性问题；</li><br><li>该系统调用的实现不过是把系统V IPC函数进行了封装，没有任何效率上的优势；</li><br><li>系统V在IPC方面的API数量不多，形式也较简洁。</li>

<h3 id="系统V消息队列API"><a href="#系统V消息队列API" class="headerlink" title="系统V消息队列API"></a>系统V消息队列API</h3><p>系统V消息队列API共有四个，使用时需要包括几个头文件：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="int-msgget-key-t-key-int-msgflg"><a href="#int-msgget-key-t-key-int-msgflg" class="headerlink" title="int msgget(key_t key, int msgflg)"></a>int msgget(key_t key, int msgflg)</h5><p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。</p>
<p>在以下两种情况下，该调用将创建一个新的消息队列：</p>
<li>如果没有消息队列与健值key相对应，并且msgflg中包含了IPC_CREAT标志位；</li><br><li>key参数为IPC_PRIVATE；</li>

<p>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果。</p>
<p>调用返回：成功返回消息队列描述字，否则返回-1。</p>
<p>注：参数key设置成常数IPC_PRIVATE并不意味着其他进程不能访问该消息队列，只意味着即将创建新的消息队列。</p>
<h5 id="int-msgrcv-int-msqid-struct-msgbuf-msgp-int-msgsz-long-msgtyp-int-msgflg"><a href="#int-msgrcv-int-msqid-struct-msgbuf-msgp-int-msgsz-long-msgtyp-int-msgflg" class="headerlink" title="int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);"></a>int msgrcv(int msqid, struct msgbuf *msgp, int msgsz, long msgtyp, int msgflg);</h5><p>该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中。</p>
<p>msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：</p>
<li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li><br><li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li><br><li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失。</li>

<p>msgrcv手册中详细给出了消息类型取不同值时(&gt;0; &lt;0; =0)，调用将返回消息队列中的哪个消息。</p>
<p>msgrcv()解除阻塞的条件有三个：</p>
<p>1.消息队列中有了满足条件的消息；<br>2.msqid代表的消息队列被删除；<br>3.调用msgrcv（）的进程被信号中断；</p>
<p>调用返回：成功返回读出消息的实际字节数，否则返回-1。</p>
<h5 id="int-msgsnd-int-msqid-struct-msgbuf-msgp-int-msgsz-int-msgflg"><a href="#int-msgsnd-int-msqid-struct-msgbuf-msgp-int-msgsz-int-msgflg" class="headerlink" title="int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);"></a>int msgsnd(int msqid, struct msgbuf *msgp, int msgsz, int msgflg);</h5><p>向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定。</p>
<p>对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p>
<p>  当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量；<br>  当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节。</p>
<p>msgsnd()解除阻塞的条件有三个：<br>1.不满足上述两个条件，即消息队列中有容纳该消息的空间；<br>2.msqid代表的消息队列被删除；<br>3.调用msgsnd（）的进程被信号中断；</p>
<p>调用返回：成功返回0，否则返回-1。</p>
<h5 id="int-msgctl-int-msqid-int-cmd-struct-msqid-ds-buf"><a href="#int-msgctl-int-msqid-int-cmd-struct-msqid-ds-buf" class="headerlink" title="int msgctl(int msqid, int cmd, struct msqid_ds *buf);"></a>int msgctl(int msqid, int cmd, struct msqid_ds *buf);</h5><p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID。</p>
<ol>
<li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li>
<li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员。</li>
<li>IPC_RMID：删除msqid标识的消息队列；</li>
</ol>
<p>调用返回：成功返回0，否则返回-1。</p>
<h3 id="消息队列的限制"><a href="#消息队列的限制" class="headerlink" title="消息队列的限制"></a>消息队列的限制</h3><p>每个消息队列的容量（所能容纳的字节数）都有限制，该值因系统不同而不同。在后面的应用实例中，输出了redhat 8.0的限制，结果参见 附录 3。</p>
<p>另一个限制是每个消息队列所能容纳的最大消息数：在redhad 8.0中，该限制是受消息队列容量制约的：消息个数要小于消息队列的容量（字节数）。</p>
<p>注：上述两个限制是针对每个消息队列而言的，系统对消息队列的限制还有系统范围内的最大消息队列个数，以及整个系统范围内的最大消息数。一般来说，实际开发过程中不会超过这个限制。</p>
<h3 id="消息队列应用实例"><a href="#消息队列应用实例" class="headerlink" title="消息队列应用实例"></a>消息队列应用实例</h3><p>消息队列应用相对较简单，下面实例基本上覆盖了对消息队列的所有操作，同时，程序输出结果有助于加深对前面所讲的某些规则及消息队列限制的理解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">struct</span> msqid_ds )</span></span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gflags,sflags,rflags;</span><br><span class="line"><span class="keyword">key_t</span> key;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line"><span class="keyword">struct</span> msgsbuf&#123;</span><br><span class="line">        <span class="keyword">int</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">    &#125;msg_sbuf;</span><br><span class="line"><span class="keyword">struct</span> msgmbuf</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">10</span>];</span><br><span class="line">    &#125;msg_rbuf;</span><br><span class="line"><span class="keyword">struct</span> msqid_ds msg_ginfo,msg_sinfo;</span><br><span class="line"><span class="keyword">char</span>* msgpath=<span class="string">"/unix/msgqueue"</span>;</span><br><span class="line">key=ftok(msgpath,<span class="string">'a'</span>);</span><br><span class="line">gflags=IPC_CREAT|IPC_EXCL;</span><br><span class="line">msgid=msgget(key,gflags|<span class="number">00666</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg create error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个消息队列后，输出消息队列缺省属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">sflags=IPC_NOWAIT;</span><br><span class="line">msg_sbuf.mtype=<span class="number">10</span>;</span><br><span class="line">msg_sbuf.mtext[<span class="number">0</span>]=<span class="string">'a'</span>;</span><br><span class="line">reval=msgsnd(msgid,&amp;msg_sbuf,<span class="keyword">sizeof</span>(msg_sbuf.mtext),sflags);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message send error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一个消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">rflags=IPC_NOWAIT|MSG_NOERROR;</span><br><span class="line">reval=msgrcv(msgid,&amp;msg_rbuf,<span class="number">4</span>,<span class="number">10</span>,rflags);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read msg error\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read from msg queue %d bytes\n"</span>,reval);</span><br><span class="line"><span class="comment">//从消息队列中读出消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">msg_sinfo.msg_perm.uid=<span class="number">8</span>;<span class="comment">//just a try</span></span><br><span class="line">msg_sinfo.msg_perm.gid=<span class="number">8</span>;<span class="comment">//</span></span><br><span class="line">msg_sinfo.msg_qbytes=<span class="number">16388</span>;</span><br><span class="line"><span class="comment">//此处验证超级用户可以更改消息队列的缺省msg_qbytes</span></span><br><span class="line"><span class="comment">//注意这里设置的值大于缺省值</span></span><br><span class="line">reval=msgctl(msgid,IPC_SET,&amp;msg_sinfo);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg set info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line"><span class="comment">//验证设置消息队列属性</span></span><br><span class="line">reval=msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//删除消息队列</span></span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlink msg queue error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span> msgid,<span class="keyword">struct</span> msqid_ds msg_info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">//只是为了后面输出时间的方便</span></span><br><span class="line">reval=msgctl(msgid,IPC_STAT,&amp;msg_info);</span><br><span class="line"><span class="keyword">if</span>(reval==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get msg info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"current number of bytes on queue is %d\n"</span>,msg_info.msg_cbytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number of messages in queue is %d\n"</span>,msg_info.msg_qnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max number of bytes on queue is %d\n"</span>,msg_info.msg_qbytes);</span><br><span class="line"><span class="comment">//每个消息队列的容量（字节数）都有限制MSGMNB，值的大小因系统而异。在创建新的消息队列时，//msg_qbytes的缺省值就是MSGMNB</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgsnd is %d\n"</span>,msg_info.msg_lspid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgrcv is %d\n"</span>,msg_info.msg_lrpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgsnd time is %s"</span>, ctime(&amp;(msg_info.msg_stime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgrcv time is %s"</span>, ctime(&amp;(msg_info.msg_rtime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last change time is %s"</span>, ctime(&amp;(msg_info.msg_ctime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg uid is %d\n"</span>,msg_info.msg_perm.uid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg gid is %d\n"</span>,msg_info.msg_perm.gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出结果见 附录 3。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>消息队列与管道以及有名管道相比，具有更大的灵活性，首先，它提供有格式字节流，有利于减少开发人员的工作量；其次，消息具有类型，在实际应用中，可作为优先级使用。这两点是管道以及有名管道所不能比的。同样，消息队列可以在几个进程间复用，而不管这几个进程是否具有亲缘关系，这一点与有名管道很相似；但消息队列是随内核持续的，与有名管道（随进程持续）相比，生命力更强，应用空间更大。</p>
<h4 id="附录-1：-在参考文献-1-中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义："><a href="#附录-1：-在参考文献-1-中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义：" class="headerlink" title="附录 1： 在参考文献[1]中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义："></a>附录 1： 在参考文献[1]中，给出了IPC随进程持续、随内核持续以及随文件系统持续的定义：</h4><ol>
<li>随进程持续：IPC一直存在到打开IPC对象的最后一个进程关闭该对象为止。如管道和有名管道；</li>
<li>随内核持续：IPC一直持续到内核重新自举或者显示删除该对象为止。如消息队列、信号灯以及共享内存等；</li>
<li>随文件系统持续：IPC一直持续到显示删除该对象为止。</li>
</ol>
<h4 id="附录-2："><a href="#附录-2：" class="headerlink" title="附录 2："></a>附录 2：</h4><p>结构msg_queue用来描述消息队列头，存在于系统空间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_queue &#123;</span><br><span class="line">    <span class="keyword">struct</span> kern_ipc_perm q_perm;</span><br><span class="line">    <span class="keyword">time_t</span> q_stime;         <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime;         <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime;         <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;     <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;       <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;     <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid;          <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid;          <span class="comment">/* last receive pid */</span></span><br><span class="line">    <span class="keyword">struct</span> list_head q_messages;</span><br><span class="line">    <span class="keyword">struct</span> list_head q_receivers;</span><br><span class="line">    <span class="keyword">struct</span> list_head q_senders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结构msqid_ds用来设置或返回消息队列的信息，存在于用户空间；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msqid_ds &#123;</span><br><span class="line">    <span class="keyword">struct</span> ipc_perm msg_perm;</span><br><span class="line">    <span class="keyword">struct</span> msg *msg_first;      <span class="comment">/* first message on queue,unused  */</span></span><br><span class="line">    <span class="keyword">struct</span> msg *msg_last;       <span class="comment">/* last message in queue,unused */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_stime;  <span class="comment">/* last msgsnd time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_rtime;  <span class="comment">/* last msgrcv time */</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span> msg_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_cbytes;  <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qnum;    <span class="comment">/* number of messages in queue */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> msg_qbytes;  <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lspid;   <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">    <span class="keyword">__kernel_ipc_pid_t</span> msg_lrpid;   <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看出上述两个结构很相似。</p>
<h4 id="附录-3：-消息队列实例输出结果："><a href="#附录-3：-消息队列实例输出结果：" class="headerlink" title="附录 3： 消息队列实例输出结果："></a>附录 3： 消息队列实例输出结果：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">current number of bytes on queue is 0</span><br><span class="line">number of messages in queue is 0</span><br><span class="line">max number of bytes on queue is 16384</span><br><span class="line">pid of last msgsnd is 0</span><br><span class="line">pid of last msgrcv is 0</span><br><span class="line">last msgsnd time is Thu Jan  1 08:00:00 1970</span><br><span class="line">last msgrcv time is Thu Jan  1 08:00:00 1970</span><br><span class="line">last <span class="operator"><span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">//上面刚刚创建一个新消息队列时的输出</span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16384</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">1970</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">read</span> <span class="keyword">from</span> msg queue <span class="number">1</span> <span class="keyword">bytes</span></span><br><span class="line">//实际读出的字节数</span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16384</span>   //每个消息队列最大容量（字节数）</span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">22</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">20</span> <span class="number">2002</span></span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">current</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">number</span> <span class="keyword">of</span> messages <span class="keyword">in</span> queue <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">bytes</span> <span class="keyword">on</span> queue <span class="keyword">is</span> <span class="number">16388</span>   //可看出超级用户可修改消息队列最大容量</span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgsnd <span class="keyword">is</span> <span class="number">2510</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">last</span> msgrcv <span class="keyword">is</span> <span class="number">2510</span>  //对操作消息队列进程的跟踪</span><br><span class="line"><span class="keyword">last</span> msgsnd <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">21</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> msgrcv <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">22</span> <span class="number">2002</span></span><br><span class="line"><span class="keyword">last</span> <span class="keyword">change</span> <span class="keyword">time</span> <span class="keyword">is</span> Sun <span class="built_in">Dec</span> <span class="number">29</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">23</span> <span class="number">2002</span>    //msgctl()调用对msg_ctime有影响</span><br><span class="line">msg uid <span class="keyword">is</span> <span class="number">8</span></span><br><span class="line">msg gid <span class="keyword">is</span> <span class="number">8</span></span></span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>UNIX网络编程第二卷：进程间通信，作者：W.Richard Stevens，译者：杨继张，清华大学出版社。对POSIX以及系统V消息队列都有阐述，对Linux环境下的程序开发有极大的启发意义</li>
</ol>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/消息队列/" data-id="ciqklv21a001eroqy37g2hfsa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-共享内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/共享内存/" class="article-date">
  <time datetime="2016-07-02T04:09:19.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/共享内存/">共享内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。linux发行版本如Redhat 8.0支持mmap()系统调用及系统V共享内存，但还没实现Posix共享内存，本文将主要介绍mmap()系统调用及系统V共享内存API的原理及应用。</p>
<h2 id="一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"><a href="#一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面" class="headerlink" title="一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面"></a>一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</h2><p>1、page cache及swap cache中页面的区分：一个被访问文件的物理页面都驻留在page cache或swap cache中，一个页面的所有信息由struct page来描述。struct page中有一个域为指针mapping ，它指向一个struct address_space类型结构。page cache或swap cache中的所有页面就是根据address_space结构以及一个偏移量来区分的。</p>
<p>2、文件与address_space结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个struct inode结构，其中的i_mapping域指向一个address_space结构。这样，一个文件就对应一个address_space结构，一个address_space与一个偏移量能够确定一个page cache 或swap cache中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。</p>
<p>3、进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。</p>
<p>4、对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。<br>注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新。</p>
<p>5、所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br> 注：一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区上。</p>
<p>上面涉及到了一些数据结构，围绕数据结构理解问题会容易一些。</p>
<h3 id="二、mmap-及其相关系统调用"><a href="#二、mmap-及其相关系统调用" class="headerlink" title="二、mmap()及其相关系统调用"></a>二、mmap()及其相关系统调用</h3><p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</p>
<p>注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
<h5 id="mmap-系统调用形式如下："><a href="#mmap-系统调用形式如下：" class="headerlink" title="mmap()系统调用形式如下："></a>mmap()系统调用形式如下：</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* mmap ( <span class="type">void</span> * <span class="keyword">addr</span> , size_t len , <span class="type">int</span> prot , <span class="type">int</span> flags , <span class="type">int</span> fd , off_t offset )</span><br></pre></td></tr></table></figure>
<p> 参数fd为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起。prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。flags由以下几个常值指定：MAP_SHARED , MAP_PRIVATE , MAP_FIXED，其中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。offset参数一般设为0，表示从文件头开始映射。参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。这里不再详细介绍mmap()的参数，读者可参考mmap()手册页获得进一步的信息。</p>
<h5 id="系统调用mmap-用于共享内存的两种方式："><a href="#系统调用mmap-用于共享内存的两种方式：" class="headerlink" title="系统调用mmap()用于共享内存的两种方式："></a>系统调用mmap()用于共享内存的两种方式：</h5><p> （1）使用普通文件提供的内存映射：适用于任何进程之间； 此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="built_in">name</span>, <span class="built_in">flag</span>, mode);</span><br><span class="line"> <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<p>ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，我们将在范例中进行具体说明。</p>
<p>（2）使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间； 由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。<br> 对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可，参见范例2。</p>
<h5 id="系统调用munmap"><a href="#系统调用munmap" class="headerlink" title="系统调用munmap()"></a>系统调用munmap()</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> munmap( <span class="type">void</span> * <span class="keyword">addr</span>, size_t len )</span><br></pre></td></tr></table></figure>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<h5 id="系统调用msync"><a href="#系统调用msync" class="headerlink" title="系统调用msync()"></a>系统调用msync()</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> msync ( <span class="type">void</span> * <span class="keyword">addr</span> , size_t len, <span class="type">int</span> flags)</span><br></pre></td></tr></table></figure>
<p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p>
<h3 id="三、mmap-范例"><a href="#三、mmap-范例" class="headerlink" title="三、mmap()范例"></a>三、mmap()范例</h3><p>下面将给出使用mmap()的两个范例：范例1给出两个进程通过映射普通文件实现共享内存通信；范例2给出父子进程通过匿名映射实现共享内存。系统调用mmap()有许多有趣的地方，下面是通过mmap（）映射普通文件实现进程间的通信的范例，我们通过该范例来说明mmap()实现共享内存的特点及注意事项。</p>
<h4 id="范例1：两个进程通过映射普通文件实现共享内存通信"><a href="#范例1：两个进程通过映射普通文件实现共享内存通信" class="headerlink" title="范例1：两个进程通过映射普通文件实现共享内存通信"></a>范例1：两个进程通过映射普通文件实现共享内存通信</h4><p>范例1包含两个子程序：map_normalfile1.c及map_normalfile2.c。编译两个程序，可执行文件分别为map_normalfile1及map_normalfile2。两个程序通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。map_normalfile2试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。map_normalfile1把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。</p>
<p>下面是两个程序代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------map_normalfile1.c-----------*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line"></span><br><span class="line">  fd=open(argv[<span class="number">1</span>],O_CREAT|O_RDWR|O_TRUNC,<span class="number">00777</span>);</span><br><span class="line">  lseek(fd,<span class="keyword">sizeof</span>(people)*<span class="number">5</span>-<span class="number">1</span>,SEEK_SET);</span><br><span class="line">  write(fd,<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  p_map = (people*) mmap( <span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">        MAP_SHARED,fd,<span class="number">0</span> );</span><br><span class="line">  close( fd );</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>( ( *(p_map+i) ).name, &amp;temp,<span class="number">2</span> );</span><br><span class="line">    ( *(p_map+i) ).age = <span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" initialize over \n "</span>)；</span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line">  munmap( p_map, <span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok \n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------map_normalfile2.c-----------*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)  <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  fd=open( argv[<span class="number">1</span>],O_CREAT|O_RDWR,<span class="number">00777</span> );</span><br><span class="line">  p_map = (people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"name: %s age %d;\n"</span>,(*(p_map+i)).name, (*(p_map+i)).age );</span><br><span class="line">  &#125;</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>map_normalfile1.c首先定义了一个people数据结构，（在这里采用数据结构的方式是因为，共享内存区的数据往往是有固定格式的，这由通信的各个进程决定，采用结构的方式有普遍代表性）。map_normfile1首先打开或创建一个文件，并把文件的长度设置为5个people结构大小。然后从mmap()的返回地址开始，设置了10个people结构。然后，进程睡眠10秒钟，等待其他进程映射同一个文件，最后解除映射。</p>
<p>map_normfile2.c只是简单的映射一个文件，并以people数据结构的格式从mmap()返回的地址处读取10个people结构，并输出读取的值，然后解除映射。</p>
<p>分别把两个程序编译成可执行文件map_normalfile1和map_normalfile2后，在一个终端上先运行./map_normalfile2 /tmp/test_shm，程序输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initialize <span class="keyword">over</span></span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>
<p>在map_normalfile1输出initialize over 之后，输出umap ok之前，在另一个终端上运行map_normalfile2 /tmp/test_shm，将会产生如下输出(为了节省空间，输出结果为稍作整理后的结果)：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>: g	age <span class="number">25</span>;	<span class="attribute">name</span>: h	age <span class="number">26</span>;	<span class="attribute">name</span>: I	age <span class="number">27</span>;	<span class="attribute">name</span>: j	age <span class="number">28</span>;	<span class="attribute">name</span>: k	age <span class="number">29</span>;</span><br></pre></td></tr></table></figure></p>
<p>在map_normalfile1 输出umap ok后，运行map_normalfile2则输出如下结果：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;	<span class="attribute">name</span>:	age <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="从程序的运行结果中可以得出的结论"><a href="#从程序的运行结果中可以得出的结论" class="headerlink" title="从程序的运行结果中可以得出的结论"></a>从程序的运行结果中可以得出的结论</h5><p>1、最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文件的大小；</p>
<p>2、可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不完全受限于文件大小。打开文件被截短为5个people结构大小，而在map_normalfile1中初始化了10个people数据结构，在恰当时候（map_normalfile1输出initialize over 之后，输出umap ok之前）调用map_normalfile2会发现map_normalfile2将输出全部10个people结构的值，后面将给出详细讨论。<br> 注：在linux中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从mmap()返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。</p>
<p>3、文件一旦被映射后，调用mmap()的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对mmap()返回地址空间的操作只在内存中有意义，只有在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件，所写内容仍然不能超过文件的大小。</p>
<h4 id="范例2：父子进程通过匿名映射实现共享内存"><a href="#范例2：父子进程通过匿名映射实现共享内存" class="headerlink" title="范例2：父子进程通过匿名映射实现共享内存"></a>范例2：父子进程通过匿名映射实现共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line">  p_map=(people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED|MAP_ANONYMOUS,-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child read: the %d people's age is %d\n"</span>,i+<span class="number">1</span>,(*(p_map+i)).age);</span><br><span class="line">    (*p_map).age = <span class="number">100</span>;</span><br><span class="line">    munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>); <span class="comment">//实际上，进程终止时，会自动解除映射。</span></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((*(p_map+i)).name, &amp;temp,<span class="number">2</span>);</span><br><span class="line">    (*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"parent read: the first people,s age is %d\n"</span>,(*p_map).age );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"umap\n"</span>);</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察程序的输出结果，体会父子进程匿名共享内存：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">1</span> people's age <span class="keyword">is</span> <span class="number">20</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">2</span> people's age <span class="keyword">is</span> <span class="number">21</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">3</span> people's age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">4</span> people's age <span class="keyword">is</span> <span class="number">23</span></span><br><span class="line">child <span class="command">read</span>: <span class="keyword">the</span> <span class="number">5</span> people's age <span class="keyword">is</span> <span class="number">24</span></span><br><span class="line">parent <span class="command">read</span>: <span class="keyword">the</span> <span class="keyword">first</span> people,s age <span class="keyword">is</span> <span class="number">100</span></span><br><span class="line">umap</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure></p>
<h3 id="四、对mmap-返回地址的访问"><a href="#四、对mmap-返回地址的访问" class="headerlink" title="四、对mmap()返回地址的访问"></a>四、对mmap()返回地址的访问</h3><p>前面对范例运行结构的讨论中已经提到，linux采用的是页式管理机制。对于用mmap()映射普通文件来说，进程会在自己的地址空间新增一块空间，空间大小由mmap()的len参数指定，注意，进程并不一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面个数决定了进程从mmap()返回的地址开始，能够有效访问的地址空间大小。超过这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如下图示说明：<br><img src="/pictures/Linux/进程间通信/共享内存-mmap地址映射.png" alt=""><br>注意：文件被映射部分而不是整个文件决定了进程能够访问的空间大小，另外，如果指定文件的偏移部分，一定要注意为页面大小的整数倍。下面是对进程映射地址空间的访问范例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd,i;</span><br><span class="line">	<span class="keyword">int</span> pagesize,offset;</span><br><span class="line">	people *p_map;</span><br><span class="line"></span><br><span class="line">	pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pagesize is %d\n"</span>,pagesize);</span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_CREAT|O_RDWR|O_TRUNC,<span class="number">00777</span>);</span><br><span class="line">	lseek(fd,pagesize*<span class="number">2</span>-<span class="number">100</span>,SEEK_SET);</span><br><span class="line">	write(fd,<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line">	offset = <span class="number">0</span>;	<span class="comment">//此处offset = 0编译成版本1；offset = pagesize编译成版本2</span></span><br><span class="line">	p_map = (people*)mmap(<span class="literal">NULL</span>,pagesize*<span class="number">3</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,offset);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i-<span class="number">2</span>)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d over\n"</span>,i);</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i-<span class="number">1</span>)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d edge over, now begin to access page %d\n"</span>,i, i+<span class="number">1</span>);</span><br><span class="line">		(*(p_map+pagesize/<span class="keyword">sizeof</span>(people)*i)).age = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"access page %d over\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如程序中所注释的那样，把程序编译成两个版本，两个版本主要体现在文件被映射部分的大小不同。文件的大小介于一个页面与两个页面之间（大小为：pagesize<em>2-99），版本1的被映射部分是整个文件，版本2的文件被映射部分是文件大小减去一个页面后的剩余部分，不到一个页面大小(大小为：pagesize-99)。程序中试图访问每一个页面边界，两个版本都试图在进程空间中映射pagesize</em>3的字节数。</p>
<h4 id="版本1的输出结果如下："><a href="#版本1的输出结果如下：" class="headerlink" title="版本1的输出结果如下："></a>版本1的输出结果如下：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pagesize is 4096</span><br><span class="line">access page 1 over</span><br><span class="line">access page 1 edge over, now <span class="operator"><span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">2</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> <span class="keyword">over</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> <span class="keyword">over</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">2</span> edge <span class="keyword">over</span>, <span class="keyword">now</span> <span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">3</span></span><br><span class="line">Bus <span class="keyword">error</span>		//被映射文件在进程空间中覆盖了两个页面，此时，进程试图访问第三个页面</span></span><br></pre></td></tr></table></figure>
<h4 id="版本2的输出结果如下："><a href="#版本2的输出结果如下：" class="headerlink" title="版本2的输出结果如下："></a>版本2的输出结果如下：</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pagesize <span class="keyword">is</span> <span class="number">4096</span></span><br><span class="line"><span class="keyword">access</span> page <span class="number">1</span> over</span><br><span class="line"><span class="keyword">access</span> page <span class="number">1</span> edge over, now <span class="keyword">begin</span> <span class="keyword">to</span> <span class="keyword">access</span> page <span class="number">2</span></span><br><span class="line"><span class="keyword">Bus</span> error		//被映射文件在进程空间中覆盖了一个页面，此时，进程试图访问第二个页面</span><br></pre></td></tr></table></figure>
<p>结论：采用系统调用mmap()实现进程间通信是很方便的，在应用层上接口非常简洁。内部实现机制区涉及到了linux存储管理以及文件系统等方面的内容，可以参考一下相关重要数据结构来加深理解。在本专题的后面部分，将介绍系统v共享内存的实现。</p>
<h3 id="系统V共享内存原理"><a href="#系统V共享内存原理" class="headerlink" title="系统V共享内存原理"></a>系统V共享内存原理</h3><p>系统调用mmap()通过映射一个普通文件实现共享内存。系统V则是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统shm中的一个文件（这是通过shmid_kernel结构联系起来的），后面还将阐述。<br>进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过shmget获得或创建一个IPC共享内存区域，并返回相应的标识符。内核在保证shmget获得或创建一个共享内存区，初始化该共享内存区相应的shmid_kernel结构注同时，还将在特殊文件系统shm中，创建并打开一个同名文件，并在内存中建立起该文件的相应dentry及inode结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用shmget完成的。</p>
<p>注：每一个共享内存区都有一个控制结构struct shmid_kernel，shmid_kernel是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁，定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> shmid_kernel <span class="comment">/* private to the kernel */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> kern_ipc_perm	shm_perm;</span><br><span class="line">	<span class="keyword">struct</span> file *		shm_file;</span><br><span class="line">	<span class="keyword">int</span>			id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_nattch;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_segsz;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_atim;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_dtim;</span><br><span class="line">	<span class="keyword">time_t</span>			shm_ctim;</span><br><span class="line">	<span class="keyword">pid_t</span>			shm_cprid;</span><br><span class="line">	<span class="keyword">pid_t</span>			shm_lprid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构中最重要的一个域应该是shm_file，它存储了将被映射文件的地址。每个共享内存区对象都对应特殊文件系统shm中的一个文件，一般情况下，特殊文件系统shm中的文件是不能用read()、write()等方法访问的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可直接采用访问内存的方式对其访问。</p>
<p>这里我们采用下图表给出与系统V共享内存相关数据结构：<br><img src="/pictures/Linux/进程间通信/共享内存-系统V相关数据结构.png" alt=""></p>
<p>正如消息队列和信号灯一样，内核通过数据结构struct ipc_ids shm_ids维护系统中的所有共享内存区域。上图中的shm_ids.entries变量指向一个ipc_id结构数组，而每个ipc_id结构数组中有个指向kern_ipc_perm结构的指针。到这里读者应该很熟悉了，对于系统V共享内存区来说，kern_ipc_perm的宿主是shmid_kernel结构，shmid_kernel是用来描述一个共享内存区域的，这样内核就能够控制系统中所有的共享区域。同时，在shmid_kernel结构的file类型指针shm_file指向文件系统shm中相应的文件，这样，共享内存区域就与shm文件系统中的文件对应起来。</p>
<p>在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用shmat()完成此项功能。由于在调用shmget()时，已经创建了文件系统shm中的一个同名文件与共享内存区域相对应，因此，调用shmat()的过程相当于映射文件系统shm中的同名文件过程，原理与mmap()大同小异。</p>
<h3 id="系统V共享内存API"><a href="#系统V共享内存API" class="headerlink" title="系统V共享内存API"></a>系统V共享内存API</h3><p>对于系统V共享内存，主要有以下几个API：shmget()、shmat()、shmdt()及shmctl()。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>shmget（）用来获得共享内存区域的ID，如果不存在指定的共享区域就创建相应的区域。shmat()把共享内存区域映射到调用进程的地址空间中去，这样，进程就可以方便地对共享区域进行访问操作。shmdt()调用用来解除进程对共享内存区域的映射。shmctl实现对共享内存区域的控制操作。这里我们不对这些系统调用作具体的介绍，读者可参考相应的手册页面，后面的范例中将给出它们的调用方法。</p>
<p>注：shmget的内部实现包含了许多重要的系统V共享内存机制；shmat在把共享内存区域映射到进程空间时，并不真正改变进程的页表。当进程第一次访问内存映射区域访问时，会因为没有物理页表的分配而导致一个缺页异常，然后内核再根据相应的存储管理机制为共享内存映射区域分配相应的页表。</p>
<h3 id="系统V共享内存限制"><a href="#系统V共享内存限制" class="headerlink" title="系统V共享内存限制"></a>系统V共享内存限制</h3><p>在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如一个共享内存区的最大字节数shmmax，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做。</p>
<h3 id="系统V共享内存范例"><a href="#系统V共享内存范例" class="headerlink" title="系统V共享内存范例"></a>系统V共享内存范例</h3><p>本部分将给出系统V共享内存API的使用方法，并对比分析系统V共享内存机制与mmap()映射普通文件实现共享内存之间的差异，首先给出两个进程通过系统V共享内存通信的范例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** testwrite.c *******/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> shm_id,i;</span><br><span class="line">	<span class="keyword">key_t</span> key;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	people *p_map;</span><br><span class="line">	<span class="keyword">char</span>* name = <span class="string">"/dev/shm/myshm2"</span>;</span><br><span class="line">	key = ftok(name,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key==-<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">	shm_id=shmget(key,<span class="number">4096</span>,IPC_CREAT);</span><br><span class="line">	<span class="keyword">if</span>(shm_id==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p_map=(people*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	temp=<span class="string">'a'</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp+=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>((*(p_map+i)).name,&amp;temp,<span class="number">1</span>);</span><br><span class="line">		(*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shmdt(p_map)==-<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">" detach error "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********** testread.c ************/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125; people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> shm_id,i;</span><br><span class="line">	<span class="keyword">key_t</span> key;</span><br><span class="line">	people *p_map;</span><br><span class="line">	<span class="keyword">char</span>* name = <span class="string">"/dev/shm/myshm2"</span>;</span><br><span class="line">	key = ftok(name,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(key == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">"ftok error"</span>);</span><br><span class="line">	shm_id = shmget(key,<span class="number">4096</span>,IPC_CREAT);</span><br><span class="line">	<span class="keyword">if</span>(shm_id == -<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"shmget error"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p_map = (people*)shmat(shm_id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"name:%s\n"</span>,(*(p_map+i)).name );</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"age %d\n"</span>,(*(p_map+i)).age );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shmdt(p_map) == -<span class="number">1</span>)</span><br><span class="line">		perror(<span class="string">" detach error "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testwrite.c创建一个系统V共享内存区，并在其中写入格式化数据；testread.c访问同一个系统V共享内存区，读出其中的格式化数据。分别把两个程序编译为testwrite及testread，先后执行./testwrite及./testread 则./testread输出结果如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>: b	age <span class="number">20</span>;	<span class="attribute">name</span>: c	age <span class="number">21</span>;	<span class="attribute">name</span>: d	age <span class="number">22</span>;	<span class="attribute">name</span>: e	age <span class="number">23</span>;	<span class="attribute">name</span>: f	age <span class="number">24</span>;</span><br><span class="line"><span class="attribute">name</span>: g	age <span class="number">25</span>;	<span class="attribute">name</span>: h	age <span class="number">26</span>;	<span class="attribute">name</span>: I	age <span class="number">27</span>;	<span class="attribute">name</span>: j	age <span class="number">28</span>;	<span class="attribute">name</span>: k	age <span class="number">29</span>;</span><br></pre></td></tr></table></figure></p>
<p>通过对试验结果分析，对比系统V与mmap()映射普通文件实现共享内存通信，可以得出如下结论：<br>1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。 注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。</p>
<p>2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。</p>
<p>3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。 注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。</p>
<p>共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统shm中的。通过shmget可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过shmat将这个内存区映射到本进程的虚拟地址空间。</p>
<p>本文转载自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/共享内存/" data-id="ciqklv21x002kroqy3igovv5r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-管道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/02/管道/" class="article-date">
  <time datetime="2016-07-02T02:33:05.000Z" itemprop="datePublished">2016-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/02/管道/">管道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="管道及有名管道"><a href="#管道及有名管道" class="headerlink" title="管道及有名管道"></a>管道及有名管道</h1><p>管道和有名管道是最早的进程间通信机制之一，管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<h2 id="管道概述及相关API应用"><a href="#管道概述及相关API应用" class="headerlink" title="管道概述及相关API应用"></a>管道概述及相关API应用</h2><h4 id="管道相关的关键概念"><a href="#管道相关的关键概念" class="headerlink" title="管道相关的关键概念"></a>管道相关的关键概念</h4><p>管道是Linux支持的最初Unix IPC形式之一，具有以下特点：</p>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><br><li>只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；</li><br><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li><br><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li>

<h4 id="管道的创建："><a href="#管道的创建：" class="headerlink" title="管道的创建："></a>管道的创建：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。</p>
<h4 id="管道的读写规则："><a href="#管道的读写规则：" class="headerlink" title="管道的读写规则："></a>管道的读写规则：</h4><p>管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的I/O函数都可以用于管道，如close、read、write等等。</p>
<p>从管道中读取数据：</p>
<li>如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0；</li><br><li>当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的数据字节数，如果请求的字节数目不大于PIPE_BUF，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。注：（PIPE_BUF在include/linux/limits.h中定义，不同的内核版本可能会有所不同。Posix.1要求PIPE_BUF至少为512字节，red hat 7.2中为4096）。</li>

<p>关于管道的读规则验证：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> readtest.c <span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	int pipe_fd[2];</span><br><span class="line">	pid_t pid;</span><br><span class="line">	char r_buf[100];</span><br><span class="line">	char w_buf[4];</span><br><span class="line">	char<span class="keyword">*</span> p_wbuf;</span><br><span class="line">	int r_num;</span><br><span class="line">	int cmd;</span><br><span class="line"></span><br><span class="line">	memset(r_buf,0,sizeof(r_buf));</span><br><span class="line">	memset(w_buf,0,sizeof(r_buf));</span><br><span class="line">	p_wbuf=w_buf;</span><br><span class="line">	if(pipe(pipe_fd)<span class="variable">&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf("pipe create error\n");</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if((pid=fork())==0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf("\n");</span><br><span class="line">		close(pipe_fd[1]);</span><br><span class="line">		sleep(3);//确保父进程关闭写端</span><br><span class="line">	    r_num=read(pipe_fd[0],r_buf,100);</span><br><span class="line">printf(	"read num is %d   the data read from the pipe is %d\n",r_num,atoi(r_buf));</span><br><span class="line"></span><br><span class="line">		close(pipe_fd[0]);</span><br><span class="line">		exit();</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;</span>0)</span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[0]);//read</span><br><span class="line">	strcpy(w_buf,<span class="string">"111"</span>);</span><br><span class="line">	if(write(pipe_fd[1],w_buf,4)!=-1)</span><br><span class="line">		printf(<span class="string">"parent write over\n"</span>);</span><br><span class="line">	close(pipe_fd[1]);//write</span><br><span class="line">		printf(<span class="string">"parent close fd[1] over\n"</span>);</span><br><span class="line">	sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> /<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> 程序输出结果：</span><br><span class="line"> <span class="keyword">*</span> parent write over</span><br><span class="line"> <span class="keyword">*</span> parent close fd[1] over</span><br><span class="line"> <span class="keyword">*</span> read num is 4   the data read from the pipe is 111</span><br><span class="line"> <span class="keyword">*</span> 附加结论：</span><br><span class="line"> <span class="keyword">*</span> 管道写端关闭后，写入的数据将一直存在，直到读出为止.</span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<p>向管道中写入数据：</p>
<li>向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。<br>注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。</li>

<p>对管道的写规则的验证1：写端对读端存在的依赖性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span>* w_buf;</span><br><span class="line">	<span class="keyword">int</span> writenum;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	sleep(<span class="number">1</span>);  <span class="comment">//等待子进程完成关闭读端的操作</span></span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);<span class="comment">//write</span></span><br><span class="line">	w_buf=<span class="string">"111"</span>;</span><br><span class="line">	<span class="keyword">if</span>((writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">4</span>))==-<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"write to pipe error\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the bytes write to pipe is %d \n"</span>, writenum);</span><br><span class="line"></span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则输出结果为： Broken pipe,原因就是该管道以及它的所有fork()产物的读端都已经被关闭。如果在父进程中保留读端，即在写完pipe后，再关闭父进程的读端，也会正常写入pipe，读者可自己验证一下该结论。因此，在向管道写入数据时，至少应该存在某一个进程，其中管道读端没有被关闭，否则就会出现上述错误（管道断裂,进程收到了SIGPIPE信号，默认动作是进程终止）</p>
<p>对管道的写规则的验证2：linux不保证写管道的原子性验证<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> writenum;</span><br><span class="line">	<span class="keyword">int</span> rnum;</span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		rnum=read(pipe_fd[<span class="number">0</span>],r_buf,<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"child: readnum is %d\n"</span>,rnum);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);<span class="comment">//write</span></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>((writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">1024</span>))==-<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"write to pipe error\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the bytes write to pipe is %d \n"</span>, writenum);</span><br><span class="line">	writenum=write(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">4096</span>);</span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">1000</span></span><br><span class="line">the bytes write to pipe <span class="number">120</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">the bytes write to pipe <span class="number">0</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>结论：</p>
<p>写入数目小于4096时写入是非原子的！<br>如果把父进程中的两次写入字节数都改为5000，则很容易得出下面结论：<br>写入管道的数据量大于4096字节时，缓冲区的空闲空间将被写入数据（补齐），直到写完所有数据为止，如果没有进程读数据，则一直阻塞。</p>
<h3 id="管道应用实例："><a href="#管道应用实例：" class="headerlink" title="管道应用实例："></a>管道应用实例：</h3><h4 id="实例一：用于shell"><a href="#实例一：用于shell" class="headerlink" title="实例一：用于shell"></a>实例一：用于shell</h4><p>管道可用于输入输出重定向，它将一个命令的输出直接定向到另一个命令的输入。比如，当在某个shell程序（Bourne shell或C shell等）键入who│wc -l后，相应shell程序将创建who以及wc两个进程和这两个进程间的管道。考虑下面的命令行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$kill -l 运行结果见 附一。</span><br><span class="line"></span><br><span class="line">$kill -l | grep SIGRTMIN 运行结果如下：</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>) SIGPWR	<span class="number">31</span>) SIGSYS	<span class="number">32</span>) SIGRTMIN	<span class="number">33</span>) SIGRTMIN+<span class="number">1</span></span><br><span class="line"><span class="number">34</span>) SIGRTMIN+<span class="number">2</span>	<span class="number">35</span>) SIGRTMIN+<span class="number">3</span>	<span class="number">36</span>) SIGRTMIN+<span class="number">4</span>	<span class="number">37</span>) SIGRTMIN+<span class="number">5</span></span><br><span class="line"><span class="number">38</span>) SIGRTMIN+<span class="number">6</span>	<span class="number">39</span>) SIGRTMIN+<span class="number">7</span>	<span class="number">40</span>) SIGRTMIN+<span class="number">8</span>	<span class="number">41</span>) SIGRTMIN+<span class="number">9</span></span><br><span class="line"><span class="number">42</span>) SIGRTMIN+<span class="number">10</span>	<span class="number">43</span>) SIGRTMIN+<span class="number">11</span>	<span class="number">44</span>) SIGRTMIN+<span class="number">12</span>	<span class="number">45</span>) SIGRTMIN+<span class="number">13</span></span><br><span class="line"><span class="number">46</span>) SIGRTMIN+<span class="number">14</span>	<span class="number">47</span>) SIGRTMIN+<span class="number">15</span>	<span class="number">48</span>) SIGRTMAX-<span class="number">15</span>	<span class="number">49</span>) SIGRTMAX-<span class="number">14</span></span><br></pre></td></tr></table></figure></p>
<h4 id="实例二：用于具有亲缘关系的进程间通信"><a href="#实例二：用于具有亲缘关系的进程间通信" class="headerlink" title="实例二：用于具有亲缘关系的进程间通信"></a>实例二：用于具有亲缘关系的进程间通信</h4><p>下面例子给出了管道的具体应用，父进程通过管道发送一些命令给子进程，子进程解析命令，并根据命令作相应处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span>** w_buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">int</span> childexit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	<span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">	<span class="comment">//子进程：解析从管道中获取的命令，并作相应的处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(!childexit)</span><br><span class="line">		&#123;</span><br><span class="line">			read(pipe_fd[<span class="number">0</span>],r_buf,<span class="number">4</span>);</span><br><span class="line">			cmd=atoi(r_buf);</span><br><span class="line">			<span class="keyword">if</span>(cmd==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: receive command from parent over\n now child process exit\n"</span>);</span><br><span class="line">				childexit=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		       <span class="keyword">else</span> <span class="keyword">if</span>(handle_cmd(cmd)!=<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">	<span class="comment">//parent: send commands to child</span></span><br><span class="line">	&#123;</span><br><span class="line">	close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">	w_buf[<span class="number">0</span>]=<span class="string">"003"</span>;</span><br><span class="line">	w_buf[<span class="number">1</span>]=<span class="string">"005"</span>;</span><br><span class="line">	w_buf[<span class="number">2</span>]=<span class="string">"777"</span>;</span><br><span class="line">	w_buf[<span class="number">3</span>]=<span class="string">"000"</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		write(pipe_fd[<span class="number">1</span>],w_buf[i],<span class="number">4</span>);</span><br><span class="line">	close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是子进程的命令处理函数（特定于应用）：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_cmd</span><span class="params">(<span class="keyword">int</span> cmd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((cmd&lt;<span class="number">0</span>)||(cmd&gt;<span class="number">256</span>))</span><br><span class="line"><span class="comment">//suppose child only support 256 commands</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child: invalid command \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: the cmd from parent is %d\n"</span>, cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h4><p>管道的主要局限性正体现在它的特点上：</p>
<li>只支持单向数据流；</li><br><li>只能用于具有亲缘关系的进程之间；</li><br><li>没有名字；</li><br><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><br><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>

<h2 id="有名管道概述及相关API应用"><a href="#有名管道概述及相关API应用" class="headerlink" title="有名管道概述及相关API应用"></a>有名管道概述及相关API应用</h2><h3 id="有名管道相关的关键概念"><a href="#有名管道相关的关键概念" class="headerlink" title="有名管道相关的关键概念"></a>有名管道相关的关键概念</h3><p>管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
<h3 id="有名管道的创建"><a href="#有名管道的创建" class="headerlink" title="有名管道的创建"></a>有名管道的创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_t mode)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数的第一个参数是一个普通的路径名，也就是创建后FIFO的名字。第二个参数与打开普通文件的open()函数中的mode 参数相同。 如果mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开FIFO的函数就可以了。一般文件的I/O函数都可以用于FIFO，如close、read、write等等。</p>
<h3 id="有名管道的打开规则"><a href="#有名管道的打开规则" class="headerlink" title="有名管道的打开规则"></a>有名管道的打开规则</h3><p>有名管道比管道多了一个打开操作：open。</p>
<p>FIFO的打开规则：</p>
<p>如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。</p>
<p>如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。</p>
<p>对打开规则的验证：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r_rd;</span><br><span class="line">	<span class="keyword">int</span> w_fd;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cannot create fifoserver\n"</span>);</span><br><span class="line">	handle_client(FIFO_SERVER);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_client</span><span class="params">(<span class="keyword">char</span>* arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret=w_open(arg);</span><br><span class="line"><span class="keyword">switch</span>(ret)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"open %s error\n"</span>,arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"no process has the fifo open for reading\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"something wrong with open the fifo except for ENXIO"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"open server ok\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"w_no_r return ----\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;		</span><br><span class="line">unlink(FIFO_SERVER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w_open</span><span class="params">(<span class="keyword">char</span>*arg)</span></span><br><span class="line"><span class="comment">//0  open error for no reading</span></span><br><span class="line"><span class="comment">//-1 open error for other reasons</span></span><br><span class="line"><span class="comment">//1  open ok</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(open(arg,O_WRONLY|O_NONBLOCK,<span class="number">0</span>)==-<span class="number">1</span>)</span><br><span class="line">	&#123;	<span class="keyword">if</span>(errno==ENXIO)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="有名管道的读写规则"><a href="#有名管道的读写规则" class="headerlink" title="有名管道的读写规则"></a>有名管道的读写规则</h3><p>从FIFO中读取数据：</p>
<p>约定：如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。</p>
<li>如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。</li><br><li>对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。</li><br><li>读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。</li><br><li>如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。</li>

<p>注：如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。</p>
<p>向FIFO中写入数据：</p>
<p>约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。</p>
<p>对于设置了阻塞标志的写操作：</p>
<li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。</li><br><li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。</li>

<p>对于没有设置阻塞标志的写操作：</p>
<li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。</li><br><li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；</li>

<p>对FIFO读写规则的验证：</p>
<p>下面提供了两个对FIFO的读写程序，适当调节程序中的很少地方或者程序的命令行参数就可以对各种FIFO读写规则进行验证。</p>
<h5 id="程序1：写FIFO的程序"><a href="#程序1：写FIFO的程序" class="headerlink" title="程序1：写FIFO的程序"></a>程序1：写FIFO的程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line"><span class="comment">//参数为即将写入的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> real_wnum;</span><br><span class="line">	<span class="built_in">memset</span>(w_buf,<span class="number">0</span>,<span class="number">4096</span>*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cannot create fifoserver\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(errno==ENXIO)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"open error; no reading process\n"</span>);</span><br><span class="line"></span><br><span class="line">     	fd=open(FIFO_SERVER,O_WRONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置非阻塞标志</span></span><br><span class="line">	<span class="comment">//fd=open(FIFO_SERVER,O_WRONLY,0);</span></span><br><span class="line">	<span class="comment">//设置阻塞标志</span></span><br><span class="line">	real_wnum=write(fd,w_buf,<span class="number">2048</span>);</span><br><span class="line">	<span class="keyword">if</span>(real_wnum==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"write to fifo error; try later\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"real write num is %d\n"</span>,real_wnum);</span><br><span class="line">	real_wnum=write(fd,w_buf,<span class="number">5000</span>);</span><br><span class="line">	<span class="comment">//5000用于测试写入字节大于4096时的非原子性</span></span><br><span class="line">	<span class="comment">//real_wnum=write(fd,w_buf,4096);</span></span><br><span class="line">	<span class="comment">//4096用于测试写入字节不大于4096时的原子性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(real_wnum==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"try later\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数"><a href="#程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数" class="headerlink" title="程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数"></a>程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FIFO_SERVER <span class="string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> r_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span>  fd;</span><br><span class="line">	<span class="keyword">int</span>  r_size;</span><br><span class="line">	<span class="keyword">int</span>  ret_size;</span><br><span class="line">	r_size=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"requred real read bytes %d\n"</span>,r_size);</span><br><span class="line">	<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">	fd=open(FIFO_SERVER,O_RDONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//fd=open(FIFO_SERVER,O_RDONLY,0);</span></span><br><span class="line">	<span class="comment">//在此处可以把读程序编译成两个不同版本：阻塞版本及非阻塞版本</span></span><br><span class="line">	<span class="keyword">if</span>(fd==-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"open %s for read error\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">		ret_size=read(fd,r_buf,r_size);</span><br><span class="line">		<span class="keyword">if</span>(ret_size==-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"no data avlaible\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"real read bytes %d\n"</span>,ret_size);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pause();</span><br><span class="line">	unlink(FIFO_SERVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序应用说明：</p>
<p>把读程序编译成两个不同版本：</p>
<li>阻塞读版本:br</li><br><li>以及非阻塞读版本nbr</li>

<p>把写程序编译成两个四个版本：</p>
<li>非阻塞且请求写的字节数大于PIPE_BUF版本：nbwg</li><br><li>非阻塞且请求写的字节数不大于PIPE_BUF版本：版本nbw</li><br><li>阻塞且请求写的字节数大于PIPE_BUF版本：bwg</li><br><li>阻塞且请求写的字节数不大于PIPE_BUF版本：版本bw</li>


<p>下面将使用br、nbr、w代替相应程序中的阻塞读、非阻塞读</p>
<p>验证阻塞写操作：<br>1.当请求写入的数据量大于PIPE_BUF时的非原子性：<br>      nbr 1000<br>      bwg</p>
<p>2.当请求写入的数据量不大于PIPE_BUF时的原子性：<br>      nbr 1000<br>      bw</p>
<p>验证非阻塞写操作：<br>1.当请求写入的数据量大于PIPE_BUF时的非原子性：<br>      nbr 1000<br>      nbwg</p>
<p>2.请求写入的数据量不大于PIPE_BUF时的原子性：<br>      nbr 1000<br>      nbw</p>
<p>不管写打开的阻塞标志是否设置，在请求写入的字节数大于4096时，都不保证写入的原子性。但二者有本质区别：</p>
<p>对于阻塞写来说，写操作在写满FIFO的空闲区域后，会一直等待，直到写完所有数据为止，请求写入的数据最终都会写入FIFO；</p>
<p>而非阻塞写则在写满FIFO的空闲区域后，就返回(实际写入的字节数)，所以有些数据最终不能够写入。</p>
<p>对于读操作的验证则比较简单，不再讨论。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>管道常用于两个方面：<br>（1）在shell中时常会用到管道（作为输入输入的重定向），在这种应用方式下，管道的创建对于用户来说是透明的；<br>（2）用于具有亲缘关系的进程间通信，用户自己创建管道，并完成读写操作。</p>
<p>FIFO可以说是管道的推广，克服了管道无名字的限制，使得无亲缘关系的进程同样可以采用先进先出的通信机制进行通信。</p>
<p>管道和FIFO的数据是字节流，应用程序之间必须事先确定特定的传输”协议”，采用传播具有特定意义的消息。</p>
<p>要灵活应用管道及FIFO，理解它们的读写规则是关键。</p>
<p>以上内容转自<a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part1/index.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/07/02/管道/" data-id="ciqklv210000wroqyq136v459" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP-Nagel算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/TCP-Nagel算法/" class="article-date">
  <time datetime="2016-05-10T06:24:13.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/TCP-Nagel算法/"> TCP Nagel算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>Nagel算法</li>
</ol>
<p>TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p>
  <font color="blue">Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。</font>

<p>Nagle算法的规则（可参考tcp_output.c文件里tcp_nagle_check函数注释）：</p>
<pre><code>（1）如果包长度达到MSS，则允许发送；

（2）如果该包含有FIN，则允许发送；

（3）设置了TCP_NODELAY选项，则允许发送；

（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
</code></pre><p>Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低。</p>
<p>Nagle算法是silly window syndrome(SWS)预防算法的一个半集。SWS算法预防发送少量的数据，Nagle算法是其在发送方的实现，而接收方要做的时不要通告缓冲空间的很小增长，不通知小窗口，除非缓冲区空间有显著的增长。这里显著的增长定义为完全大小的段（MSS）或增长到大于最大窗口的一半。</p>
<font color="red">注意：BSD的实现是允许在空闲链接上发送大的写操作剩下的最后的小段，也就是说，当超过1个MSS数据发送时，内核先依次发送完n个MSS的数据包，然后再发送尾部的小数据包，其间不再延时等待。（假设网络不阻塞且接收窗口足够大）</font>


<p>举个例子，比如之前的blog中的实验，一开始client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\r\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。</p>
<p>这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个TCP确认延迟机制 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么’\r\n’（B块）总是在A块之后40ms才发出。<br>当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。</p>
<h4 id="TCP-NODELAY-选项"><a href="#TCP-NODELAY-选项" class="headerlink" title="TCP_NODELAY 选项"></a>TCP_NODELAY 选项</h4><p>默认情况下，发送数据采用Negale 算法。这样虽然提高了网络吞吐量，但是实时性却降低了，在一些交互性很强的应用程序来说是不允许的，使用TCP_NODELAY选项可以禁止Negale 算法。</p>
<p>此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了Negale 算法，但网络的传输仍然受到TCP确认延迟机制的影响。</p>
<h4 id="TCP-CORK-选项"><a href="#TCP-CORK-选项" class="headerlink" title="TCP_CORK 选项"></a>TCP_CORK 选项</h4><p>所谓的CORK就是塞子的意思，形象地理解就是用CORK将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽力把小数据包拼接成一个大的数据包（一个MTU）再发送出去，当然若一定时间后（一般为200ms，该值尚待确认），内核仍然没有组合成一个MTU时也必须发送现有的数据（不可能让数据一直等待吧）。</p>
<p>然而，TCP_CORK的实现可能并不像你想象的那么完美，CORK并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到MTU的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包（努力接近MTU）的话，内核就会无条件发送。也就是说若应用层程序发送小包数据的间隔不够短时，TCP_CORK就没有一点作用，反而失去了数据的实时性（每个小包数据都会延时一定时间再发送）。</p>
<h4 id="Nagle算法与CORK算法区别"><a href="#Nagle算法与CORK算法区别" class="headerlink" title="Nagle算法与CORK算法区别"></a>Nagle算法与CORK算法区别</h4><p>Nagle算法和CORK算法非常类似，但是它们的着眼点不一样，Nagle算法主要避免网络因为太多的小包（协议头的比例非常之大）而拥塞，而CORK算法则是为了提高网络的利用率，使得总体上协议头占用的比例尽可能的小。如此看来这二者在避免发送小包上是一致的，在用户控制的层面上，Nagle算法完全不受用户socket的控制，你只能简单的设置TCP_NODELAY而禁用它，CORK算法同样也是通过设置或者清除TCP_CORK使能或者禁用之，然而Nagle算法关心的是网络拥塞问题，只要所有的ACK回来则发包，而CORK算法却可以关心内容，在前后数据包发送间隔很短的前提下（很重要，否则内核会帮你将分散的包发出），即使你是分散发送多个小数据包，你也可以通过使能CORK算法将这些内容拼接在一个包内，如果此时用Nagle算法的话，则可能做不到这一点。</p>
<p>以上内容转自<a href="http://blog.163.com/li_xiang1102/blog/static/607140762011111103213616/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/05/10/TCP-Nagel算法/" data-id="ciqklv23j003qroqyfdhqr0eu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-连续发送多份小数据时40ms延迟问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/10/连续发送多份小数据时40ms延迟问题/" class="article-date">
  <time datetime="2016-05-10T06:15:32.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/连续发送多份小数据时40ms延迟问题/">连续发送多份小数据时40ms延迟问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="连续发送多份小数据时40ms延迟问题"><a href="#连续发送多份小数据时40ms延迟问题" class="headerlink" title="连续发送多份小数据时40ms延迟问题"></a>连续发送多份小数据时40ms延迟问题</h2><h3 id="以及TCP-NODELAY、TCP-CORK失效问题的定位与解决"><a href="#以及TCP-NODELAY、TCP-CORK失效问题的定位与解决" class="headerlink" title="以及TCP_NODELAY、TCP_CORK失效问题的定位与解决"></a>以及TCP_NODELAY、TCP_CORK失效问题的定位与解决</h3><p>提到TCP_NODELAY和TCP_CORK，相信很多人都很熟悉。然而由于Linux实现上的问题，这两个参数在实际使用中，并不像书里介绍的那么简单。最近DTS在解决一个TCP超时问题时，对这两个参数和它们背后所隐藏的问题有了比较深刻的认识，在此与同学们分享一下我们的经验和教训。</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>和许多经典的分布式程序类似，DTS使用TCP长连接用于client和server的数据交互：client发送请求给server，然后等待server回应。有时候出于数据结构上的考虑，client需要先连续发送多份数据，再等待server的回应。测试发现这种情况下，server端有时会出现接收数据延迟。比如说某个case里，client会先发送275个字节，接着发送24个字节，然后再发送292字节数据等等；此时如果该TCP连接被复用过，则server端在收取24字节这批数据时会很容易出现40ms延迟。</p>
<p>由于client每次发送的数据都很小，很自然想到是nagle算法延迟了client端的数据发送，于是在client端和server端都设置了TCP_NODELAY。然而测试发现，此时server虽然顺利接受了24字节数据，却在接受随后292字节数据时依然出现了40ms延迟。难道是数据太多导致TCP_NODELAY失效？因此又在client端添加了TCP_CORK选项：即如果client需要连续发送多次数据，则先关闭TCP_NODELAY，打开TCP_CORK；所有数据write完后，再关闭TCP_CORK，打开TCP_NODELAY。按照设想，client应该会把所有数据打包在一起发送，但测试结果依然和以前一样，server还是在收取第三份数据时出现了40ms的延迟。</p>
<h4 id="不得已使用tcpdump进行分析，结果如下："><a href="#不得已使用tcpdump进行分析，结果如下：" class="headerlink" title="不得已使用tcpdump进行分析，结果如下："></a>不得已使用tcpdump进行分析，结果如下：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.640134</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 551<span class="pseudo">:826(275)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499424 1712127318&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.640151</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 826<span class="pseudo">:850(24)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499424 1712127318&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.680812</span> <span class="tag">IP</span> <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span> &gt; <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span>: . <span class="tag">ack</span> 850 <span class="tag">win</span> 2252 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 1712127359 2551499424&gt;</span><br><span class="line">18<span class="pseudo">:18</span><span class="pseudo">:01</span><span class="class">.680818</span> <span class="tag">IP</span> <span class="tag">jx-dp-wk11</span><span class="class">.jx</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.36989</span> &gt; <span class="tag">tc-dpf-rd-in</span><span class="class">.tc</span><span class="class">.baidu</span><span class="class">.com</span><span class="class">.licensedaemon</span>: <span class="tag">P</span> 850<span class="pseudo">:1142(292)</span> <span class="tag">ack</span> 141 <span class="tag">win</span> 1460 &lt;<span class="tag">nop</span>,<span class="tag">nop</span>,<span class="tag">timestamp</span> 2551499465 1712127359&gt;</span><br></pre></td></tr></table></figure>
<p>注意红色的部分，可见client并没有将所有数据打成一个包，每次write的数据还是作为单独的包发送；此外，client在发送完24字节的数据后，一直等到server告知ack才接着发送剩下的292字节。由于server延迟了40ms才告知ack，因此导致了其接收292字节数据时也出现了40ms延迟。</p>
<p>既然查出了延迟是server端delayed ack的原因，通过设置server端TCP_QUICKACK，40ms延迟的问题得到了解决。</p>
<h4 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h4><p>虽然DTS的延时问题暂时得到了解决，但其内在原因却使人百思不得其解：为什么TCP_NODELAY会失效？为什么TCP_CORK无作为？…… 在STL同学的帮助下，我们逐渐对这些困惑有了答案。</p>
<p>首先介绍下delayed ack算法：当协议栈接受到TCP数据时，并不一定会立刻发送ACK响应，而是倾向于等待一个超时或者满足特殊条件时再发送。对于Linux实现，这些特殊条件如下：</p>
<p>1）收到的数据已经超过了full frame size</p>
<p>2）或者处于快速回复模式</p>
<p>3）或者出现了乱序的包</p>
<p>4）或者接收窗口的数据足够多</p>
<p>如果接收方有数据回写，则ACK也会搭车一起发送。当以上条件都不满足时，接收方会延迟40ms再回应ACK。</p>
<h4 id="1-为什么TCP-NODELAY失效"><a href="#1-为什么TCP-NODELAY失效" class="headerlink" title="1.为什么TCP_NODELAY失效"></a>1.为什么TCP_NODELAY失效</h4><p>UNIX网络编程这本书介绍说，TCP_NODELAY同时禁止了nagle算法和delayed ACK算法，因此小块数据可以直接发送。然而Linux实现中，TCP_NODELAY只禁止了nagle算法。另一方面，协议栈在发送包的时候，不仅受到TCP_NODELAY的影响，还受到协议栈里面拥塞窗口的影响。由于server端delayed ack，client迟迟无法收到ack应答，拥塞窗口堵满，从而无法继续发送更多数据；一直到40ms后ack达到，才能继续发送（题外话： TCP_NODELAY在FREEBSD上性能优于Linux上，因为FREEBSD并不像Linux一样需要第一个包到达后就响应ACK）。</p>
<p>这也解释了为什么延时现象在重用过的TCP连接上特别容易出现：目前使用的52bs内核中，连接刚建立时拥塞窗口默认是3，因此可以发送3个数据包，而后拥塞窗口变为2，就会导致第3个292字节的包发不出去。</p>
<h4 id="2-为什么TCP-CORK失效"><a href="#2-为什么TCP-CORK失效" class="headerlink" title="2.为什么TCP_CORK失效"></a>2.为什么TCP_CORK失效</h4><p>TCP_CORK会将发送端多份数据打成一个包，待到TCP_CORK关闭后一起发送。Linux Man手册上也描述了TCP_CORK选项和TCP_NODELAY一起使用的情形。然而根据之前tcpdump的结果，client端设置TCP_CORK后并没有发挥效果。继续测试发现，只要设置过TCP_NODELAY选项，即使随后关闭也会导致TCP_CORK无效；如果从未设置过TCP_NODELAY，则TCP_CORK可以产生效果。</p>
<p>根据STL同学对协议栈代码的调研，发现这个是Linux实现上的问题。在内核中，设置启动TCP_NODELAY选项后，内核会为socket增加两个标志位TCP_NAGLE_OFF和TCP_NAGLE_PUSH，关闭TCP_NODELAY的时候，内核只去掉了TCP_NAGLE_OFF标志位。而在发包的时候判断的却恰恰是TCP_NAGLE_PUSH标志位，如果该位置位设置，就直接把包发出去，从而导致TCP_CORK发挥不了作用。这很可能是这一版本Linux内核实现上的bug。</p>
<h4 id="3-TCP-QUICKACK的作用和限制"><a href="#3-TCP-QUICKACK的作用和限制" class="headerlink" title="3.TCP_QUICKACK的作用和限制"></a>3.TCP_QUICKACK的作用和限制</h4><p>前面介绍delayed ack算法时，讲到协议栈迅速回复ack的情形之一就是进入到快速回复模式。而TCP_QUICKACK选项就是向内核建议进入快速回复模式。快速回复ack模式的判断条件如下：(tp-&gt;ack.quick &amp;&amp; tp-&gt;ack.pingpong)，其中设置QUICKACK选项会置pingpong=0。</p>
<p>然而，随着TCP连接的重用和数据的不断收发，快速回复模式有可能失效。例如在后续的交互过程当中，pingpong变为1的条件就有：1.收到fin后；2. 发送方发送数据时，发现当前时间与上次接收数据的时间小于40ms。此外，发送方发现数据包带有ack标志位时，也会减小ack.quick值。这些都会导致快速回复模式的退出。因此，即使每次接受数据前都设置TCP_QUICKACK选项，也不能完全解决delayed ack问题。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>经过上述的测试与分析，可以认识到当连续发送多个小数据时，TCP_NODELAY作用并不明显，TCP_CORK无法像宣传的那样和TCP_NODELAY混合使用，而TCP_QUICKACK也不能完全解决问题。因此，我们最终的解决方案如下：</p>
<p>（1）在client端多次发送数据时，先打开TCP_CORK选项，发送完后再关闭TCP_CORK，将多份小数据打成一个包发送；此外，client端不能设置TCP_NODELAY选项，以避免TCP_CORK失效。</p>
<p>（2）server端开启TCP_QUICKACK选项，尽量快速回复ack。</p>
<p>通过这个延时问题的解决，可以看到由于Linux实现策略上的问题，TCP_NODELAY和TCP_CORK还是暗藏了不少陷阱。实际应用中，其实也可以绕过这些参数，在应用层将多份数据序列化到一个buffer中，或者使用writev系列函数。然而，这些方法需要额外的内存拷贝，或者让传输对象对外暴露过多的数据结构信息，并不一定容易实现，也会添加代码重构的代价。</p>
<p>另一方面，考虑到那些使用TCP进行异步请求的应用，由于多个请求需要同时复用一个TCP连接，也很容易出现延时问题；而无论是通过TCP_CORK还是writev哪种方法，都不太适合这种异步场景。最近STL推出的新内核添加了一个禁止delayed ack的系统参数，使用该参数理论上讲可以彻底根除40ms的延迟问题。</p>
<p>以上内容转自<a href="http://www.cnblogs.com/tangr206/articles/3284203.html" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/05/10/连续发送多份小数据时40ms延迟问题/" data-id="ciqklv20p000froqyqskbdkl6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ICMP-协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/ICMP-协议/" class="article-date">
  <time datetime="2016-04-26T12:05:10.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/ICMP-协议/">ICMP 协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ICMP 经常被认为是 IP 层的一个组成部分，它传递差错报文以及其他需要注意的信息。ICMP 报文通常被 IP 层或更高层协议(TCP 或 UDP)使用。ICMP 报文是在 IP 数据报内部传输的。IP 协议是不可靠协议，不能保证 IP 数据报能够成功的到达目的主机，无法进行差错控制，而 ICMP 协议能够协助 IP 协议完成这些功能。下面是 ICMP 报文的数据结构：</p>
<p>类型：一个 8 位类型字段，表示 ICMP 数据包类型;</p>
<p>代码：一个 8 位代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0;</p>
<p>检验和：数据包中 ICMP 部分上的一个 16 位检验和;</p>
<p><img src="/pictures/计算机网络/ICMP协议/ICMP报文格式.png" alt=""></p>
<p>以下针对 ICMP 差错报文的类型进行分析：</p>
<p>1、ICMP 目标不可达消息：IP 路由器无法将 IP 数据报发送给目的地址时，会给发送端主机返回一个目标不可达 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>2、ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。</p>
<p>3、ICMP 超时消息：IP 数据包中有一个字段 TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减 1，直到减到 0 时该 IP 数据包被丢弃。此时，IP 路由器将发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>4、源抑制消息：当 TCP/IP 主机发送数据到另一主机时，如果速度达到路由器或者链路的饱和状态，路由器发出一个 ICMP 源抑制消息。</p>
<h4 id="ICMP-查询报文"><a href="#ICMP-查询报文" class="headerlink" title="ICMP 查询报文"></a>ICMP 查询报文</h4><p>ICMP 回送消息：用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。</p>
<p>ICMP 地址掩码消息：主要用于主机或路由想要了解子网掩码的情况。可以向那些主机或路由器发送 ICMP 地址掩码请求消息，然后通过接收 ICMP 地址掩码应答消息获取子网掩码信息。</p>
<p>ICMP 时间戳消息：可以向那些主机或路由器发送 ICMP 时间戳请求消息，然后通过接收 ICMP 时间戳应答消息获取时间信息。</p>
<h4 id="Ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序"></a>Ping 程序</h4><p>Ping 程序利用 ICMP 回显请求报文和回显应答报文(而不用经过传输层)来测试目标主机是否可达。它是一个检查系统连接性的基本诊断工具。</p>
<p>ICMP 回显请求和 ICMP 回显应答报文是配合工作的。当源主机向目标主机发送了 ICMP 回显请求数据包后，它期待着目标主机的回答。目标主机在收到一个 ICMP 回显请求数据包后，它会交换源、目的主机的地址，然后将收到的 ICMP 回显请求数据包中的数据部分原封不动地封装在自己的 ICMP 回显应答数据包中，然后发回给发送 ICMP 回显请求的一方。如果校验正确，发送者便认为目标主机的回显服务正常，也即物理连接畅通。</p>
<h4 id="Traceroute-程序"><a href="#Traceroute-程序" class="headerlink" title="Traceroute 程序"></a>Traceroute 程序</h4><p>Traceroute 程序主要用来侦测源主机到目的主机之间所经过的路由的情况。</p>
<p>Traceroute 使用 ICMP 报文和 IP 首部中的 TTL 字段，它充分利用了 ICMP 超时消息。其原理很简单，开始时发送一个 TTL 字段为 1 的 UDP 数据报，而后每次收到 ICMP 超时萧后，按顺序再发送一个 TTL 字段加 1 的 UDP 数据报，以确定路径中的每个路由器，而每个路由器在丢弃 UDP 数据报时都会返回一个 ICMP 超时报文，而最终到达目的主机后，由于 ICM P选择了一个不可能的值作为 UDP 端口(大于30000)。这样目的主机就会发送一个端口不可达的 ICMP 差错报文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/ICMP-协议/" data-id="ciqklv24o005sroqyzh19auv5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DDOS攻击简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/DDOS攻击简介/" class="article-date">
  <time datetime="2016-04-26T08:34:37.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/DDOS攻击简介/">DDOS攻击简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DDOs攻击主要有两种类型：流量攻击和占用服务器资源攻击</p>
<p>针对于TCP/IP协议的不同，ddos可以利用好几个协议的漏洞进行攻击。</p>
<h2 id="基于TCP协议的攻击"><a href="#基于TCP协议的攻击" class="headerlink" title="基于TCP协议的攻击"></a>基于TCP协议的攻击</h2><h4 id="SYN-Flood-攻击"><a href="#SYN-Flood-攻击" class="headerlink" title="SYN Flood 攻击"></a>SYN Flood 攻击</h4><p>基于TCP协议的攻击主要利用的是TCP的三次握手漏洞，由于TCP建立连接的时候需要三次握手，当服务器收到一个SYN包后，服务器会处于SYN_Received状态，并且在系统中保存半连接的数据，同时发送SYN-ACK包给客户端，但是此时客户端消失了，而处于这个状态的服务器会有一个定时器，在收不到客户端的回复的时候，会重新的发送SYN-ACk数据包（3-5次，并且等待一个SYN-time，一般是30秒到2分钟），此时半连接的数据一直占着系统资源，这样的话，如果有大量这种行为就会导致服务器资源被一直占用着，而正常连接行为的客户却得不到处理。这就是所谓的SYN攻击</p>
<h4 id="ACK-Flood-攻击"><a href="#ACK-Flood-攻击" class="headerlink" title="ACK Flood 攻击"></a>ACK Flood 攻击</h4><p>ACK Flood攻击是在TCP连接建立之后，所有的数据传输TCP报文都是带有ACK标志位的，主机在接收到一个带有ACK标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应RST包告诉对方此端口不存在。<br>这里，服务器要做两个动作：查表、回应 ACK/RST。这种攻击方式显然没有SYN Flood给服务器带来的冲击大，因此攻击者一定要用大流量ACK小包冲击才会对服务器造成影响。按照我们对TCP协议的理解，随机源IP的ACK小包应该会被Server很快丢弃，因为在服务器的TCP堆栈中没有这些ACK包的状态信息。但是实际上通过测试，发现有一些TCP服务会对ACK Flood比较敏感，比如说JSP Server，在数量并不多的ACK小包的打击下，JSP Server就很难处理正常的连接请求。对于Apache或者IIS来说，10kpps的ACK Flood不构成危胁，但是更高数量的ACK Flood会造成服务器网卡中断频率过高，负载过重而停止响应。可以肯定的是，ACK Flood不但可以危害路由器等网络设备，而且对服务器上的应用有不小的影响。</p>
<p>也有另外一种攻击：connection 攻击，就是大量的肉机与服务器建立连接，占用服务器的资源不放，而一台服务器的连接数量是有限的，大量的连接都被占用了，新的正常连接得不到服务。</p>
<h2 id="基于UDP的攻击"><a href="#基于UDP的攻击" class="headerlink" title="基于UDP的攻击"></a>基于UDP的攻击</h2><p>UDP Flood是日渐猖厥的流量型DoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。 100k pps的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。</p>
<h2 id="基于ICMP的攻击"><a href="#基于ICMP的攻击" class="headerlink" title="基于ICMP的攻击"></a>基于ICMP的攻击</h2><h4 id="死亡之ping"><a href="#死亡之ping" class="headerlink" title="死亡之ping"></a>死亡之ping</h4><p>IP协议规定IP包最大尺寸为65536，大部分的处理程序在处理IP包的时候，会假定报文不会超过最大的尺寸，利用该漏洞，可以发送大于65536的数据包，使得系统在处理报文的时候发生内存溢出，从而使得系统崩溃。这就是死亡之ping的实现原理，发送大于限制长度的报文来使得服务器出现系统奔溃</p>
<h4 id="echo攻击"><a href="#echo攻击" class="headerlink" title="echo攻击"></a>echo攻击</h4><p>利用ICMP的echo机制，对服务器发送大量的ICMP包，占用服务器的带宽，也可以利用ICMP的广播机制，将源端IP伪造成服务器的IP，向网络广播ICMP echo request，从而使得大量的网络机器向服务器发送ICMP echo应答包，占用服务器的大量带宽。</p>
<h4 id="针对链接的ICMP-DoS"><a href="#针对链接的ICMP-DoS" class="headerlink" title="针对链接的ICMP DoS"></a>针对链接的ICMP DoS</h4><p>针对连接的DoS攻击，可以终止现有的网络连接。针对网络连接的DoS攻击会影响所有的IP设备，因为它使用了合法的ICMP消息。Nuke通过发送一个伪造的ICMP Destination Unreachable或Redirect消息来终止合法的网络连接。更具恶意的攻击，如puke和smack，会给某一个范围内的端口发送大量的数据包，毁掉大量的网络连接，同时还会消耗受害主机CPU的时钟周期。</p>
<h4 id="基于ICMP重定向的路由欺骗技术"><a href="#基于ICMP重定向的路由欺骗技术" class="headerlink" title="基于ICMP重定向的路由欺骗技术"></a>基于ICMP重定向的路由欺骗技术</h4><p>攻击者可利用ICMP重定向报文破坏路由，并以此增强其窃听能力。除了路由器，主机必须服从ICMP重定向。如果一台机器想网络中的另一台机器发送了一个ICMP重定向消息，这就可能引起其他机器具有一张无效的路由表。如果一台机器伪装成路由器截获所有到某些目标网络或全部目标网络的IP数据包，这样就形成了窃听。通过ICMP技术还可以抵达防火墙后的机器进行攻击和窃听。</p>
<p>注：重定向路由欺骗技术尚无实际应用。</p>
<h2 id="HTTP-Get-攻击"><a href="#HTTP-Get-攻击" class="headerlink" title="HTTP Get 攻击"></a>HTTP Get 攻击</h2><p>这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQLServer、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。一般来说，提交一个GET或POST指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是很大的，常见的数据库服务器很少能支持数百个查询指令同时执行，而这对于客户端来说却是轻而易举的，因此攻击者只需通过Proxy代理向主机服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务，常见的现象就是网站慢如蜗牛、ASP程序失效、PHP连接数据库失败、数据库主程序占用CPU偏高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/DDOS攻击简介/" data-id="ciqklv24r005vroqy4hrcxbfe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内网穿透简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/内网穿透简介/" class="article-date">
  <time datetime="2016-04-26T06:13:50.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/内网穿透简介/">内网穿透简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NAT的类型"><a href="#NAT的类型" class="headerlink" title="NAT的类型"></a>NAT的类型</h2><p>NAT一般有两种大的类型：cone（漏斗）类型和symmetric（对称）类型</p>
<h3 id="cone"><a href="#cone" class="headerlink" title="cone"></a>cone</h3><p>cone类型又分为三种小的类型，分别为：full cone、restricted cone和port restricted cone</p>
<p>在cone类型中，内网ip-port对在NAT中的映射是不变的，即使所访问的外网ip-port端口不一样，这也是其命名为cone的原因。</p>
<h4 id="full-cone"><a href="#full-cone" class="headerlink" title="full cone"></a>full cone</h4><p>full cone是限制最少的类型，在NAT服务器上，一个内网的ip-port对只映射到一个公网的ip-port对，而不管内网主机访问的外网ip-port对的不同。</p>
<h4 id="restricted-cone"><a href="#restricted-cone" class="headerlink" title="restricted cone"></a>restricted cone</h4><p>restricted cone相对于full cone类型增加了外网ip的限制，只有内网的机器访问了某个外网的机器，该外网机器的数据包才可以通过NAT的限制。在NAT的映射中，NAT维持一个映射关系：<br>{对端外网ip：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个外网ip的机器不同的port都可以通过该映射，从而实现与内网的通讯。</p>
<h4 id="port-restricted-cone"><a href="#port-restricted-cone" class="headerlink" title="port restricted cone"></a>port restricted cone</h4><p> port restricted cone类型在restricted cone类型的基础上增加了port的限制，必须又内网的机器访问外网机器的某个端口，该外网机器的对应端口发出的数据包才可以通过NAT。NAT维持的映射关系如下：<br> {对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}，同一个机器的特定端口才可以通过该映射。</p>
 <font color="red">注意，在以上的三种类型中，只要内网ip-port对不变，其在NAT的映射所对应的公网ip-port对就不会改变，也就是说，同一个内网ip-port在通讯过程中，其所对外的公网ip-port是不变的</font>

<h3 id="symmetric"><a href="#symmetric" class="headerlink" title="symmetric"></a>symmetric</h3><p>该类型的限制最严格，端口对端口的通讯都会有一个特定的映射，就拿port restricted cone来说，对于映射：{对端外网ip：对端外网port：内网ip：内网port}—-&gt;{公网ip：公网port}， 只要是四元组中的内网ip：内网port不变，那么所有的四元组都会被映射到同一个{公网ip：公网port}，而在symmetric类型下，只要四元组中有一个是变化的，都会被映射到不同的而且唯一的{公网ip：公网port}。</p>
<p>cone 的映射是多对一的映射，类似于一个漏斗，而symmetric的映射是一个一对一的映射，也就是对称的映射。</p>
<h2 id="NAT穿透"><a href="#NAT穿透" class="headerlink" title="NAT穿透"></a>NAT穿透</h2><p>根据NAT的类型不同，具体的实现细节也是不同的。但是不管是NAT类型不同，还是所采用的打洞技术不同，都需要使用到第三方服务器作为彼此信息的转发者。采用UDP来实现打洞，成功率会比较高，实现起来也比较容易。而采用TCP来打洞的话，成功率较低，而且实现起来会比较的麻烦，主要的原因就是对于TCP来说，既要打洞又要建立监听，而两者所使用的端口都是一样的，而且如果两端同时收到对端的SYN，那么两端都会处于SYN-Received状态，具体进一步的处理就要看不同的系统的TCP栈处理程序了，这个也就会导致TCP在打洞方面的成功率低于UDP。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/04/26/内网穿透简介/" data-id="ciqklv21v002hroqyium9pxyf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java底层机制/">Java底层机制</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图与树/">图与树</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Java底层机制/" style="font-size: 16.67px;">Java底层机制</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/图与树/" style="font-size: 16.67px;">图与树</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/13/LCA之DFS-ST算法/">LCA之DFS+ST算法</a>
          </li>
        
          <li>
            <a href="/2016/07/13/LCA之Tarjan算法/">LCA之Tarjan算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/ST算法/">ST算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/线段树/">线段树</a>
          </li>
        
          <li>
            <a href="/2016/07/12/并查集/">并查集</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>