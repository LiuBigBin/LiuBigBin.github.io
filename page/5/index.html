<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiuYongbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongbin">
<meta property="og:url" content="http://liubigbin.github.io/page/5/index.html">
<meta property="og:site_name" content="LiuYongbin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongbin">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="LiuYongbin" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongbin</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hey boy just do it!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liubigbin.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-那家姓B的树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/18/那家姓B的树/" class="article-date">
  <time datetime="2016-03-18T07:23:13.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/那家姓B的树/">那家姓B的树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>姓B的树主要有三种：B-树（也就是B树），B+树以及B*树。</p>
<h2 id="B-树（B树）"><a href="#B-树（B树）" class="headerlink" title="B-树（B树）"></a>B-树（B树）</h2><p> B 树又叫平衡多路查找树。一棵M阶的B树定义如下：</p>
<ol>
<li>M阶树，指的是每一个节点最多有M个子节点</li>
<li>除了根节点可以有2&lt;= K &lt;=M个子节点之外，其他中间节点的子节点数目必须在M/2(取上限)&lt;= K &lt;=M之间</li>
<li>所有叶子节点都出现在同一层，实际上所有的叶子节点都是空指针</li>
<li>每一个节点中关键字的个数不其所拥有的子节点少一个，且升序排序</li>
<li>2和4的限制导致了对于每一个中间节点，其所有的关键节点的数量为M/2(取上限)-1 &lt;= K &lt;= M-1</li>
</ol>
<p>B树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据.</p>
<h4 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h4><p>如果一颗B树所包含的关键字为N，那么怎样求该树的高度呢？<br>这里先设每一个节点的最小子节点的数量<code>M/2(取上限)</code>为t，那么在第一层，也就是根节点，节点数量为1，第二层的节点数量至少为2，接下来每一层，由于每一个节点的子节点数量为t，于是第三层的节点数为2*t，第四层为<code>2·t·t</code>，一直下去。所以第L层的节点数为<code>2·t^(L-2)</code>; 对于B树来说，叶节点的数量为B树的所有关键字N+1，所以对于有N个关键字的B树来说，其叶子节点的层数如果为h的话，那么有<code>2·t^(h-2) = N+1</code>; 这样的话，<code>h = log_t((N+1)/2)+2</code>;由于B树的叶子节点只是一个空指针，在B树中没有表示出来，所以B树的层数为<code>H = log_t((N+1)/2)+1</code>，如果高度从根节点为0算起的话，就是<code>log_t((N+1)/2)</code>，因为上面所有的推导都是在节点的子节点最小的情况下得到的，所以实际上B树的高度要比得到的<code>log_t((N+1)/2)</code>小。</p>
<h3 id="B树的插入删除操作"><a href="#B树的插入删除操作" class="headerlink" title="B树的插入删除操作"></a>B树的插入删除操作</h3><p>对于会修改B树结构的操作：插入、删除，在处理的过程中必须保证B树的特征，所以对于插入和删除，需要一些比较复制的处理流程：</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入一个值时，如果对应的节点的关键字恰好为M-1个，那么需要将该节点的关键字的中位数上移到其父节点中，然后该节点剩下的关键字平均分裂为两个新的节点，上移的中位数对于父节点来说其实也是一个插入操作，所以对父节点进行同样的插入造作，这样递归知道没有冲突为止。如果插入的节点的关键字小于M-1，那么直接在该节点中按照关键字的值顺序插入新的关键字。<br>下面是插入的演示：</p>
<p>1、B树的初始结构：<br><img src="/pictures/数据结构/树结构/B树插入-初始结构.jpg" alt=""></p>
<p>2、插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：</p>
<p><img src="/pictures/数据结构/树结构/B树插入-1.jpg" alt=""></p>
<p>3、当插入E,K,Q时，不需要任何分裂操作：<br><img src="/pictures/数据结构/树结构/B树插入-2.jpg" alt=""></p>
<p>4、插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<br><img src="/pictures/数据结构/树结构/B树插入-3.jpg" alt=""></p>
<p>5、当B树的结构如下所示时：<br><img src="/pictures/数据结构/树结构/B树插入-4.jpg" alt=""></p>
<p>6、当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，<font color="red">注意以前在父节点中的第三个指针在修改后包括D和G节点中。</font><br><img src="/pictures/数据结构/树结构/B树插入-5.jpg" alt=""></p>
<h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3><p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，接下来判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接进入移动之后的情况。</p>
<h4 id="移动之后的情况："><a href="#移动之后的情况：" class="headerlink" title="移动之后的情况："></a>移动之后的情况：</h4><ol>
<li>如果当前所在的节点没有子节点，那么在删除后，需要看当前的节点的关键字是个数是否为：<code>M/2(取上限)-1 &lt;= K &lt;= M-1</code>,如果是的话，删除完成，否则的话，进入向相邻兄弟节点求借关键字步骤。</li>
<li>如果的当前的所在节点具有子节点，那么删除后，向该关键字所对应的左或右子节点接一个关键字上移到当前节点中，先借丰满的子节点，移动后不需要修改其他，删除直接完成。如果左右子节点都不是丰满的，那么在上移一个关键字后，需要对被借关键子的子节点进入向相邻兄弟节点求借关键字步骤。</li>
</ol>
<h4 id="进入向相邻兄弟节点求借关键字步骤"><a href="#进入向相邻兄弟节点求借关键字步骤" class="headerlink" title="进入向相邻兄弟节点求借关键字步骤"></a>进入向相邻兄弟节点求借关键字步骤</h4><p>向相邻兄弟节点求借关键字步骤是因为当前的节点的关键子个数不符合<code>M/2(取上限)-1 &lt;= K &lt;= M-1</code>，此时可以看看与当前节点相邻的左右兄弟节点有没有丰满的，有的话，当前节点所对应的父节点的关键子下移到当前节点中，然后丰满兄弟节点的相应的关键子上移到父节点中，放在那个刚下移的关键子的位置上，结束！，如果左右兄弟节点都没有丰满的话，就只能进行节点合并了。节点合并先找出需要合并的左右兄弟节点，二选一，然后将父节点所对应的关键子下移与需要合并的两个节点组成新的节点，此时，父节点相当于删除了一个关键字，那么就需要对父节点进行进入向相邻兄弟节点求借关键字步骤了，一直递归知道B树结构平衡为止！</p>
<p>删除演示：<br>1、B树的初始结构：<br><img src="/pictures/数据结构/树结构/B树删除-初始结构.jpg" alt=""></p>
<p>2、首先删除元素H，当然首先查找H，H在一个叶子结点中，且该叶子结点元素数目3大于最小元素数目ceil(m/2)-1=2，则操作很简单，只需要移动K至原来H的位置，移动L至K的位置（也就是结点中删除元素后面的元素向前移动）<br><img src="/pictures/数据结构/树结构/B树删除-1.jpg" alt=""></p>
<p>3、下一步，删除T,因为T没有在叶子结点中，而是在中间结点中找到，发现他的继承者W(字母升序的下个元素)，将W上移到T的位置，然后将原包含W的孩子结点中的W进行删除，这里恰好删除W后，该孩子结点中元素个数大于2，无需进行合并操作。<br><img src="/pictures/数据结构/树结构/B树删除-2.jpg" alt=""></p>
<p>4、下一步删除R，R在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目ceil(5/2)-1=2，此时进入进入向相邻兄弟节点求借关键字步骤<br><img src="/pictures/数据结构/树结构/B树删除-3.jpg" alt=""></p>
<p>5、最后一步删除E，因为没有左右相邻兄弟节点是丰满的，所以进入节点合并步骤：<br><img src="/pictures/数据结构/树结构/B树删除-4.jpg" alt=""></p>
<p>但是，由于此时的父节点不符合要求，所以需要对父节点在进入进入向相邻兄弟节点求借关键字步骤，很明显，父节点G没有对应可借的兄弟节点，所以进行节点合并<br><img src="/pictures/数据结构/树结构/B树删除-4.jpg" alt=""></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>谈完了B树，我们再来讨论一下B+tree，B+tree是B树的一个变种，在实际应用中，B+tree更加常见。B+树与B树的区别在于这么几点：<br>1、B+树的内部节点（也就是非叶子节点）有n个关键字，同时有n个儿子。这和B树不同，B树的内部节点有n个儿子，但只有n-1个关键字。<br>2、B+树只有叶子节点才包含行数据，而内部节点仅仅只有关键字信息和儿子的指针（这里的指针实际上就是磁盘块的文件偏移量），也就是说内部节点仅仅包含索引信息。<br>3、B+树中的数据都存在于叶子节点中，因此所有叶子节点加在一起所组成的集合包含了所有关键字的信息以及关键字对应的行数据，而B树所有叶子节点加在一起所组成的集合并未包含所有的关键字，因为有些关键字处在内部节点中。<br><img src="/pictures/数据结构/树结构/B+树.png" alt=""></p>
<p>上图就是B+树的一个实例。可以看到叶子节点中，蓝色部分包含了所有关键字信息，一个也不少。图中叶子节点把关键字信息（蓝色）和实际数据（Q）分开了，实际上为了便于理解，你可以认为叶子节点就是一行一行顺序排列的行数据，行数据本身就包含了关键字信息。需要注意的是，中间节点的每一个关键字的值都是其对应的子节点的关键字中的那个最小的值。每一个节点之所以有一个指向其相邻兄弟的指针，是因为可以方便顺序访问，提高区间访问的性能。相比于B树，B+树更适合外存索引，原因和内节点的出度有关，因为B+树的内节点只存储索引信息和子节点的指针信息，少去了B树对应的data信息，所以一个节点所存储的索引信息比B树大很多，这样的话，节点的出度就越高。因为一般在实现B+树的时候，会是将一个节点设置成为一个页的大小，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O，所以一个节点的出度就取决于存储的key+data+pointer的大小，B+少了data，所以存的索引信息也就越多。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>B<em>-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B</em>树中非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)·M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：<br><img src="/pictures/数据结构/树结构/B星树.jpg" alt=""></p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。<br>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。<br>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/18/那家姓B的树/" data-id="ciqkep7u00005o0qy2am6qday" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树结构/">树结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-第K小元素选择算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/17/第K小元素选择算法/" class="article-date">
  <time datetime="2016-03-17T13:40:02.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/第K小元素选择算法/">第K小元素选择算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于在一个无序的数组中找出第K小（大）的元素，目前有很多种方法，但是BFPRT算法是目前最好的算法，其复杂度在最好或最坏情况下都是O(n)。目前主要有一下几种思路：</p>
<p>1、将n个数排序(比如快速排序或归并排序)，选取排序后的第k个数，时间复杂度为O(nlogn)。使用STL函数sort可以大大减少编码量。</p>
<p>2、将方法1中的排序方法改为线性时间排序算法(如基数排序或计数排序)，时间复杂度为O(n)。但线性时间排序算法使用限制较多，不常使用。</p>
<p>3、维护一个k个元素的最大堆，存储当前遇到的最小的k个数，时间复杂度为O(nlogk)。这种方法同样适用于海量数据的处理。</p>
<p>4、部分的选择排序，即把最小的放在第1位，第二小的放在第2位，直到第k位为止，时间复杂度为O(kn)。实现非常简单。</p>
<p>5、部分的快速排序（快速选择算法），每次划分之后判断第k个数在左右哪个部分，然后递归对应的部分，平均时间复杂度为O(n)。但最坏情况下复杂度为O(n^2)。</p>
<p>6、BFPRT算法，修改快速选择算法的主元选取规则，使用中位数的中位数的作为主元，最坏情况下时间复杂度为O(n)。</p>
<h4 id="BFPRT的算法步骤如下："><a href="#BFPRT的算法步骤如下：" class="headerlink" title="BFPRT的算法步骤如下："></a>BFPRT的算法步骤如下：</h4><ol>
<li><p>将n个元素每5个一组，分成n/5(上界)组。</p>
</li>
<li><p>取出每一组的中位数，任意排序方法，比如插入排序。</p>
</li>
<li><p>递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。</p>
</li>
<li><p>用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。</p>
</li>
<li><p>若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。</k，在小于x的元素中递归查找第i小的元素；若i></p>
</li>
<li><p>终止条件：n=1时，返回的即是i小元素。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/17/第K小元素选择算法/" data-id="ciqkep7v10011o0qycg2dhxnj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组/">数组</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C语言之static" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/17/C语言之static/" class="article-date">
  <time datetime="2016-03-17T05:59:50.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/C语言之static/">C语言之static</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在C或是C++语言中，一段可运行程序在内存中的内存分配图如下：<br><img src="/pictures/C与C++/程序运行内存分配图.png" alt="程序运行内存分配图"></p>
<p>在C语言中，全局变量和静态变量都是存储在上图中的数据区下面，所以在函数中定义一个局部静态变量时，该变量的内存就在数据区中，而不是在栈内存去里面，所以当函数运行完成退出后，对应的静态局部变量还是在数据区里面，不会随着函数的退出而消亡。</p>
<p>由于C语言代码是以文件为单位来组织的，在一个源程序所有源文件中，一个外部变量或函数只能在某个文件中定义一次，而其它文件可以通过extern声明来访问它（定义外部变量或函数的源文件中也可以包含对该外部变量的extern声明）。而static则可以限定变量或函数为静态存储。如果用static限定外部变量与函数，则可以将该对象的作用域限定为被编译源文件的剩余部分。通过static限定外部对象，可以达到隐藏外部对象的目的。因而，static限定的变量或函数不会和同一程序中其它文件中同名的相冲突。如果用static限定内部变量，则该变量从程序一开始就拥有内存，不会随其所在函数的调用和退出而分配和消失。</p>
<p>C语言中使用静态函数的好处：</p>
<ol>
<li>静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。</li>
<li>关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。 使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。</li>
</ol>
<h2 id="static变量"><a href="#static变量" class="headerlink" title="static变量:"></a>static变量:</h2><h4 id="局部"><a href="#局部" class="headerlink" title="局部"></a>局部</h4><p>a.静态局部变量在函数内定义,生存期为整个源程序，但作用域与自动变量相同，只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它。<br>b.对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。但是他们的作用域，非静态全局 变量的作用域是整个源程序（多个源文件可以共同使用）； 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。</p>
<h2 id="static函数（也叫内部函数）"><a href="#static函数（也叫内部函数）" class="headerlink" title="static函数（也叫内部函数）"></a>static函数（也叫内部函数）</h2><p>只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。区别于一般的非静态函数（外部函数）</p>
<h4 id="全局变量以及全局变量与静态变量的关系："><a href="#全局变量以及全局变量与静态变量的关系：" class="headerlink" title="全局变量以及全局变量与静态变量的关系："></a>全局变量以及全局变量与静态变量的关系：</h4><p>顾名思义，全局变量是指能够在全局引用的变量，相对于局部变量的概念，也叫外部变量；同静态变量一样，全局变量位于静态数据区，全局变量一处定义，多处引用，用关键字“extern”引用“外部”的变量。</p>
<p>全局变量也可以是静态的，在前面有过说明，静态全局变量的意义就是不让“外部”引用，是单个源文件里的全局变量，即是编译阶段的全局变量，而不是连接阶段的全局变量。</p>
<h4 id="通过上面的分析，我们不难得出以下结论："><a href="#通过上面的分析，我们不难得出以下结论：" class="headerlink" title="通过上面的分析，我们不难得出以下结论："></a>通过上面的分析，我们不难得出以下结论：</h4><p>1、 静态函数与普通函数的区别在于：静态函数不可以被同一源文件以外的函数调用。</p>
<p>2、 静态局部变量与普通局部变量的区别在于：静态局部变量只初始化一次，下一次初始化实际上是依然是上一次的变量；</p>
<p>3、 静态全局变量与普通全局变量的区别在于：静态全局变量的作用域仅限于所在的源文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/17/C语言之static/" data-id="ciqkep7z0005vo0qy4k3a5joo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从整数的补码到用位运算实现任何两个数的加减法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/16/从整数的补码到用位运算实现任何两个数的加减法/" class="article-date">
  <time datetime="2016-03-16T06:46:15.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C与C/">C与C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/从整数的补码到用位运算实现任何两个数的加减法/">从整数的补码到用位运算实现任何两个数的加减法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在计算机中，数值是以补码的形式存储的，正整数的补码就是其原码，负整数的补码就是其绝对值的原码所有位取反再加1。</p>
<p>例如：-7的补码：因为是负数，则符号位为“1”,整个为10000111；其余7位为-7的绝对值+7的原码<br>  0000111按位取反为1111000；再加1，所以-7的补码是11111001。简单点就是10000000（ 128）-0000111（7）=11111001（121）</p>
<p>由上面的例子也可以知道，要求一个负整数的补码，在一个字节大小的情况下，只需要求128减去该负数的绝对值所得到的差的原码就行。</p>
<p>计算机之所以要把负数存储为其补码，是因为想把减法变成加法，这样减去一个负数，就相当于加上该负数的补码。</p>
<p>想要将一个正整数取反的话，那么只需要对该正整数按位取反再加1就可以了，相反的，如果是负整数转正整数的话，就是先减一在按位取反，下面的c语言的整数取反代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num = ~(num - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num = ~num + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来看看怎样通过位运算来实现连个整数的加法。</p>
<p>我们知道，在位的角度来看加法，一个位加后，要么需要进位，要么不需要，需要进位的是因为两个加数相同的位的值都是1，不需要进位是因为相同位的值不都是1，不需要进位的情况下，只需要两个数进行异或运算就可以了，进位的情况下，需要两个加数先进行&amp;运算，得到进位的值，在左移一位，这样再递归的进行两个数的相加，知道没有进位为止，也就是两个加数&amp;运算后的值为0。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span>  b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>  b ? add ((a  ^  b) , (a &amp; b)&lt;&lt;<span class="number">1</span>) : a ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a  ,  c ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">scanf</span> (<span class="string">"%d%d"</span>,&amp;a , &amp;c) ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span> (<span class="string">"val = %d\n"</span> , add (a , c) );</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果想要实现两个整数相减的话，那么可以利用补码的思想，先将减数取反，得到其补码，在利用上面的加法进行求和。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/16/从整数的补码到用位运算实现任何两个数的加减法/" data-id="ciqkep7wa002qo0qyepk4hzta" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/位运算/">位运算</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-域名污染" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/域名污染/" class="article-date">
  <time datetime="2016-03-15T09:17:09.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/域名污染/">域名污染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>域名服务器缓存污染（DNS cache pollution），又称域名服务器缓存投毒（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器封包，把域名指往不正确的IP地址。一般来说，在互联网上都有可信赖的域名服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关域名的局域域名服务器的缓存受到污染，就会把域名内的电脑导引往错误的服务器或服务器的网址。</p>
<p>域名服务器缓存污染可能是因为域名服务器软件的设计错误而产生，但亦可能由别有用心者透过研究开放架构的域名服务器系统来利用当中的漏洞。为防止局域的域名服务器缓存污染除了要定时更新服务器的软件以外，可能还需要人手变更某些设定，以控制服务器对可疑的域名封包作出筛选。</p>
<p>一般来说，一部连上了互联网的电脑都会使用互联网服务供应商提供的域名服务器。这个服务器一般只会服务供应商的客户，通常都会将部分客户曾经请求过的域名暂存起来，这种服务器被称为非权威服务器，其应答称非权威应答。缓存污染攻击就是针对这一种服务器，以影响服务器的使用者或下游服务。</p>
<p>在中国大陆，对所有经过防火长城的在UDP的53端口上的域名查询进行IDS入侵检测，一经发现与黑名单关键词相匹配的域名查询请求，会马上伪装成目标域名的解析服务器返回虚假的查询结果。由于通常的域名查询没有任何认证机制，而且域名查询通常基于无连接不可靠的UDP协议，查询者只能接受最先到达的格式正确结果，并丢弃之后的结果。</p>
<p>对于不了解相关知识的网民来说，由于系统默认使用的ISP提供的域名查询服务器查询国外的权威服务器时即被防火长城污染，进而使其缓存受到污染，因此默认情况下查询ISP的服务器就会获得虚假IP地址；而用户直接查询境外域名查询服务器（比如 Google Public DNS）时有可能会直接被防火长城污染，从而在没有任何防范机制的情况下仍然不能获得目标网站正确的IP地址。<br>因为TCP连接的机制可靠，防火长城理论上未对TCP协议下的域名查询进行污染，故现在能透过强制使用TCP协议查询真实的IP地址。而现实的情况是，防火长城对于真实的IP地址也可能会采取其它的手段进行封锁，或者对查询行为使用连接重置的方法进行拦截，故能否真正访问可能还需要其它翻墙的手段。</p>
<h3 id="ISP域名劫持"><a href="#ISP域名劫持" class="headerlink" title="ISP域名劫持"></a>ISP域名劫持</h3><p>中国的互联网服务提供商经常劫持部分域名，转到自己指定的网站，以提供自己的广告。</p>
<p>以上内容来自于<a href="https://zh.wikipedia.org/zh-cn/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#ISP.E5.9F.9F.E5.90.8D.E5.8A.AB.E6.8C.81" target="_blank" rel="external">维基百科</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/15/域名污染/" data-id="ciqkep7vu001yo0qys8cp6jxl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NAT以及内网穿透" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/NAT以及内网穿透/" class="article-date">
  <time datetime="2016-03-15T07:21:42.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/NAT以及内网穿透/">NAT以及内网穿透</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT分两种类型：NAT和NAPT。</p>
<h3 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT(Network Address Translation)网络地址转换"></a>NAT(Network Address Translation)网络地址转换</h3><p>NAT属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。NAT（Network Address Translation，网络地址转换）是将IP数据包头中的IP地址转换为另一个IP 地址的过程。在实际应用中，NAT 主要用于实现私有网络访问公共网络的功能。这种通过使用少量的公有IP 地址代表较多的私有IP地址的方式，将有助于减缓可用IP 地址空间的枯竭。</p>
<h3 id="NAPT-Network-Address-Port-Translation-网络地址端口转换"><a href="#NAPT-Network-Address-Port-Translation-网络地址端口转换" class="headerlink" title="NAPT(Network Address Port Translation)网络地址端口转换"></a>NAPT(Network Address Port Translation)网络地址端口转换</h3><p>NAPT是人们比较熟悉的一种转换方式。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。NAPT是一种较流行的NAT的变体通过转换TCP或UDP协议端口号以及地址来提供并发性。除了一对源和目的IP地址以外，这个表还包括一对源和目的协议端口号，以及NAT盒使用的一个协议端口号。NAPT的主要优势在于，能够使用一个全球有效IP地址获得通用性。主要缺点在于其通信仅限于TCP或UDP。只要所有通信都采用TCP或UDP，NAPT就允许一台内部计算机访问多台外部计算机，并允许多台内部主机访问同一台外部计算机，相互之间不会发生冲突。</p>
<h4 id="NAPT的四种类型"><a href="#NAPT的四种类型" class="headerlink" title="NAPT的四种类型"></a>NAPT的四种类型</h4><ol>
<li><p>Full Cone NAT：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全</p>
</li>
<li><p>Restricted Cone NAT：它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安全性</p>
</li>
<li><p>Port Restricted Cone NAT：它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性</p>
</li>
<li><p>Symmetric NAT：这是一种比所有Cone NAT都要更为灵活的转换方式：在Cone NAT中，内部主机的内部Tuple与外部Tuple的转换映射关系是独立于内部主机所发出的UDP报文中的目标地址及端口的，即与目标Tuple无关；在Symmetric NAT中，目标Tuple则成为了NAT设备建立转换关系的一个重要考量：只有来自于同一个内部Tuple 、且针对同一目标Tuple的请求才被NAT转换至同一个外部Tuple，否则的话，NAT将为之分配一个新的外部Tuple；打个比方，当内部主机以相同的内部Tuple对2个不同的目标Tuple发送UDP报文时，此时NAT将会为内部主机分配两个不同的外部Tuple，并且建立起两个不同的内、外部Tuple转换关系。与此同时，只有接收到了内部主机所发送的数据包的外部主机才能向内部主机返回UDP报文，这里对外部返回报文来源的限制是与Port Restricted Cone一致的。不难看出，如果说Full Cone是要求最宽松NAT UDP转换方式，那么，Symmetric NAT则是要求最严格的NAT方式，其不仅体现在转换关系的建立上，而且还体现在对外部报文来源的限制方面。</p>
</li>
</ol>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>内网穿透是一个比较大的研究问题，这里只是根据自己的理解对其进行简答的原理描述而已。</p>
<p>内网穿透的实现方法根据不同A、B双方不同的NAPT类型而不同，一般如果两侧的NAT类型都是Cone NAT类型，那么就可以实现双向的通讯。如果两侧都是Symmetric NAT，或是一侧是Symmetric NAT另一侧是Port Restricted Cone，那么将不能实现双向通讯。</p>
<p>由于内网机器可以访问外网的机器，而外网的机器不能访问内网的机器，之所以不能访问，那是因为在内网端的NAT上没有对应的内网机器IP端口转换记录，所以NAT找不到对应的内部机器，所以直接的把数据包给丢掉。所以，如果想要实现内网穿透，那么就必须要先知道内网机器在NAT上的所对应的公网IP：Port信息，而且必须让NAT产生这条信息。那么怎么才可以使得内网的NAT产生该信息，而且另一端能获得这条转换后的公网IP：Port信息呢？此时需要第三方公网服务器S的支持。</p>
<p>内网机器A发送一条信息给公网服务器S，公网服务器得到了A经过NAT转换后的公网IP：port信息，并记录下来，另一侧的内网机器B同样发送信息给公网服务器S，S得到了B的转换后的公网IP：Port信息，此时在A的NAT和B的NAT都分别产生了A和B的内网IP：Port转换为公网IP：Port的映射信息，在S把对方的转换后的公网IP：Port信息分别告诉给A、B后，就可以根据不同的NAT类型来实现内网的穿透了。</p>
<ol>
<li><p>Full Cone NAT类型的最容易，因为不会对外网的请求来源进行限制，所以可以直接进行双向通讯了。</p>
</li>
<li><p>Restricted Cone NAT类型和Port Restricted Cone NAT类型需要有一侧发起第一次注定失败的请求，例如：B发起对A的请求，此时在B的NAT上就会有B对A的请求记录，但是在A的NAT上面并没有对应的A请求B的记录，所以B发起的请求会被A的NAT给丢弃，但是此时的B已经对A打好洞了，所以如果此时A发起请求，或是数据给B（A侧打洞），那么由于B的NAT有对应的B请求过A的记录，所以数据包能以顺利的到达B。那么在数据顺利到达B后，由于A给B发送了数据（不管成功或失败），才是在A的NAT上也有对应的A请求过B的记录，所以此时如果有新的B的数据包发给A，那么A的NAT就会直接的根据映射将数据包转给A，实现了B与A的通信。</p>
</li>
<li><p>Symmetric NAT，由于该类型的NAT的映射对象不是内网的IP：Port，而是外网的IP：Port信息，所以对不同的外网IP：Port请求会得到不同的IP：port转换，请求服务器S会得到一条IP：Port转换，请求对侧也会得到一条不同的IP：Port转换，又由于ymmetric NAT对外部返回报文来源的限制是与Port Restricted Cone一致的，所以这种类型不能实现双方的通讯。</p>
</li>
</ol>
<p>对于内网穿透，网上一般都是UDP实现的，而且该技术已经很成熟了，对于TCP的实现，有说可以实现的，有说不可以实现的，由于自己没有具体的写代码实现过，不过感觉根据UDP的实现思路，TCP应该也是可以实现内网穿透的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/15/NAT以及内网穿透/" data-id="ciqkep7xw003wo0qyk286lw0v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP_IP模型常用协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/14/TCP_IP模型常用协议/" class="article-date">
  <time datetime="2016-03-14T10:01:27.000Z" itemprop="datePublished">2016-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/14/TCP_IP模型常用协议/">TCP/IP模型常用协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要讲解一下TCP/IP模型中用到的几个比较主要的协议：ICMP、ARP、RARP、RIP以及BGP协议<br><img src="pictures/网络层协议/TCP_IP模型与OSI模型.jpg" alt=""><br>在OSI模型中，arp和rarp是归属于数据链路层的协议，但是在TCP/IP模型中，两者都归类为网络层协议。</p>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>ICMP(Internet Control Message Protocol)是介于网络层和传输层的协议。它的主要功能是传输网络诊断信息。</p>
<p>ICMP传输的信息可以分为两类，一类是错误(error)信息，这一类信息可用来诊断网络故障。我们已经知道，IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送IP包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送IP包。通过ICMP包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。需要注意的是，ICMP只提供特定类型的错误汇报，它不能帮助IP协议成为“可靠”(reliable)的协议。另一类信息是咨询(Informational)性质的，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用ICMP包回答。</p>
<p>(ICMP基于IP协议。也就是说，一个ICMP包需要封装在IP包中，然后在互联网传送。ICMP是IP套装的必须部分，也就是说，任何一个支持IP协议的计算机，都要同时实现ICMP。)</p>
<p>ICMP协议是实现ping命令和traceroute命令的基础。这两个工具常用于网络排错。</p>
<h3 id="常见的ICMP包类型"><a href="#常见的ICMP包类型" class="headerlink" title="常见的ICMP包类型"></a>常见的ICMP包类型</h3><h4 id="回音"><a href="#回音" class="headerlink" title="回音"></a>回音</h4><p>回音(Echo)属于咨询信息。ping命令就是利用了该类型的ICMP包。当使用ping命令的时候，将向目标主机发送Echo-询问类型的ICMP包，而目标主机在接收到该ICMP包之后，会回复Echo-回答类型的ICMP包，并将询问ICMP包包含在数据部分。ping命令是我们进行网络排查的一个重要工具。如果一个IP地址可以通过ping命令收到回复，那么其他的网络协议通信方式也很有可能成功。</p>
<h4 id="源头冷却"><a href="#源头冷却" class="headerlink" title="源头冷却"></a>源头冷却</h4><p>源头冷却(source quench)属于错误信息。如果某个主机快速的向目的地传送数据，而目的地主机没有匹配的处理能力，目的地主机可以向出发主机发出该类型的ICMP包，提醒出发主机放慢发送速度(请温柔一点吧)。</p>
<h4 id="目的地无法到达"><a href="#目的地无法到达" class="headerlink" title="目的地无法到达"></a>目的地无法到达</h4><p>目的地无法到达(Destination Unreachable)属于错误信息。如果一个路由器接收到一个没办法进一步接力的IP包，它会向出发主机发送该类型的ICMP包。比如当IP包到达最后一个路由器，路由器发现目的地主机down机，就会向出发主机发送目的地无法到达(Destination Unreachable)类型的ICMP包。目的地无法到达还可能有其他的原因，比如不存在接力路径，比如不被接收的端口号等等。</p>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>超时(Time Exceeded)属于错误信息。IPv4中的Time to Live(TTL)和IPv6中的Hop Limit会随着经过的路由器而递减，当这个区域值减为0时，就认为该IP包超时(Time Exceeded)。Time Exceeded就是TTL减为0时的路由器发给出发主机的ICMP包，通知它发生了超时错误。</p>
<p>traceroute就利用了这种类型的ICMP包。traceroute命令用来发现IP接力路径(route)上的各个路由器。它向目的地发送IP包，第一次的时候，将TTL设置为1，引发第一个路由器的Time Exceeded错误。这样，第一个路由器回复ICMP包，从而让出发主机知道途径的第一个路由器的信息。随后TTL被设置为2、3、4，…，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送ICMP包来汇报错误。traceroute将ICMP包的信息打印在屏幕上，就是接力路径的信息了。</p>
<h4 id="重新定向"><a href="#重新定向" class="headerlink" title="重新定向"></a>重新定向</h4><p>重新定向(redirect)属于错误信息。当一个路由器收到一个IP包，对照其routing table，发现自己不应该收到该IP包，它会向出发主机发送重新定向类型的ICMP，提醒出发主机修改自己的routing table。</p>
<h4 id="IPv6的Neighbor-Discovery"><a href="#IPv6的Neighbor-Discovery" class="headerlink" title="IPv6的Neighbor Discovery"></a>IPv6的Neighbor Discovery</h4><p>ARP协议用于发现周边的IP地址和MAC地址的对应。然而，ARP协议只用于IPv4，IPv6并不使用ARP协议。IPv6包通过邻居探索(ND, Neighbor Discovery)来实现ARP的功能。ND的工作方式与ARP类似，但它基于ICMP协议。ICMP包有Neighbor Solicitation和Neighbor Advertisement类型。这两个类型分别对应ARP协议的询问和回复信息。</p>
<p>ICMP协议是IP协议的排错帮手，它可以帮助人们及时发现IP通信中出现的故障。基于ICMP的ping和traceroute也构成了重要的网络诊断工具。然而，需要注意的是，尽管ICMP的设计是出于好的意图，但ICMP却经常被黑客借用进行网络攻击，比如利用伪造的IP包引发大量的ICMP回复，并将这些ICMP包导向受害主机，从而形成DoS攻击。而redirect类型的ICMP包可以引起某个主机更改自己的routing table，所以也被用作攻击工具。许多站点选择忽视某些类型的ICMP包来提高自身的安全性。</p>
<h2 id="ARP协议、RARP协议"><a href="#ARP协议、RARP协议" class="headerlink" title="ARP协议、RARP协议"></a>ARP协议、RARP协议</h2><p>在上面的过程中，我们实际上假设了，每一台主机和路由都能了解局域网内的IP地址和MAC地址的对应关系，这是实现IP包封装(encapsulation)到帧的基本条件。IP地址与MAC地址的对应是通过ARP协议传播到局域网的每个主机和路由。每一台主机或路由中都有一个ARP cache，用以存储局域网内IP地址和MAC地址如何对应。</p>
<p>ARP协议(ARP介于连接层和网络层之间，ARP包需要包裹在一个帧中)的工作方式如下：主机会发出一个ARP包，该ARP包中包含有自己的IP地址和MAC地址。通过ARP包，主机以广播的形式询问局域网上所有的主机和路由：我是IP地址xxxx，我的MAC地址是xxxx，有人知道199.165.146.4的MAC地址吗？拥有该IP地址的主机会回复发出请求的主机：哦，我知道，这个IP地址属于我的一个NIC，它的MAC地址是xxxxxx。由于发送ARP请求的主机采取的是广播形式，并附带有自己的IP地址和MAC地址，其他的主机和路由会同时检查自己的ARP cache，如果不符合，则更新自己的ARP cache。</p>
<p>这样，经过几次ARP请求之后，ARP cache会达到稳定。如果局域网上设备发生变动，ARP重复上面过程。</p>
<p>(在Linux下，可以使用$arp命令来查看ARP的过程。ARP协议只用于IPv4。IPv6使用Neighbor Discovery Protocol来替代ARP的功能。)</p>
<p>RARP协议则刚好相反，它将MAC地址解析成为对应的IP地址，现在已很少单独使用。</p>
<h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>RIP协议是基于UDP协议来实现的，所以属于应用层协议。<br>RIP协议被用来生成路由表信息，它通过距离来决定routing table，所以属于distance-vector protocol。对于RIP来说，所谓的距离是从出发地到目的地途径的路由器数目(hop number)</p>
<h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>BGP协议基于TCP协议来实现，所以属于应用层协议。<br>RIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达。所以RIP更多用于互联网的一部分(比如整个中国电信的网络)。这样一个互联网的部分往往属于同一个ISP或者有同一个管理机构，所以叫做自治系统(AS,autonomous system)。自治系统内部的主机和路由根据通向外部的边界路由器来和其它的自治系统通信。各个边界路由器之间通过BGP(Border Gateway Protocol)来生成自己前往其它AS的routing table，而自治系统内部则参照边界路由器，使用RIP来决定routing table。BGP的基本工作过程与RIP类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(routing table)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/14/TCP_IP模型常用协议/" data-id="ciqkep7xr003no0qyeuwbhw57" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-平衡二叉查找树-AVL树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/12/平衡二叉查找树-AVL树/" class="article-date">
  <time datetime="2016-03-12T05:24:02.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/12/平衡二叉查找树-AVL树/">平衡二叉查找树(AVL树)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转载自：<a href="http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html" target="_blank" rel="external">一步一步写平衡二叉树（AVL树）</a>，个人感觉原文思路写的很好，也表达的很清楚，所以就转载一下，不过文中的代码感觉还有点小问题，但是结构写得很不错。</p>
<p>平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。<br><img src="/pictures/数据结构/树结构/AVL1.png" alt="两颗二叉查找树，只有右边的是AVL树"></p>
<h2 id="下面对于AVL树的构建进行描述："><a href="#下面对于AVL树的构建进行描述：" class="headerlink" title="下面对于AVL树的构建进行描述："></a>下面对于AVL树的构建进行描述：</h2><h4 id="第一步：节点信息"><a href="#第一步：节点信息" class="headerlink" title="第一步：节点信息"></a>第一步：节点信息</h4><p>相对于二叉查找树的节点来说，我们需要用一个属性二叉树的高度，目的是维护插入和删除过程中的旋转算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树节点信息</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> TreeNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TreeNode():lson(<span class="literal">NULL</span>),rson(<span class="literal">NULL</span>),freq(<span class="number">1</span>),hgt(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        T data;<span class="comment">//值</span></span><br><span class="line">        <span class="keyword">int</span> hgt;<span class="comment">//以此节点为根的树的高度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> freq;<span class="comment">//频率</span></span><br><span class="line">        TreeNode* lson;<span class="comment">//指向左儿子的地址</span></span><br><span class="line">        TreeNode* rson;<span class="comment">//指向右儿子的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第二步：平衡二叉树类的声明"><a href="#第二步：平衡二叉树类的声明" class="headerlink" title="第二步：平衡二叉树类的声明"></a>第二步：平衡二叉树类的声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树类的属性和方法声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> AVLTree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TreeNode&lt;T&gt;* root;<span class="comment">//根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insertpri</span><span class="params">(TreeNode&lt;T&gt;* &amp;node,T x)</span></span>;<span class="comment">//插入</span></span><br><span class="line">        TreeNode&lt;T&gt;* findpri(TreeNode&lt;T&gt;* node,T x);<span class="comment">//查找</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insubtree</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span>;<span class="comment">//中序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Deletepri</span><span class="params">(TreeNode&lt;T&gt;* &amp;node,T x)</span></span>;<span class="comment">//删除</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span>;<span class="comment">//求树的高度</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SingRotateLeft</span><span class="params">(TreeNode&lt;T&gt;* &amp;k2)</span></span>;<span class="comment">//左左情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SingRotateRight</span><span class="params">(TreeNode&lt;T&gt;* &amp;k2)</span></span>;<span class="comment">//右右情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateLR</span><span class="params">(TreeNode&lt;T&gt;* &amp;k3)</span></span>;<span class="comment">//左右情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoubleRotateRL</span><span class="params">(TreeNode&lt;T&gt;* &amp;k3)</span></span>;<span class="comment">//右左情况下的旋转</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> cmpa,<span class="keyword">int</span> cmpb)</span></span>;<span class="comment">//求最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        AVLTree():root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span></span>;<span class="comment">//插入接口</span></span><br><span class="line">        TreeNode&lt;T&gt;* find(T x);<span class="comment">//查找接口</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(T x)</span></span>;<span class="comment">//删除接口</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">()</span></span>;<span class="comment">//遍历接口</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第三步：两个辅助方法"><a href="#第三步：两个辅助方法" class="headerlink" title="第三步：两个辅助方法"></a>第三步：两个辅助方法</h4><p>　　旋转算法需要借助于两个功能的辅助，一个是求树的高度，一个是求两个高度的最大值。这里规定，一棵空树的高度为-1，只有一个根节点的树的高度为0，以后每多一层高度加1。为了解决指针NULL这种情况，写了一个求高度的函数，这个函数还是很有必要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算以节点为根的树的高度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::height(TreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;hgt;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最大值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> AVLTree&lt;T&gt;::Max(<span class="keyword">int</span> cmpa,<span class="keyword">int</span> cmpb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cmpa&gt;cmpb?cmpa:cmpb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第四步：旋转"><a href="#第四步：旋转" class="headerlink" title="第四步：旋转"></a>第四步：旋转</h4><p>对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：<br><img src="/pictures/数据结构/树结构/AVL2.png" alt="四种不平衡树的情况"></p>
<p>1、6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为<font color="red">左左</font>。</p>
<p>2、6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为<font color="red">左右</font>。</p>
<p>3、2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为<font color="red">右左</font>。</p>
<p>4、2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为<font color="red">右右</font>。</p>
<p>从图中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过<font color="red">一次旋转</font>就可以达到目标，我们称之为<font color="red">单旋转</font>。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行<font color="red">两次旋转</font>，我们称之为<font color="red">双旋转</font>。</p>
<h4 id="第五步：单旋转"><a href="#第五步：单旋转" class="headerlink" title="第五步：单旋转"></a>第五步：单旋转</h4><p>单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。</p>
<p><img src="/pictures/数据结构/树结构/AVL3.png" alt="左左情况下的单旋转过程"></p>
<p>为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p>
<p>这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左左情况下的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::SingRotateLeft(TreeNode&lt;T&gt;* &amp;k2)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* k1;</span><br><span class="line">    k1=k2-&gt;lson;</span><br><span class="line">    k2-&gt;lson=k1-&gt;rson;</span><br><span class="line">    k1-&gt;rson=k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    k1-&gt;hgt=Max(height(k1-&gt;lson),k2-&gt;hgt)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右右情况下的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::SingRotateRight(TreeNode&lt;T&gt;* &amp;k2)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* k1;</span><br><span class="line">    k1=k2-&gt;rson;</span><br><span class="line">    k2-&gt;rson=k1-&gt;lson;</span><br><span class="line">    k1-&gt;lson=k2;</span><br><span class="line"></span><br><span class="line">    k2-&gt;hgt=Max(height(k2-&gt;lson),height(k2-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    k1-&gt;hgt=Max(height(k1-&gt;rson),k2-&gt;hgt)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第六步：双旋转"><a href="#第六步：双旋转" class="headerlink" title="第六步：双旋转"></a>第六步：双旋转</h4><p>对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。</p>
<p><img src="/pictures/数据结构/树结构/AVL4.png" alt="左右情况下的双旋转过程"></p>
<p>为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次<font color="red">右右旋转</font>，旋转之后就变成了<font color="red">左左</font>情况，所以第二步再进行一次<font color="red">左左旋转</font>，最后得到了一棵以k2为根的平衡二叉树树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右情况的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::DoubleRotateLR(TreeNode&lt;T&gt;* &amp;k3)</span><br><span class="line">&#123;</span><br><span class="line">    SingRotateRight(k3-&gt;lson);</span><br><span class="line">    SingRotateLeft(k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右左情况的旋转</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::DoubleRotateRL(TreeNode&lt;T&gt;* &amp;k3)</span><br><span class="line">&#123;</span><br><span class="line">    SingRotateLeft(k3-&gt;rson);</span><br><span class="line">    SingRotateRight(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第七步：插入"><a href="#第七步：插入" class="headerlink" title="第七步：插入"></a>第七步：插入</h4><p>插入的方法和二叉查找树基本一样，区别是，插入完成后需要从插入的节点开始维护一个到根节点的路径，每经过一个节点都要维持树的平衡。维持树的平衡要根据高度差的特点选择不同的旋转算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insertpri(TreeNode&lt;T&gt;* &amp;node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//如果节点为空,就在此节点处加入x信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        node=<span class="keyword">new</span> TreeNode&lt;T&gt;();</span><br><span class="line">        node-&gt;data=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;data&gt;x)<span class="comment">//如果x小于节点的值,就继续在节点的左子树中插入x</span></span><br><span class="line">    &#123;</span><br><span class="line">        insertpri(node-&gt;lson,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            <span class="keyword">if</span>(x&lt;node-&gt;lson-&gt;data)</span><br><span class="line">                SingRotateLeft(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                DoubleRotateLR(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;data&lt;x)<span class="comment">//如果x大于节点的值,就继续在节点的右子树中插入x</span></span><br><span class="line">    &#123;</span><br><span class="line">        insertpri(node-&gt;rson,x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;rson)-height(node-&gt;lson))<span class="comment">//如果高度之差为2的话就失去了平衡,需要旋转</span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;node-&gt;rson-&gt;data)</span><br><span class="line">                SingRotateRight(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                DoubleRotateRL(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ++(node-&gt;freq);<span class="comment">//如果相等,就把频率加1</span></span><br><span class="line">    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insert(T x)</span><br><span class="line">&#123;</span><br><span class="line">    insertpri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第八步：查找"><a href="#第八步：查找" class="headerlink" title="第八步：查找"></a>第八步：查找</h4><p>和二叉查找树相比，查找方法没有变法，不过根据存储的特性，AVL树能维持在一个O(logN)的稳定的时间，而二叉查找树则相当不稳定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::findpri(TreeNode&lt;T&gt;* node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)<span class="comment">//如果节点为空说明没找到,返回NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;data&gt;x)<span class="comment">//如果x小于节点的值,就继续在节点的左子树中查找x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findpri(node-&gt;lson,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;data&lt;x)<span class="comment">//如果x大于节点的值,就继续在节点的左子树中查找x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> findpri(node-&gt;rson,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> node;<span class="comment">//如果相等,就找到了此节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">TreeNode&lt;T&gt;* AVLTree&lt;T&gt;::find(T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> findpri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第九步：删除"><a href="#第九步：删除" class="headerlink" title="第九步：删除"></a>第九步：删除</h4><p>删除的方法也和二叉查找树的一致，区别是，删除完成后，需要从删除节点的父亲开始向上维护树的平衡一直到根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::Deletepri(TreeNode&lt;T&gt;* &amp;node,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> ;<span class="comment">//没有找到值是x的节点</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">         Deletepri(node-&gt;lson,x);<span class="comment">//如果x小于节点的值,就继续在节点的左子树中删除x</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;rson)-height(node-&gt;lson))</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;rson-&gt;lson!=<span class="literal">NULL</span>&amp;&amp;(height(node-&gt;rson-&gt;lson)&gt;height(node-&gt;rson-&gt;rson)) )</span><br><span class="line">                DoubleRotateRL(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                SingRotateRight(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">         Deletepri(node-&gt;rson,x);<span class="comment">//如果x大于节点的值,就继续在节点的右子树中删除x</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;lson-&gt;rson!=<span class="literal">NULL</span>&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))</span><br><span class="line">                DoubleRotateLR(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                SingRotateLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果相等,此节点就是要删除的节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;lson&amp;&amp;node-&gt;rson)<span class="comment">//此节点有两个儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode&lt;T&gt;* temp=node-&gt;rson;<span class="comment">//temp指向节点的右儿子</span></span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;lson!=<span class="literal">NULL</span>) temp=temp-&gt;lson;<span class="comment">//找到右子树中值最小的节点</span></span><br><span class="line">            <span class="comment">//把右子树中最小节点的值赋值给本节点</span></span><br><span class="line">            node-&gt;data=temp-&gt;data;</span><br><span class="line">            node-&gt;freq=temp-&gt;freq;</span><br><span class="line">            Deletepri(node-&gt;rson,temp-&gt;data);<span class="comment">//删除右子树中最小值的节点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>==height(node-&gt;lson)-height(node-&gt;rson))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;lson-&gt;rson!=<span class="literal">NULL</span>&amp;&amp; (height(node-&gt;lson-&gt;rson)&gt;height(node-&gt;lson-&gt;lson) ))</span><br><span class="line">                    DoubleRotateLR(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    SingRotateLeft(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//此节点有1个或0个儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode&lt;T&gt;* temp=node;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;lson==<span class="literal">NULL</span>)<span class="comment">//有右儿子或者没有儿子</span></span><br><span class="line">            node=node-&gt;rson;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;rson==<span class="literal">NULL</span>)<span class="comment">//有左儿子</span></span><br><span class="line">            node=node-&gt;lson;</span><br><span class="line">            <span class="keyword">delete</span>(temp);</span><br><span class="line">            temp=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    node-&gt;hgt=Max(height(node-&gt;lson),height(node-&gt;rson))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::Delete(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Deletepri(root,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第十步：中序遍历"><a href="#第十步：中序遍历" class="headerlink" title="第十步：中序遍历"></a>第十步：中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::insubtree(TreeNode&lt;T&gt;* node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    insubtree(node-&gt;lson);<span class="comment">//先遍历左子树</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;node-&gt;data&lt;&lt;<span class="string">" "</span>;<span class="comment">//输出根节点</span></span><br><span class="line">    insubtree(node-&gt;rson);<span class="comment">//再遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> AVLTree&lt;T&gt;::traversal()</span><br><span class="line">&#123;</span><br><span class="line">    insubtree(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第十一步：关于效率"><a href="#第十一步：关于效率" class="headerlink" title="第十一步：关于效率"></a>第十一步：关于效率</h4><p>此数据结构插入、查找和删除的时间复杂度均为O(logN)，但是插入和删除需要额外的旋转算法需要的时间，有时旋转过多也会影响效率。</p>
<p>关于递归和非递归。我用的是递归的方法进行插入，查找和删除，而非递归的方法一般来说要比递归的方法快很多，但是我感觉非递归的方法写出来会比较困难，所以我还是选择了递归的方法。</p>
<p>还有一种效率的问题是关于高度信息的存储，由于我们需要的仅仅是高度的差，不需要知道这棵树的高度，所以只需要使用两个二进制位就可以表示这个差。这样可以避免平衡因子的重复计算，可以稍微的加快一些速度，不过代码也丧失了相对简明性和清晰度。如果采用递归写法的话，这种微加速就更显得微乎其微了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/12/平衡二叉查找树-AVL树/" data-id="ciqkep7vm001no0qyojzbiwmg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树结构/">树结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-之守护进程、僵死进程与孤儿进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/11/Linux-之守护进程、僵死进程与孤儿进程/" class="article-date">
  <time datetime="2016-03-11T14:19:57.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/11/Linux-之守护进程、僵死进程与孤儿进程/">Linux 之守护进程、僵死进程与孤儿进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。<br>由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<h4 id="僵死进程的危害："><a href="#僵死进程的危害：" class="headerlink" title="僵死进程的危害："></a>僵死进程的危害：</h4><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p>一个进程如果只复制fork子进程而不负责对子进程进行wait()或是waitpid()调用来释放其所占有资源的话，那么就会产生很多的僵死进程，如果要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会编程孤儿进程，从而被init所收养，这样init就会释放所有的僵死进程所占有的资源，从而结束僵死进程。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</p>
<p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。</p>
<p>一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</p>
<p>守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</p>
<h3 id="创建守护进程步骤"><a href="#创建守护进程步骤" class="headerlink" title="创建守护进程步骤"></a>创建守护进程步骤</h3><p>首先我们要了解一些基本概念：</p>
<h5 id="进程组-："><a href="#进程组-：" class="headerlink" title="进程组 ："></a>进程组 ：</h5><ol>
<li>每个进程也属于一个进程组</li>
<li>每个进程主都有一个进程组号，该号等于该进程组组长的PID号 .</li>
<li>一个进程只能为它自己或子进程设置进程组ID号</li>
</ol>
<h4 id="会话期："><a href="#会话期：" class="headerlink" title="会话期："></a>会话期：</h4><p>会话期(session)是一个或多个进程组的集合。</p>
<p>setsid()函数可以建立一个对话期：</p>
<p>如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。</p>
<p>(1).此进程变成该对话期的首进程</p>
<p>(2)此进程变成一个新进程组的组长进程。</p>
<p>(3)此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。</p>
<p>(4)为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行</p>
<p>现在我们来给出创建守护进程所需步骤：</p>
<p>编写守护进程的一般步骤步骤：</p>
<p>（1）在父进程中执行fork并exit推出；</p>
<p>（2）在子进程中调用setsid函数创建新的会话；</p>
<p>（3）在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；</p>
<p>（4）在子进程中调用umask函数，设置进程的umask为0；</p>
<p>（5）在子进程中关闭任何不需要的文件描述符</p>
<p>说明：</p>
<p>1: 在后台运行。</p>
<p>为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pid=fork())</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//是父进程，结束父进程，子进程继续</span></span><br></pre></td></tr></table></figure></p>
<p>2: 脱离控制终端，登录会话和进程组</p>
<p>有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。<br>控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid();</span><br></pre></td></tr></table></figure></p>
<p>说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。</p>
<p>3: 禁止进程重新打开控制终端</p>
<p>现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pid=fork())</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//结束第一子进程，第二子进程继续（第二子进程不再是会话组长）</span></span><br></pre></td></tr></table></figure></p>
<p>4: 关闭打开的文件描述符</p>
<p>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; MAXFILE; i++)</span><br><span class="line">    close(i);</span><br></pre></td></tr></table></figure></p>
<p>5: 改变当前工作目录</p>
<p>进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如/tmpchdir(“/“)</p>
<p>6: 重设文件创建掩模</p>
<p>进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);</p>
<p>7: 处理SIGCHLD信号</p>
<p>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD,SIG_IGN);</span><br></pre></td></tr></table></figure></p>
<p>这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。</p>
<h4 id="守护进程实例"><a href="#守护进程实例" class="headerlink" title="守护进程实例"></a>守护进程实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 守护进程初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_daemon</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork error !\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);        <span class="comment">// 父进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setsid();           <span class="comment">// 子进程开启新会话，并成为会话首进程和组长进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork error !\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);        <span class="comment">// 结束第一子进程，第二子进程不再是会话首进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    chdir(<span class="string">"/tmp"</span>);      <span class="comment">// 改变工作目录</span></span><br><span class="line">    umask(<span class="number">0</span>);           <span class="comment">// 重设文件掩码</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; getdtablesize(); ++i) &#123;</span><br><span class="line">       close(i);        <span class="comment">// 关闭打开的文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fp;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line">    <span class="keyword">char</span> buf[] = &#123;<span class="string">"This is a daemon:  "</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *datetime;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//printf("The NOFILE is: %d\n", NOFILE);</span></span><br><span class="line">    <span class="comment">//printf("The tablesize is: %d\n", getdtablesize());</span></span><br><span class="line">    <span class="comment">//printf("The pid is: %d\n", getpid());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Daemon 进程</span></span><br><span class="line">    init_daemon();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔一分钟记录运行状态</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == (fp = open(<span class="string">"/tmp/daemon.log"</span>, O_CREAT|O_WRONLY|O_APPEND, <span class="number">0600</span>))) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Open file error !\n"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        write(fp, buf, len);</span><br><span class="line">        t = time(<span class="number">0</span>);</span><br><span class="line">        datetime = asctime(localtime(&amp;t));</span><br><span class="line">        len = <span class="built_in">strlen</span>(datetime);</span><br><span class="line">        write(fp, datetime, len);</span><br><span class="line">        close(fp);</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用库函数daemon-创建守护进程"><a href="#利用库函数daemon-创建守护进程" class="headerlink" title="利用库函数daemon()创建守护进程"></a>利用库函数daemon()创建守护进程</h4><p>其实我们完全可以利用daemon()函数创建守护进程，其函数原型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int daemon(int nochdir, int noclose);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The daemon() function is for programs wishing to detach themselves from</span><br><span class="line">       the controlling terminal and run in the background as system daemons.</span><br><span class="line"></span><br><span class="line">       If nochdir is zero, daemon()  changes  the  process’s  current  working</span><br><span class="line">       directory to the root directory ("/"); otherwise,</span><br><span class="line"></span><br><span class="line">       If  noclose is zero, daemon() redirects standard input, standard output</span><br><span class="line">       and standard error to /dev/null; otherwise,  no  changes  are  made  to</span><br><span class="line">       these file descriptors.</span><br><span class="line"></span><br><span class="line">功能：创建一个守护进程</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">nochdir：=0将当前目录更改至“/”</span><br><span class="line"></span><br><span class="line">noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">成功：0</span><br><span class="line"></span><br><span class="line">失败：-1</span><br></pre></td></tr></table></figure>
<p>现在我们利用daemon()改写刚才那个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ERR_EXIT(m) \</span><br><span class="line">do\</span><br><span class="line">&#123;\</span><br><span class="line">    perror(m);\</span><br><span class="line">    exit(EXIT_FAILURE);\</span><br><span class="line">&#125;\</span><br><span class="line">while (<span class="number">0</span>);\</span><br><span class="line"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_daemon</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>(daemon(<span class="number">0</span>,<span class="number">0</span>) == -<span class="number">1</span>)</span><br><span class="line">        ERR_EXIT(<span class="string">"daemon error"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fd = open(<span class="string">"daemon.log"</span>,O_WRONLY|O_CREAT|O_APPEND,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == -<span class="number">1</span>)</span><br><span class="line">            ERR_EXIT(<span class="string">"open error"</span>);</span><br><span class="line">        t = time(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> *buf = asctime(localtime(&amp;t));</span><br><span class="line">        write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/11/Linux-之守护进程、僵死进程与孤儿进程/" data-id="ciqkep7yc004ko0qyiip5e0hl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IO-多路复用之select、poll、epoll详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/11/IO-多路复用之select、poll、epoll详解/" class="article-date">
  <time datetime="2016-03-11T12:31:52.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/11/IO-多路复用之select、poll、epoll详解/">IO 多路复用之select、poll、epoll详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readfds, fd_set *writefds,</span><br><span class="line">            fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。但是select有一下三个缺点：</p>
<ol>
<li>当个进程能够监控的文件描述符的数量受到限制（最大为1024，由FD_SETSIZE宏定义决定，修改需要重新编译内核）</li>
<li>每一次调用select，都需要将文件描述符set复制到内核里面，增加了系统开销</li>
<li>select采用轮询的方式，每一次内核都要遍历 [0，maxfdp1)这么多个文件描述符，即使文件描述符set里面只有一<br>个值为maxfdp的文件描述符，而且返回的时候，程序需要遍历所有监控的文件描述符来获得可读写的文件描述符</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pollfd &#123;</span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><h4 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
<p>1: int epoll_create(int size):</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>2: int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event):<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数是对指定描述符fd执行op操作。</span><br><span class="line">-<span class="ruby"> epfd：是epoll_create()的返回值。</span><br><span class="line"></span>-<span class="ruby"> op：表示op操作，用三个宏来表示：添加<span class="constant">EPOLL_CTL_ADD</span>，删除<span class="constant">EPOLL_CTL_DEL</span>，修改<span class="constant">EPOLL_CTL_MOD</span>。</span><br><span class="line"></span>      分别添加、删除和修改对fd的监听事件。</span><br><span class="line">-<span class="ruby"> fd：是需要监听的fd（文件描述符）</span><br><span class="line"></span>-<span class="ruby"> epoll_event：是告诉内核需要监听什么事</span></span><br></pre></td></tr></table></figure></p>
<p>struct epoll_event结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> epoll_event &#123;</span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个</span><br><span class="line">              socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>
<p>3: int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</p>
<p>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<h4 id="epoll的优点主要是一下几个方面："><a href="#epoll的优点主要是一下几个方面：" class="headerlink" title="epoll的优点主要是一下几个方面："></a>epoll的优点主要是一下几个方面：</h4><ol>
<li><p>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
</li>
<li><p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</p>
</li>
<li><p>文件描述符只需要复制一次到内核，不需要每一次调用函数都进行文件描述符的内核复制</p>
</li>
</ol>
<p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>
<p>下面是在<a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="external">这里</a>复制的一份epoll的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IPADDRESS   <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT        <span class="number">8787</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXSIZE     <span class="number">1024</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LISTENQ     <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FDSIZE      <span class="number">1000</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EPOLLEVENTS <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="comment">//创建套接字并进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="comment">//IO多路复用epoll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">struct</span> epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd;</span><br><span class="line">    listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line">    listen(listenfd,LISTENQ);</span><br><span class="line">    do_epoll(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in servaddr;</span><br><span class="line">    listenfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error:"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr)) == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind error: "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event events[EPOLLEVENTS];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE);</span><br><span class="line">    <span class="comment">//创建一个描述符</span></span><br><span class="line">    epollfd = epoll_create(FDSIZE);</span><br><span class="line">    <span class="comment">//添加监听描述符事件</span></span><br><span class="line">    add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取已经准备好的描述符事件</span></span><br><span class="line">        ret = epoll_wait(epollfd,events,EPOLLEVENTS,-<span class="number">1</span>);</span><br><span class="line">        handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">struct</span> epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//进行选好遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">        <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clifd;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">    <span class="keyword">socklen_t</span>  cliaddrlen;</span><br><span class="line">    clifd = accept(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;cliaddrlen);</span><br><span class="line">    <span class="keyword">if</span> (clifd == -<span class="number">1</span>)</span><br><span class="line">        perror(<span class="string">"accpet error:"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);</span><br><span class="line">        <span class="comment">//添加一个客户描述符和事件</span></span><br><span class="line">        add_event(epollfd,clifd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"read error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);</span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写</span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite;</span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event ev;</span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liubigbin.github.io/2016/03/11/IO-多路复用之select、poll、epoll详解/" data-id="ciqkep7yu005mo0qyzz9td7zj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C与C/">C与C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">10</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11-常规新特性/">C++11 常规新特性</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java底层机制/">Java底层机制</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-网络编程/">Linux 网络编程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux命令/">Linux命令</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux权限管理/">Linux权限管理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux用户管理/">Linux用户管理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux进程间通信/">Linux进程间通信</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图与树/">图与树</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树结构/">树结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/棋盘动态规划/">棋盘动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11-常规新特性/" style="font-size: 18.33px;">C++11 常规新特性</a> <a href="/tags/Java底层机制/" style="font-size: 16.67px;">Java底层机制</a> <a href="/tags/Linux-网络编程/" style="font-size: 16.67px;">Linux 网络编程</a> <a href="/tags/Linux命令/" style="font-size: 16.67px;">Linux命令</a> <a href="/tags/Linux权限管理/" style="font-size: 10px;">Linux权限管理</a> <a href="/tags/Linux用户管理/" style="font-size: 15px;">Linux用户管理</a> <a href="/tags/Linux进程间通信/" style="font-size: 16.67px;">Linux进程间通信</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/位运算/" style="font-size: 10px;">位运算</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/图与树/" style="font-size: 15px;">图与树</a> <a href="/tags/推荐算法/" style="font-size: 10px;">推荐算法</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/树结构/" style="font-size: 13.33px;">树结构</a> <a href="/tags/棋盘动态规划/" style="font-size: 11.67px;">棋盘动态规划</a> <a href="/tags/爬虫/" style="font-size: 11.67px;">爬虫</a> <a href="/tags/设计模式/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/随记/" style="font-size: 11.67px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/13/LCA之Tarjan算法/">LCA之Tarjan算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/ST算法/">ST算法</a>
          </li>
        
          <li>
            <a href="/2016/07/12/线段树/">线段树</a>
          </li>
        
          <li>
            <a href="/2016/07/12/并查集/">并查集</a>
          </li>
        
          <li>
            <a href="/2016/07/11/UDP之connect/">UDP之connect</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiuYongbin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>